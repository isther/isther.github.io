<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Go语言基础之并发 | Ther's Blog</title>
<meta name=keywords content="Golang,Go,并发,goroutine,channel,select,原子操作,并发安全和锁,学习笔记">
<meta name=description content="并发">
<meta name=author content="Ther">
<link rel=canonical href=https://canonical.url/to/page>
<meta name=google-site-verification content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.niuwx.cn/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.niuwx.cn/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=https://www.niuwx.cn/favicon.ico>
<link rel=apple-touch-icon href=https://www.niuwx.cn/favicon.ico>
<link rel=mask-icon href=https://www.niuwx.cn/favicon.ico>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Go语言基础之并发">
<meta property="og:description" content="并发">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-18T22:33:51+08:00">
<meta property="article:modified_time" content="2021-03-18T22:33:51+08:00"><meta property="og:site_name" content="Ther's Blog">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Go语言基础之并发">
<meta name=twitter:description content="并发">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.niuwx.cn/posts/"},{"@type":"ListItem","position":2,"name":"Go语言基础之并发","item":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go语言基础之并发","name":"Go语言基础之并发","description":"并发","keywords":["Golang","Go","并发","goroutine","channel","select","原子操作","并发安全和锁","学习笔记"],"articleBody":"并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。\n并发和并行 并发：同一时间段内执行多个任务。\n并行：同一时刻执行多个任务。\nGo语言的并发通过goroutine实现。goroutine类似于进程，属于用户态的进程。可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时调度完成，而线程是由操作系统调度完成。\nGo语言还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言并成的CSP并发模式的重要实现基础。\ngoroutine Go语言中goroutine的概念类似于线程但 goroutine是由Go的运行时（runtime）调度和管理的。\ngoroutine的使用 Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加go关键字，就可以为一个函数创建一个goroutine。\n一个gotoutine必定对应一个函数，可以创建的多个goroutine去执行相同的函数。\n启动单个goroutine 例如：\npackage main import \"fmt\" func hello() { fmt.Println(\"Hello goroutine!\") } func main() { hello() fmt.Println(\"main goroutine done!\") } 这个例子的输出结果是Hello goroutine! 和main goroutine done!。\npackage main import \"fmt\" func hello() { fmt.Println(\"Hello goroutine!\") } func main() { go hello() fmt.Println(\"main goroutine done!\") } 这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了main goroutine done!，这是为什么呢？\n在程序启动时，Go程序为main()函数创建一个默认的goroutine，当main()函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，hello()还没来得及进行，程序就结束了。\n如何才能将hello()进行呢？最简单粗暴的方式就是time.Sleep。\npackage main import ( \"fmt\" \"time\" ) func hello() { fmt.Println(\"Hello goroutine!\") } func main() { go hello() fmt.Println(\"main goroutine done!\") time.Sleep(1000) } 执行上面的代码会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。\n启动多个goroutine 例子：\npackage main import ( \"fmt\" \"sync\" ) var wg sync.WaitGroup func hello(i int) { defer wg.Done() //goroutine结束也要登记,-1 \tfmt.Println(\"Hello goroutine\", i) } func main() { for i := 0; i 10; i++ { wg.Add(1) //启动一个goroutine就登记一次,+1 \tgo hello(i) } wg.Wait() //等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。\ngoroutine与线程 goroutine调度 GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。\nGOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。\nGo语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。\nGo1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。\n我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如：\npackage main import ( \"fmt\" \"runtime\" \"time\" ) func a() { for i := 1; i 10; i++ { fmt.Println(\"A:\", i) } } func b() { for i := 1; i 10; i++ { fmt.Println(\"B:\", i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second) } 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。\nGo语言中的操作系统线程和goroutine的关系：\n 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。  channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\nchannel类型 channel是一种类型，一种引用类型。声明格式如下：\nvar 变量 chan 元素类型 例如：\nvar ch1 chan int var ch2 chan bool var ch3 chan []int 创建channel 通道是引用类型，通道类型的空值是nil。\nvar ch chan int fmt.Println(ch) //nil 声明的通道在make初始化后才能使用。\n格式如下：\nmake(chan 元素类型, [大小]) 例如：\nch1 := make(chan int) ch2 := make(chan bool) ch3 := make(chan []int) channel操作 通道有发送（send）、接收(receive）和关闭（close）三种操作。\n发送和接收都使用符号。\n现在我们先使用以下语句定义一个通道：\nch := make(chan int) 发送 将一个值发送到通道中。\nch  10 // 把10发送到ch中 接收 从一个通道中接收值。\nx :=  ch // 从ch中接收值并赋值给变量x ch // 从ch中接收值，忽略结果 关闭 我们通过调用内置的close函数来关闭通道。\nclose(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n关闭后的通道有以下特点：\n 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。  无缓冲的通道 无缓冲的通道又称为阻塞的通道。例如：\npackage main import ( \"fmt\" ) func main() { ch := make(chan int) ch  10 fmt.Println(\"成功\") } 这段代码在执行时会出现错误\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5f exit status 2 因为ch := make(chan int)创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。\n上面的代码会阻塞在ch 这一行代码形成死锁。\n解决方法：\n一种方法就是启用一个goroutine去接受，例如：\npackage main import ( \"fmt\" ) func rec(c chan int) { ret := c fmt.Println(\"成功\", ret) } func main() { ch := make(chan int) go rec(ch) ch  10 fmt.Println(\"成功\") } 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。\n使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。\n有缓冲的通道 解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：\nfunc main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 \tch  10 fmt.Println(\"发送成功\") } 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量。\nfor range 从通道循环取值 当向通道中发送完数据时，我们可以通过close函数来关闭通道。\n当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？\n看这个例子：\npackage main import \"fmt\" func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 \tgo func() { for i := 0; i 100; i++ { ch1  i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 \tgo func() { for { i, ok := ch1 // 通道关闭后再取值ok=false \tif !ok { break } ch2  i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 \tfor i := range ch2 { // 通道关闭后会退出for range循环 \tfmt.Println(i) } } 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range。\n单向通道 有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。\nGo语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：\nfunc counter(out chan int) { for i := 0; i 100; i++ { out  i } close(out) } func squarer(out chan int, in chan int) { for i := range in { out  i * i } close(out) } func printer(in chan int) { for i := range in { fmt.Println(i) } } func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) } 其中，\n chan是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作； 是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。  在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。\nworker pool （goroutine池） 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。\n例如：\npackage main import ( \"fmt\" \"time\" ) func worker(id int, jobs chan int, results chan int) { for i := range jobs { fmt.Printf(\"worker:%d start job:%d\\n\", id, i) time.Sleep(time.Second) fmt.Printf(\"worker:%d end job:%d\\n\", id, i) results  i * 2 } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) //只开启3个goroutine \tfor w := 1; w  3; w++ { go worker(w, jobs, results) } //5个任务 \tfor j := 1; j  5; j++ { jobs  j } close(jobs) for a := 1; a  5; a++ { results } } select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：\nfor{ // 尝试从ch1接收值  data, ok := ch1 // 尝试从ch2接收值  data, ok := ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。\nselect的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：\nselect{ case ch1: ... case data := ch2: ... case ch3data: ... default: 默认操作 } 举个例子来演示下select的使用：\nfunc main() { ch := make(chan int, 1) for i := 0; i 10; i++ { select { case x := ch: fmt.Println(x) case ch  i: } } } 使用select语句能提高代码的可读性。\n 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select{}会一直等待，可用于阻塞main函数。  并发安全和锁 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。\n举个例子：\npackage main import ( \"fmt\" \"sync\" ) var x int64 var wg sync.WaitGroup func add() { for i := 0; i 50000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。\n互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：\npackage main import ( \"fmt\" \"sync\" ) var x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i 50000; i++ { lock.Lock() //上锁 \tx = x + 1 lock.Unlock() //解锁 \t} wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。\n读写互斥锁 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。\n读写锁示例：\nvar ( x int64 wg sync.WaitGroup //lock sync.Mutex \trwlock sync.RWMutex ) func write() { // lock.Lock() // 加互斥锁 \trwlock.Lock() // 加写锁 \tx = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 \trwlock.Unlock() // 解写锁 \t// lock.Unlock() // 解互斥锁 \twg.Done() } func read() { // lock.Lock() // 加互斥锁 \trwlock.RLock() // 加读锁 \ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 \trwlock.RUnlock() // 解读锁 \t// lock.Unlock() // 解互斥锁 \twg.Done() } func main() { start := time.Now() for i := 0; i 10; i++ { wg.Add(1) go write() } for i := 0; i 1000; i++ { wg.Add(1) go read() } wg.Wait() end := time.Now() fmt.Println(end.Sub(start)) } 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。\nsync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：\n   方法名 功能     (wg * WaitGroup) Add(delta int) 计数器+delta   (wg *WaitGroup) Done() 计数器-1   (wg *WaitGroup) Wait() 阻塞直到计数器变为0    sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。\n我们利用sync.WaitGroup将上面的代码优化一下：\nvar wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\"Hello Goroutine!\") } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 \tfmt.Println(\"main goroutine done!\") wg.Wait() } 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。\nsync.Once 说在前面的话：这是一个进阶知识点。\n在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。\nsync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) {} 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用。\n加载配置文件示例 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\nvar icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \"left\": loadIcon(\"left.png\"), \"up\": loadIcon(\"up.png\"), \"right\": loadIcon(\"right.png\"), \"down\": loadIcon(\"down.png\"), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\nfunc loadIcons() { icons = make(map[string]image.Image) icons[\"left\"] = loadIcon(\"left.png\") icons[\"up\"] = loadIcon(\"up.png\") icons[\"right\"] = loadIcon(\"right.png\") icons[\"down\"] = loadIcon(\"down.png\") } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。\n使用sync.Once改造的示例代码如下：\nvar icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \"left\": loadIcon(\"left.png\"), \"up\": loadIcon(\"up.png\"), \"right\": loadIcon(\"right.png\"), \"down\": loadIcon(\"down.png\"), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 并发安全的单例模式 下面是借助sync.Once实现的并发安全的单例模式：\npackage singleton import ( \"sync\" ) type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = \u0026singleton{} }) return instance } sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\nsync.Map Go语言中内置的map不是并发安全的。请看下面的示例：\nvar m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\"k=:%v,v:=%v\\n\", key, get(key)) wg.Done() }(i) } wg.Wait() } 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。\n像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。\nvar m = sync.Map{} func main() { wg := sync.WaitGroup{} for i := 0; i 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(\"k=:%v,v:=%v\\n\", key, value) wg.Done() }(i) } wg.Wait() } 原子操作 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。\n示例 我们填写一个示例来比较下互斥锁和原子操作的性能。\npackage main import ( \"fmt\" \"sync\" \"sync/atomic\" \"time\" ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(\u0026a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(\u0026a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i 1000; i++ { wg.Add(1) go func() { c.Inc() wg.Done() }() } wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start)) } func main() { c1 := CommonCounter{} // 非并发安全 \ttest(c1) c2 := MutexCounter{} // 使用互斥锁实现并发安全 \ttest(\u0026c2) c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高 \ttest(\u0026c3) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好\n","wordCount":"1383","inLanguage":"en","datePublished":"2021-03-18T22:33:51+08:00","dateModified":"2021-03-18T22:33:51+08:00","author":{"@type":"Person","name":"Ther"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/"},"publisher":{"@type":"Organization","name":"Ther's Blog","logo":{"@type":"ImageObject","url":"https://www.niuwx.cn/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.niuwx.cn/ accesskey=h title="Ther's Blog (Alt + H)">Ther's Blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.niuwx.cn/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://www.niuwx.cn/archive title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://www.niuwx.cn/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://www.niuwx.cn/tags title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.niuwx.cn/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://www.niuwx.cn/>Home</a>&nbsp;»&nbsp;<a href=https://www.niuwx.cn/posts/>Posts</a></div>
<h1 class=post-title>
Go语言基础之并发
</h1>
<div class=post-description>
并发
</div>
<div class=post-meta>March 18, 2021&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Ther&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Golang/Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header> <div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e5%b9%b6%e5%8f%91%e5%92%8c%e5%b9%b6%e8%a1%8c aria-label=并发和并行>并发和并行</a></li>
<li>
<a href=#goroutine aria-label=goroutine>goroutine</a><ul>
<li>
<a href=#goroutine%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=goroutine的使用>goroutine的使用</a></li>
<li>
<a href=#%e5%90%af%e5%8a%a8%e5%8d%95%e4%b8%aagoroutine aria-label=启动单个goroutine>启动单个goroutine</a></li>
<li>
<a href=#%e5%90%af%e5%8a%a8%e5%a4%9a%e4%b8%aagoroutine aria-label=启动多个goroutine>启动多个goroutine</a></li></ul>
</li>
<li>
<a href=#goroutine%e4%b8%8e%e7%ba%bf%e7%a8%8b aria-label=goroutine与线程>goroutine与线程</a><ul>
<li>
<a href=#goroutine%e8%b0%83%e5%ba%a6 aria-label=goroutine调度>goroutine调度</a></li>
<li>
<a href=#gomaxprocs aria-label=GOMAXPROCS>GOMAXPROCS</a></li></ul>
</li>
<li>
<a href=#channel aria-label=channel>channel</a><ul>
<li>
<a href=#channel%e7%b1%bb%e5%9e%8b aria-label=channel类型>channel类型</a></li>
<li>
<a href=#%e5%88%9b%e5%bb%bachannel aria-label=创建channel>创建channel</a></li>
<li>
<a href=#channel%e6%93%8d%e4%bd%9c aria-label=channel操作>channel操作</a><ul>
<li>
<a href=#%e5%8f%91%e9%80%81 aria-label=发送>发送</a></li>
<li>
<a href=#%e6%8e%a5%e6%94%b6 aria-label=接收>接收</a></li>
<li>
<a href=#%e5%85%b3%e9%97%ad aria-label=关闭>关闭</a></li></ul>
</li>
<li>
<a href=#%e6%97%a0%e7%bc%93%e5%86%b2%e7%9a%84%e9%80%9a%e9%81%93 aria-label=无缓冲的通道>无缓冲的通道</a></li>
<li>
<a href=#%e6%9c%89%e7%bc%93%e5%86%b2%e7%9a%84%e9%80%9a%e9%81%93 aria-label=有缓冲的通道>有缓冲的通道</a></li>
<li>
<a href=#for-range-%e4%bb%8e%e9%80%9a%e9%81%93%e5%be%aa%e7%8e%af%e5%8f%96%e5%80%bc aria-label="for range 从通道循环取值">for range 从通道循环取值</a></li>
<li>
<a href=#%e5%8d%95%e5%90%91%e9%80%9a%e9%81%93 aria-label=单向通道>单向通道</a></li></ul>
</li>
<li>
<a href=#worker-pool-goroutine%e6%b1%a0 aria-label="worker pool （goroutine池）">worker pool （goroutine池）</a></li>
<li>
<a href=#select%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 aria-label=select多路复用>select多路复用</a></li>
<li>
<a href=#%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e5%92%8c%e9%94%81 aria-label=并发安全和锁>并发安全和锁</a><ul>
<li>
<a href=#%e4%ba%92%e6%96%a5%e9%94%81 aria-label=互斥锁>互斥锁</a></li>
<li>
<a href=#%e8%af%bb%e5%86%99%e4%ba%92%e6%96%a5%e9%94%81 aria-label=读写互斥锁>读写互斥锁</a></li>
<li>
<a href=#syncwaitgroup aria-label=sync.WaitGroup>sync.WaitGroup</a></li>
<li>
<a href=#synconce aria-label=sync.Once>sync.Once</a><ul>
<li>
<a href=#%e5%8a%a0%e8%bd%bd%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e7%a4%ba%e4%be%8b aria-label=加载配置文件示例>加载配置文件示例</a></li>
<li>
<a href=#%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e7%9a%84%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f aria-label=并发安全的单例模式>并发安全的单例模式</a></li></ul>
</li>
<li>
<a href=#syncmap aria-label=sync.Map>sync.Map</a></li></ul>
</li>
<li>
<a href=#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c aria-label=原子操作>原子操作</a><ul>
<li>
<a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。</p>
<h3 id=并发和并行>并发和并行<a hidden class=anchor aria-hidden=true href=#并发和并行>#</a></h3>
<p>并发：同一时间段内执行多个任务。</p>
<p>并行：同一时刻执行多个任务。</p>
<p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于进程，属于用户态的进程。可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时调度完成，而线程是由操作系统调度完成。</p>
<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是Go语言并成的CSP并发模式的重要实现基础。</p>
<h3 id=goroutine>goroutine<a hidden class=anchor aria-hidden=true href=#goroutine>#</a></h3>
<p>Go语言中<code>goroutine</code>的概念类似于线程但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。</p>
<h4 id=goroutine的使用>goroutine的使用<a hidden class=anchor aria-hidden=true href=#goroutine的使用>#</a></h4>
<p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>gotoutine</code>必定对应一个函数，可以创建的多个<code>goroutine</code>去执行相同的函数。</p>
<h4 id=启动单个goroutine>启动单个goroutine<a hidden class=anchor aria-hidden=true href=#启动单个goroutine>#</a></h4>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>() {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello goroutine!&#34;</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>hello</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main goroutine done!&#34;</span>)
}
</code></pre></div><p>这个例子的输出结果是<code>Hello goroutine!</code> 和<code>main goroutine done!</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>() {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello goroutine!&#34;</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>hello</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main goroutine done!&#34;</span>)
}
</code></pre></div><p>这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了<code>main goroutine done!</code>，这是为什么呢？</p>
<p>在程序启动时，Go程序为<code>main()</code>函数创建一个默认的goroutine，当<code>main()</code>函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，<code>hello()</code>还没来得及进行，程序就结束了。</p>
<p>如何才能将hello()进行呢？最简单粗暴的方式就是<code>time.Sleep</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>() {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello goroutine!&#34;</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>hello</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main goroutine done!&#34;</span>)
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1000</span>)
}
</code></pre></div><p>执行上面的代码会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
<h4 id=启动多个goroutine>启动多个goroutine<a hidden class=anchor aria-hidden=true href=#启动多个goroutine>#</a></h4>
<p>例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>() <span style=color:#75715e>//goroutine结束也要登记,-1
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello goroutine&#34;</span>, <span style=color:#a6e22e>i</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>) <span style=color:#75715e>//启动一个goroutine就登记一次,+1
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>hello</span>(<span style=color:#a6e22e>i</span>)
	}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>() <span style=color:#75715e>//等待所有登记的goroutine都结束
</span><span style=color:#75715e></span>}
</code></pre></div><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p>
<h3 id=goroutine与线程>goroutine与线程<a hidden class=anchor aria-hidden=true href=#goroutine与线程>#</a></h3>
<h4 id=goroutine调度>goroutine调度<a hidden class=anchor aria-hidden=true href=#goroutine调度>#</a></h4>
<p>GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<h4 id=gomaxprocs>GOMAXPROCS<a hidden class=anchor aria-hidden=true href=#gomaxprocs>#</a></h4>
<p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;runtime&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>a</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;A:&#34;</span>, <span style=color:#a6e22e>i</span>)
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>b</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;B:&#34;</span>, <span style=color:#a6e22e>i</span>)
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>GOMAXPROCS</span>(<span style=color:#ae81ff>1</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>a</span>()
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>b</span>()
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}
</code></pre></div><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。</p>
<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ol>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ol>
<h3 id=channel>channel<a hidden class=anchor aria-hidden=true href=#channel>#</a></h3>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h4 id=channel类型>channel类型<a hidden class=anchor aria-hidden=true href=#channel类型>#</a></h4>
<p><code>channel</code>是一种类型，一种引用类型。声明格式如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>变量</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>元素类型</span>
</code></pre></div><p>例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch1</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch2</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch3</span> <span style=color:#66d9ef>chan</span> []<span style=color:#66d9ef>int</span>
</code></pre></div><h4 id=创建channel>创建channel<a hidden class=anchor aria-hidden=true href=#创建channel>#</a></h4>
<p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ch</span>) <span style=color:#75715e>//nil
</span></code></pre></div><p>声明的通道在<code>make</code>初始化后才能使用。</p>
<p>格式如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>元素类型</span>, [<span style=color:#a6e22e>大小</span>])
</code></pre></div><p>例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ch1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
<span style=color:#a6e22e>ch2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
<span style=color:#a6e22e>ch3</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> []<span style=color:#66d9ef>int</span>)
</code></pre></div><h4 id=channel操作>channel操作<a hidden class=anchor aria-hidden=true href=#channel操作>#</a></h4>
<p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</code></pre></div><h5 id=发送>发送<a hidden class=anchor aria-hidden=true href=#发送>#</a></h5>
<p>将一个值发送到通道中。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>10</span> <span style=color:#75715e>// 把10发送到ch中
</span></code></pre></div><h5 id=接收>接收<a hidden class=anchor aria-hidden=true href=#接收>#</a></h5>
<p>从一个通道中接收值。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>ch</span> <span style=color:#75715e>// 从ch中接收值并赋值给变量x
</span><span style=color:#75715e></span><span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>       <span style=color:#75715e>// 从ch中接收值，忽略结果
</span></code></pre></div><h5 id=关闭>关闭<a hidden class=anchor aria-hidden=true href=#关闭>#</a></h5>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>close(<span style=color:#a6e22e>ch</span>)
</code></pre></div><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<h4 id=无缓冲的通道>无缓冲的通道<a hidden class=anchor aria-hidden=true href=#无缓冲的通道>#</a></h4>
<p>无缓冲的通道又称为阻塞的通道。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>10</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;成功&#34;</span>)
}
</code></pre></div><p>这段代码在执行时会出现错误</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>fatal error: all goroutines are asleep - deadlock!

goroutine <span style=color:#ae81ff>1</span> <span style=color:#f92672>[</span>chan send<span style=color:#f92672>]</span>:
main.main<span style=color:#f92672>()</span>
        E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5f
exit status <span style=color:#ae81ff>2</span>
</code></pre></div><p>因为<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁。</p>
<p>解决方法：</p>
<p>一种方法就是启用一个goroutine去接受，例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rec</span>(<span style=color:#a6e22e>c</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;成功&#34;</span>, <span style=color:#a6e22e>ret</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>rec</span>(<span style=color:#a6e22e>ch</span>)
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>10</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;成功&#34;</span>)
}
</code></pre></div><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h4 id=有缓冲的通道>有缓冲的通道<a hidden class=anchor aria-hidden=true href=#有缓冲的通道>#</a></h4>
<p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>) <span style=color:#75715e>// 创建一个容量为1的有缓冲区通道
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#ae81ff>10</span>
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;发送成功&#34;</span>)
}
</code></pre></div><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量。</p>
<h4 id=for-range-从通道循环取值>for range 从通道循环取值<a hidden class=anchor aria-hidden=true href=#for-range-从通道循环取值>#</a></h4>
<p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p>
<p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p>
<p>看这个例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#a6e22e>ch2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#75715e>// 开启goroutine将0~100的数发送到ch1中
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>100</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
			<span style=color:#a6e22e>ch1</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
		}
		close(<span style=color:#a6e22e>ch1</span>)
	}()
	<span style=color:#75715e>// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>for</span> {
			<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch1</span> <span style=color:#75715e>// 通道关闭后再取值ok=false
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
				<span style=color:#66d9ef>break</span>
			}
			<span style=color:#a6e22e>ch2</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>i</span>
		}
		close(<span style=color:#a6e22e>ch2</span>)
	}()
	<span style=color:#75715e>// 在主goroutine中从ch2中接收值打印
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ch2</span> { <span style=color:#75715e>// 通道关闭后会退出for range循环
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
	}

}
</code></pre></div><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p>
<h4 id=单向通道>单向通道<a hidden class=anchor aria-hidden=true href=#单向通道>#</a></h4>
<p>有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>counter</span>(<span style=color:#a6e22e>out</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>100</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>out</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>
	}
	close(<span style=color:#a6e22e>out</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>squarer</span>(<span style=color:#a6e22e>out</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>in</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>in</span> {
		<span style=color:#a6e22e>out</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>i</span>
	}
	close(<span style=color:#a6e22e>out</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>printer</span>(<span style=color:#a6e22e>in</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>in</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch1</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#a6e22e>ch2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>counter</span>(<span style=color:#a6e22e>ch1</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>squarer</span>(<span style=color:#a6e22e>ch2</span>, <span style=color:#a6e22e>ch1</span>)
	<span style=color:#a6e22e>printer</span>(<span style=color:#a6e22e>ch2</span>)
}
</code></pre></div><p>其中，</p>
<ul>
<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li>
<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li>
</ul>
<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>
<h3 id=worker-pool-goroutine池>worker pool （goroutine池）<a hidden class=anchor aria-hidden=true href=#worker-pool-goroutine池>#</a></h3>
<p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>jobs</span> <span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>results</span> <span style=color:#66d9ef>chan</span><span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>jobs</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;worker:%d start job:%d\n&#34;</span>, <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>i</span>)
		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;worker:%d end job:%d\n&#34;</span>, <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>i</span>)

		<span style=color:#a6e22e>results</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
	}
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>jobs</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>100</span>)
	<span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>100</span>)

    <span style=color:#75715e>//只开启3个goroutine
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>w</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>w</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>worker</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>jobs</span>, <span style=color:#a6e22e>results</span>)
	}
	<span style=color:#75715e>//5个任务
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>jobs</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>j</span>
	}

	close(<span style=color:#a6e22e>jobs</span>)

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>a</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>a</span><span style=color:#f92672>++</span> {
		<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>results</span>
	}
}

</code></pre></div><h3 id=select多路复用>select多路复用<a hidden class=anchor aria-hidden=true href=#select多路复用>#</a></h3>
<p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span>{
    <span style=color:#75715e>// 尝试从ch1接收值
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch1</span>
    <span style=color:#75715e>// 尝试从ch2接收值
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch2</span>
    <span style=color:#960050;background-color:#1e0010>…</span>
}
</code></pre></div><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>
<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>select</span>{
    <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch1</span>:
        <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch2</span>:
        <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ch3</span><span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>data</span>:
        <span style=color:#f92672>...</span>
    <span style=color:#66d9ef>default</span>:
        <span style=color:#a6e22e>默认操作</span>
}
</code></pre></div><p>举个例子来演示下<code>select</code>的使用：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>ch</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#66d9ef>select</span> {
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ch</span>:
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)
		<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ch</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>i</span>:
		}
	}
}
</code></pre></div><p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>
</ul>
<h3 id=并发安全和锁>并发安全和锁<a hidden class=anchor aria-hidden=true href=#并发安全和锁>#</a></h3>
<p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>
<p>举个例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int64</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>50000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
	}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>()
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>()
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)
}

</code></pre></div><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h4 id=互斥锁>互斥锁<a hidden class=anchor aria-hidden=true href=#互斥锁>#</a></h4>
<p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int64</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>() {
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>50000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>//上锁
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
		<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Unlock</span>() <span style=color:#75715e>//解锁
</span><span style=color:#75715e></span>	}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>()
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>()
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>x</span>)
}
</code></pre></div><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>
<h4 id=读写互斥锁>读写互斥锁<a hidden class=anchor aria-hidden=true href=#读写互斥锁>#</a></h4>
<p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<p>读写锁示例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> (
	<span style=color:#a6e22e>x</span>      <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>wg</span>     <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
	<span style=color:#75715e>//lock   sync.Mutex
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>rwlock</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>write</span>() {
	<span style=color:#75715e>// lock.Lock()   // 加互斥锁
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>// 加写锁
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>) <span style=color:#75715e>// 假设读操作耗时10毫秒
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>Unlock</span>()                   <span style=color:#75715e>// 解写锁
</span><span style=color:#75715e></span>	<span style=color:#75715e>// lock.Unlock()                     // 解互斥锁
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>read</span>() {
	<span style=color:#75715e>// lock.Lock()                  // 加互斥锁
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>RLock</span>()               <span style=color:#75715e>// 加读锁
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>) <span style=color:#75715e>// 假设读操作耗时1毫秒
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>rwlock</span>.<span style=color:#a6e22e>RUnlock</span>()             <span style=color:#75715e>// 解读锁
</span><span style=color:#75715e></span>	<span style=color:#75715e>// lock.Unlock()                // 解互斥锁
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>write</span>()
	}

	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>read</span>()
	}

	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
	<span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>))
}
</code></pre></div><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h4 id=syncwaitgroup>sync.WaitGroup<a hidden class=anchor aria-hidden=true href=#syncwaitgroup>#</a></h4>
<p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th style=text-align:center>方法名</th>
<th style=text-align:center>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>(wg * WaitGroup) Add(delta int)</td>
<td style=text-align:center>计数器+delta</td>
</tr>
<tr>
<td style=text-align:center>(wg *WaitGroup) Done()</td>
<td style=text-align:center>计数器-1</td>
</tr>
<tr>
<td style=text-align:center>(wg *WaitGroup) Wait()</td>
<td style=text-align:center>阻塞直到计数器变为0</td>
</tr>
</tbody>
</table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hello</span>() {
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello Goroutine!&#34;</span>)
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>hello</span>() <span style=color:#75715e>// 启动另外一个goroutine去执行hello函数
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;main goroutine done!&#34;</span>)
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
<h4 id=synconce>sync.Once<a hidden class=anchor aria-hidden=true href=#synconce>#</a></h4>
<p>说在前面的话：这是一个进阶知识点。</p>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Once</span>) <span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>()) {}
</code></pre></div><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p>
<h5 id=加载配置文件示例>加载配置文件示例<a hidden class=anchor aria-hidden=true href=#加载配置文件示例>#</a></h5>
<p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>icons</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loadIcons</span>() {
	<span style=color:#a6e22e>icons</span> = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span>{
		<span style=color:#e6db74>&#34;left&#34;</span>:  <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;left.png&#34;</span>),
		<span style=color:#e6db74>&#34;up&#34;</span>:    <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;up.png&#34;</span>),
		<span style=color:#e6db74>&#34;right&#34;</span>: <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;right.png&#34;</span>),
		<span style=color:#e6db74>&#34;down&#34;</span>:  <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;down.png&#34;</span>),
	}
}

<span style=color:#75715e>// Icon 被多个goroutine调用时不是并发安全的
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Icon</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>icons</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>loadIcons</span>()
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>icons</span>[<span style=color:#a6e22e>name</span>]
}
</code></pre></div><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loadIcons</span>() {
	<span style=color:#a6e22e>icons</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span>)
	<span style=color:#a6e22e>icons</span>[<span style=color:#e6db74>&#34;left&#34;</span>] = <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;left.png&#34;</span>)
	<span style=color:#a6e22e>icons</span>[<span style=color:#e6db74>&#34;up&#34;</span>] = <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;up.png&#34;</span>)
	<span style=color:#a6e22e>icons</span>[<span style=color:#e6db74>&#34;right&#34;</span>] = <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;right.png&#34;</span>)
	<span style=color:#a6e22e>icons</span>[<span style=color:#e6db74>&#34;down&#34;</span>] = <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;down.png&#34;</span>)
}
</code></pre></div><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>icons</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>loadIconsOnce</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Once</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>loadIcons</span>() {
	<span style=color:#a6e22e>icons</span> = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span>{
		<span style=color:#e6db74>&#34;left&#34;</span>:  <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;left.png&#34;</span>),
		<span style=color:#e6db74>&#34;up&#34;</span>:    <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;up.png&#34;</span>),
		<span style=color:#e6db74>&#34;right&#34;</span>: <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;right.png&#34;</span>),
		<span style=color:#e6db74>&#34;down&#34;</span>:  <span style=color:#a6e22e>loadIcon</span>(<span style=color:#e6db74>&#34;down.png&#34;</span>),
	}
}

<span style=color:#75715e>// Icon 是并发安全的
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Icon</span>(<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>image</span>.<span style=color:#a6e22e>Image</span> {
	<span style=color:#a6e22e>loadIconsOnce</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>loadIcons</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>icons</span>[<span style=color:#a6e22e>name</span>]
}
</code></pre></div><h5 id=并发安全的单例模式>并发安全的单例模式<a hidden class=anchor aria-hidden=true href=#并发安全的单例模式>#</a></h5>
<p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>singleton</span>

<span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;sync&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>singleton</span> <span style=color:#66d9ef>struct</span> {}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>instance</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>singleton</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>once</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Once</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetInstance</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>singleton</span> {
    <span style=color:#a6e22e>once</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#66d9ef>func</span>() {
        <span style=color:#a6e22e>instance</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>singleton</span>{}
    })
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>instance</span>
}
</code></pre></div><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h4 id=syncmap>sync.Map<a hidden class=anchor aria-hidden=true href=#syncmap>#</a></h4>
<p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>int</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>key</span>]
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>key</span>] = <span style=color:#a6e22e>value</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>20</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
			<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>n</span>)
			<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>n</span>)
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;k=:%v,v:=%v\n&#34;</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>key</span>))
			<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
		}(<span style=color:#a6e22e>i</span>)
	}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Map</span>{}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>20</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
			<span style=color:#a6e22e>key</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>n</span>)
			<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>n</span>)
			<span style=color:#a6e22e>value</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#a6e22e>key</span>)
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;k=:%v,v:=%v\n&#34;</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span>)
			<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
		}(<span style=color:#a6e22e>i</span>)
	}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
}
</code></pre></div><h3 id=原子操作>原子操作<a hidden class=anchor aria-hidden=true href=#原子操作>#</a></h3>
<p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h4 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h4>
<p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>
	<span style=color:#e6db74>&#34;sync&#34;</span>
	<span style=color:#e6db74>&#34;sync/atomic&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Counter</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Inc</span>()
	<span style=color:#a6e22e>Load</span>() <span style=color:#66d9ef>int64</span>
}

<span style=color:#75715e>// 普通版
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>CommonCounter</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>counter</span> <span style=color:#66d9ef>int64</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>CommonCounter</span>) <span style=color:#a6e22e>Inc</span>() {
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>counter</span><span style=color:#f92672>++</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>CommonCounter</span>) <span style=color:#a6e22e>Load</span>() <span style=color:#66d9ef>int64</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>counter</span>
}

<span style=color:#75715e>// 互斥锁版
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MutexCounter</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>counter</span> <span style=color:#66d9ef>int64</span>
	<span style=color:#a6e22e>lock</span>    <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MutexCounter</span>) <span style=color:#a6e22e>Inc</span>() {
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>counter</span><span style=color:#f92672>++</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MutexCounter</span>) <span style=color:#a6e22e>Load</span>() <span style=color:#66d9ef>int64</span> {
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Lock</span>()
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>lock</span>.<span style=color:#a6e22e>Unlock</span>()
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>counter</span>
}

<span style=color:#75715e>// 原子操作版
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AtomicCounter</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>counter</span> <span style=color:#66d9ef>int64</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>AtomicCounter</span>) <span style=color:#a6e22e>Inc</span>() {
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>counter</span>, <span style=color:#ae81ff>1</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>AtomicCounter</span>) <span style=color:#a6e22e>Load</span>() <span style=color:#66d9ef>int64</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>LoadInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>counter</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>Counter</span>) {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
	<span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Inc</span>()
			<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
		}()
	}
	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
	<span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Load</span>(), <span style=color:#a6e22e>end</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>start</span>))
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>c1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>CommonCounter</span>{} <span style=color:#75715e>// 非并发安全
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>c1</span>)
	<span style=color:#a6e22e>c2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>MutexCounter</span>{} <span style=color:#75715e>// 使用互斥锁实现并发安全
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>test</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c2</span>)
	<span style=color:#a6e22e>c3</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>AtomicCounter</span>{} <span style=color:#75715e>// 并发安全且比互斥锁效率更高
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>test</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c3</span>)
}
</code></pre></div><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://www.niuwx.cn/tags/golang/>Golang</a></li>
<li><a href=https://www.niuwx.cn/tags/go/>Go</a></li>
<li><a href=https://www.niuwx.cn/tags/%E5%B9%B6%E5%8F%91/>并发</a></li>
<li><a href=https://www.niuwx.cn/tags/goroutine/>goroutine</a></li>
<li><a href=https://www.niuwx.cn/tags/channel/>channel</a></li>
<li><a href=https://www.niuwx.cn/tags/select/>select</a></li>
<li><a href=https://www.niuwx.cn/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/>原子操作</a></li>
<li><a href=https://www.niuwx.cn/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/>并发安全和锁</a></li>
<li><a href=https://www.niuwx.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/>
<span class=title>« Prev Page</span>
<br>
<span>高精度计算</span>
</a>
<a class=next href=https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/>
<span class=title>Next Page »</span>
<br>
<span>Go语言基础之接口</span>
</a>
</nav>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Go语言基础之并发 on twitter" href="https://twitter.com/intent/tweet/?text=Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91&url=https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f&hashtags=Golang%2cGo%2c%e5%b9%b6%e5%8f%91%2cgoroutine%2cchannel%2cselect%2c%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%2c%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e5%92%8c%e9%94%81%2c%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go语言基础之并发 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f&title=Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91&summary=Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91&source=https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go语言基础之并发 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f&title=Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go语言基础之并发 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go语言基础之并发 on whatsapp" href="https://api.whatsapp.com/send?text=Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91%20-%20https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Go语言基础之并发 on telegram" href="https://telegram.me/share/url?text=Go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80%e4%b9%8b%e5%b9%b6%e5%8f%91&url=https%3a%2f%2fwww.niuwx.cn%2fposts%2fgolang%2fgo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%25E4%25B9%258B%25E5%25B9%25B6%25E5%258F%2591%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
<div class=post-comments><script src=https://utteranc.es/client.js repo=28251536/28251536.github.io issue-term=title theme=github-light crossorigin=anonymous async></script>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://www.niuwx.cn/>Ther's Blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>