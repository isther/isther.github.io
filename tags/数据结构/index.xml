<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>数据结构 on Ther&#39;s Blog</title>
    <link>https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on Ther&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 03 Feb 2021 19:33:51 +0800</lastBuildDate><atom:link href="https://www.niuwx.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>树（二）</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/</link>
      <pubDate>Wed, 03 Feb 2021 19:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/</guid>
      <description>简单介绍了一下树</description>
      <content:encoded><![CDATA[<h3 id="树的遍历">树的遍历</h3>
<p>上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。</p>
<p>以下是树的非递归遍历方法：</p>
<p>偷个懒用一下C++写，头文件要加上</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></code></pre></div><h4 id="先序遍历">先序遍历</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//先序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreorderNoneSecu</span>(PTree T) {
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;先序非递归遍历&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	PTree t <span style="color:#f92672">=</span> T;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s;
	<span style="color:#66d9ef">while</span>(t <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s.empty()){
		<span style="color:#66d9ef">while</span>(t){
			cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//拿到这个结点就直接打印
</span><span style="color:#75715e"></span>			s.push(t);
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
		}

		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s.empty()){
			t <span style="color:#f92672">=</span> s.top();
			s.pop();			
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
		}
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h4 id="中序遍历">中序遍历</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//中序非递归遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InorderNoneSecu</span>(PTree T) {
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;中序非递归遍历&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	PTree t <span style="color:#f92672">=</span> T;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s;
	<span style="color:#66d9ef">while</span>(t <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s.empty()){
		<span style="color:#66d9ef">while</span>(t){
			s.push(t);
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
		}

		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s.empty()){
			t <span style="color:#f92672">=</span> s.top();
			s.pop();
			cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//遍历完左子树后再打印
</span><span style="color:#75715e"></span>			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
		}
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h4 id="后序遍历">后序遍历</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//后序非递归遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PostorderNoneSecu</span>(PTree T) {
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;后序非递归遍历&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	PTree t <span style="color:#f92672">=</span> T;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s2;
	<span style="color:#66d9ef">while</span>(t <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s.empty()){
		<span style="color:#66d9ef">while</span>(t){
			s.push(t);
			s2.push(t);
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
		}

		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s.empty()){
			t <span style="color:#f92672">=</span> s.top();
			s.pop();
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
		}
	}

	<span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>s2.empty()){
		t <span style="color:#f92672">=</span> s2.top();
		s2.pop();
		cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><p>后序遍历与先序遍历的顺序相反，那么可以先遍历右子树，也就是说将先序遍历的顺序逆过来压入s2中，，然后再根据栈的后进先出的特点，一一出栈。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>树（一）</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/</link>
      <pubDate>Tue, 02 Feb 2021 16:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/</guid>
      <description>简单介绍了一下树</description>
      <content:encoded><![CDATA[<p>树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。</p>
<p>对于非空树：</p>
<p>1.有且仅有一个称之为根的结点。</p>
<p>2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84.jpg" alt=""  />
</p>
<h3 id="基本术语">基本术语</h3>
<ul>
<li>结点的度（Degree）：结点的子树个数</li>
<li>树的度：树的所有结点最大的度</li>
<li>叶结点（Leaf）：度为0的结点</li>
<li>父结点（Parent）：有子树的结点是其子树的根结点的父结点</li>
<li>子结点（Child）：若A结点是B结点的父结点，则称B结点为A结点的子结点；子结点也称孩子结点</li>
<li>兄弟结点（Sibling）：具有同一父结点的个节点彼此是兄弟结点</li>
<li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，n3&hellip;nk。路径所包含边的个数为路径的长度</li>
<li>祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li>
<li>子孙节点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙</li>
<li>结点的层次（Level）：规定根结点在第一层，其它任意节点层数是父结点层数加一</li>
<li>树的深度（Depth）：树中所有结点中的最大层次</li>
</ul>
<h3 id="二叉树">二叉树</h3>
<p>二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<h4 id="性质">性质</h4>
<p>1.二叉树的第i层的最大节点数为<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgi.svg" alt=""  />
</p>
<p>2.深度为k的二叉树最大结点数为<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgk.svg" alt=""  />
</p>
<p>3.二叉树的终端节点数为n0，度数为2 的结点数为n2，则n0 = n2 +1</p>
<p><strong>特殊的,</strong></p>
<p>如果一个深度为 k 的二叉树，正好有  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgk.svg" alt=""  />
个结点，那么这棵树就被称为<strong>满二叉树</strong>。</p>
<p>如图所示：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%bb%a1%e4%ba%8c%e5%8f%89%e6%a0%91.jpg" alt=""  />
</p>
<p>如果一个二叉树，只有当第 i 层已经达到了<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgi.svg" alt=""  />
的最大值以后，才能往第 i + 1 层自左向右地添加结点，这棵树就被称为<strong>完全二叉树</strong>。</p>
<p>那么，根据二叉树的性质二可得，具有n个结点的完全二叉树的深度为
$$
[log_2(n)]+1
$$</p>
<p>如图所示：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91.jpg" alt=""  />
</p>
<h4 id="二叉树的建立">二叉树的建立</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Tree
{
	<span style="color:#66d9ef">int</span> data;
	<span style="color:#66d9ef">struct</span> Tree <span style="color:#f92672">*</span>left;
	<span style="color:#66d9ef">struct</span> Tree <span style="color:#f92672">*</span>right;
} BiTree, <span style="color:#f92672">*</span>PTree;
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//创造一个结点
</span><span style="color:#75715e"></span>PTree <span style="color:#a6e22e">CreatNode</span>(<span style="color:#66d9ef">int</span> value) {
	PTree p <span style="color:#f92672">=</span> (PTree)malloc(<span style="color:#66d9ef">sizeof</span>(BiTree));
	p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> value;
	p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
	<span style="color:#66d9ef">return</span> p;
}

<span style="color:#75715e">//插入结点且排序，不存在有相同值的结点
</span><span style="color:#75715e"></span>PTree <span style="color:#a6e22e">AddNode</span>(<span style="color:#66d9ef">int</span> value, PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> CreatNode(value);
	}

	<span style="color:#66d9ef">if</span> (value <span style="color:#f92672">==</span> p<span style="color:#f92672">-&gt;</span>data) {
		<span style="color:#66d9ef">return</span> p;
	}

	<span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> p<span style="color:#f92672">-&gt;</span>data) {
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL) {
			p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> CreatNode(value);
			<span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>left;
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">return</span> AddNode(value, p<span style="color:#f92672">-&gt;</span>left);
		}
	}
	<span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL) {
			p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> CreatNode(value);
			<span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>right;
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">return</span> AddNode(value, p<span style="color:#f92672">-&gt;</span>right);
		}
	}
}
</code></pre></div><h4 id="遍历二叉树">遍历二叉树</h4>
<p>递归遍历左子树、根节点、递归遍历右子树</p>
<h5 id="先序遍历">先序遍历</h5>
<p>输出根节点，递归遍历左子树，在递归遍历右子树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Preorder</span>(PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
		Preorder(p<span style="color:#f92672">-&gt;</span>left);
		Preorder(p<span style="color:#f92672">-&gt;</span>right);
	}
}
</code></pre></div><h5 id="中序遍历">中序遍历</h5>
<p>递归遍历左子树，输出根节点，在递归遍历右子树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Midorder</span>(PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
		Midorder(p<span style="color:#f92672">-&gt;</span>left);
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
		Midorder(p<span style="color:#f92672">-&gt;</span>right);
	}
}
</code></pre></div><h5 id="后序遍历">后序遍历</h5>
<p>递归遍历左子树，再递归遍历右子树，输出根节点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Postorder</span>(PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
		Postorder(p<span style="color:#f92672">-&gt;</span>left);
		Postorder(p<span style="color:#f92672">-&gt;</span>right);
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
	}
}
</code></pre></div><h4 id="求二叉树的深度">求二叉树的深度</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">TreeHeight</span>(PTree p) {
	<span style="color:#66d9ef">int</span> l, r;
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
	}
	<span style="color:#66d9ef">else</span> {
		l <span style="color:#f92672">=</span> TreeHeight(p<span style="color:#f92672">-&gt;</span>left);
		r <span style="color:#f92672">=</span> TreeHeight(p<span style="color:#f92672">-&gt;</span>right);
		<span style="color:#66d9ef">return</span> (l <span style="color:#f92672">&gt;</span> r <span style="color:#f92672">?</span> l : r) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
	}
}
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> value;
	PTree p <span style="color:#f92672">=</span> NULL;
	printf(<span style="color:#e6db74">&#34;Please enter 10 numbers:&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i) {
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>value);
		<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
			p <span style="color:#f92672">=</span> CreatNode(value);
		}
		<span style="color:#66d9ef">else</span> {
			AddNode(value, p);
		}
	}

	Preorder(p);
	printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	Midorder(p);
	printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	Postorder(p);
	printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

	printf(<span style="color:#e6db74">&#34;The depth of the binary tree is：%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, TreeHeight(p));

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>栈和队列</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 31 Jan 2021 23:38:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>简单介绍了一下栈和队列</description>
      <content:encoded><![CDATA[<h5 id="引入">引入</h5>
<p>栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。</p>
<p>顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。</p>
<!-- raw HTML omitted -->
<h2 id="栈">栈</h2>
<h3 id="定义">定义</h3>
<p>栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%a0%88%e7%a4%ba%e6%84%8f%e5%9b%be.jpg" alt=""  />
</p>
<p><strong>线性表有两种存储形式，顺序表储存和链表储存。</strong></p>
<h3 id="顺序栈">顺序栈</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define MAXSIZE 100
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Stack{
	elem<span style="color:#f92672">*</span> base;<span style="color:#75715e">//栈基
</span><span style="color:#75715e"></span>	elem<span style="color:#f92672">*</span> top;<span style="color:#75715e">//栈顶
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> stacksize; <span style="color:#75715e">//栈的容量
</span><span style="color:#75715e"></span>}Stack;

</code></pre></div><h4 id="创建一个栈">创建一个栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CreatStack</span>(Stack<span style="color:#f92672">*</span> s){
	s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (elem<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(elem) <span style="color:#f92672">*</span> MAXSIZE);
	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s<span style="color:#f92672">-&gt;</span>base) <span style="color:#66d9ef">return</span> ERROR;
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base;
	s<span style="color:#f92672">-&gt;</span>stacksize <span style="color:#f92672">=</span> MAXSIZE;  	

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="入栈">入栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PushStack</span>(Stack<span style="color:#f92672">*</span> s, elem e){
	<span style="color:#66d9ef">if</span>(s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">-</span> s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">&gt;=</span> s<span style="color:#f92672">-&gt;</span>stacksize){
		s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (elem<span style="color:#f92672">*</span>)realloc(s<span style="color:#f92672">-&gt;</span>base, <span style="color:#66d9ef">sizeof</span>(elem) <span style="color:#f92672">*</span> MAXSIZE);
		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s<span style="color:#f92672">-&gt;</span>base) <span style="color:#66d9ef">return</span> ERROR;

		s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">+</span> s<span style="color:#f92672">-&gt;</span>stacksize;
		s<span style="color:#f92672">-&gt;</span>stacksize <span style="color:#f92672">+=</span>MAXSIZE;	
	}

	<span style="color:#f92672">*</span>(s<span style="color:#f92672">-&gt;</span>top) <span style="color:#f92672">=</span> e;
	s<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">++</span>;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="出栈">出栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PopStack</span>(Stack<span style="color:#f92672">*</span>s,elem <span style="color:#f92672">*</span>e){
	<span style="color:#66d9ef">if</span>(s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">==</span> s<span style="color:#f92672">-&gt;</span>base) <span style="color:#66d9ef">return</span> ERROR;
	<span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> <span style="color:#f92672">*--</span>(s<span style="color:#f92672">-&gt;</span>top);

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="清空">清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CleanStack</span>(Stack<span style="color:#f92672">*</span> s){
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base;
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="销毁">销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DestroyStack</span>(Stack<span style="color:#f92672">*</span> s){
	free(s<span style="color:#f92672">-&gt;</span>base);
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> NULL;
	s<span style="color:#f92672">-&gt;</span>stacksize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="获取当前容量">获取当前容量</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetSize</span>(Stack<span style="color:#f92672">*</span> s){
	<span style="color:#66d9ef">return</span> s<span style="color:#f92672">-&gt;</span>stacksize;
}
</code></pre></div><h3 id="链表栈">链表栈</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node<span style="color:#75715e">//定义链表结构
</span><span style="color:#75715e"></span>{
	elem data;<span style="color:#75715e">//数据域
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> Node<span style="color:#f92672">*</span> next;<span style="color:#75715e">//指针域
</span><span style="color:#75715e"></span>}Node, <span style="color:#f92672">*</span> LNode;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Stack
{
	LNode top;
	LNode base;
}Stack,<span style="color:#f92672">*</span>Pstack;
</code></pre></div><h4 id="创建一个栈-1">创建一个栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Pstack <span style="color:#a6e22e">CreatStack</span>(){
	Pstack stack <span style="color:#f92672">=</span> (Pstack)malloc(<span style="color:#66d9ef">sizeof</span>(Stack));
	<span style="color:#66d9ef">if</span>(stack <span style="color:#f92672">==</span> NULL){
		<span style="color:#66d9ef">return</span> NULL;
	}
	
	stack<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> NULL;

	<span style="color:#66d9ef">return</span> stack;
}
</code></pre></div><h4 id="入栈-1">入栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PushStack</span>(Pstack <span style="color:#f92672">*</span>stack, elem e){
	Node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (LNode)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> NULL){
		<span style="color:#66d9ef">return</span> ERROR;
	}
	p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
	p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="出栈-1">出栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PopStack</span>(Pstack <span style="color:#f92672">*</span>stack){
	Node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>base){
		printf(<span style="color:#e6db74">&#34;栈已空&#34;</span>);
		<span style="color:#66d9ef">return</span> ERROR;
	}
	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
	printf(<span style="color:#e6db74">&#34;%d &#34;</span>,p<span style="color:#f92672">-&gt;</span>data);
	free(p);

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="判断是否为空">判断是否为空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">IsEmptyStack</span>(Pstack stack){
	<span style="color:#66d9ef">return</span> (stack<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">==</span> stack<span style="color:#f92672">-&gt;</span>base);
}
</code></pre></div><h4 id="清空-1">清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CleanStack</span>(Pstack <span style="color:#f92672">*</span>stack){
	Node<span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	<span style="color:#66d9ef">while</span>(p){
		(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; 
		free(p);
		p <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	}
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="销毁-1">销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DestroyStack</span>(Pstack <span style="color:#f92672">*</span>stack){
	CleanStack(stack);

	free(<span style="color:#f92672">*</span>stack);

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>	Pstack stack <span style="color:#f92672">=</span> CreatStack();

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i){
		PushStack(<span style="color:#f92672">&amp;</span>stack, i);
	}

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));

	<span style="color:#75715e">/*出栈*/</span>
	<span style="color:#75715e">// for (int i = 0; i &lt; 10; ++i){
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	PopStack(&amp;stack);
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// }
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// printf(&#34;%\n&#34;);
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// printf(&#34;%d\n&#34;, IsEmptyStack(stack));
</span><span style="color:#75715e"></span>	
	<span style="color:#75715e">/*清空*/</span>
	CleanStack(<span style="color:#f92672">&amp;</span>stack);

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));
	printf(<span style="color:#e6db74">&#34;%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,stack);

	DestroyStack(<span style="color:#f92672">&amp;</span>stack);

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));
	printf(<span style="color:#e6db74">&#34;%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,stack);

}
</code></pre></div><h3 id="栈与递归">栈与递归</h3>
<p><strong>递归：函数自己调用自己</strong></p>
<ul>
<li>函数定义是递归的——斐波那契数列</li>
<li>数据结构是递归的——单链表、树</li>
<li>问题解法是递归的——汉诺塔、</li>
</ul>
<h4 id="函数的调用">函数的调用</h4>
<p>函数被调用之前，</p>
<ol>
<li>系统需要将实参以及返回地址传递给被调用的函数进行保存</li>
<li>将被调用的函数的局部变量分配到储存区</li>
<li>将控制转移到被调用的函数的入口</li>
</ol>
<p>从被调用函数返回到调用函数之前，</p>
<ol>
<li>保存被调用函数的计算结果</li>
<li>释放被调用函数中的数据区</li>
<li>依照被调用函数的保存的返回地址将控制转移至此</li>
</ol>
<h2 id="队列">队列</h2>
<h3 id="定义-1">定义</h3>
<p>队列也是一种重要的线性结构。与栈相同，实现一个队列也需要顺序表或者链表作为基础。但是与栈不同的是，队列是一种先进先出（FIFO）的线性表。其要求所有的数据从队列的一段进入，从队列的另一端离开。在队列中，允许插入数据的一端叫做队尾（rear），允许数据离开的一端叫做队头（front）。如图所示</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e9%98%9f%e5%88%97.jpg" alt=""  />
</p>
<h2 id="链队列">链队列</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> QNode {
	elem data;			<span style="color:#75715e">//数据域
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> QNode<span style="color:#f92672">*</span>next;	<span style="color:#75715e">//指针域
</span><span style="color:#75715e"></span>} QNode, <span style="color:#f92672">*</span>PNode;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	PNode front;		<span style="color:#75715e">//队头指针
</span><span style="color:#75715e"></span>	PNode rear;			<span style="color:#75715e">//队尾指针
</span><span style="color:#75715e"></span>} LinkQueue;
</code></pre></div><h4 id="创建一个队列">创建一个队列</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CreatQueue</span>(LinkQueue <span style="color:#f92672">*</span>q) {
	q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> (PNode)malloc(<span style="color:#66d9ef">sizeof</span>(QNode));

	<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> ERROR;
	}

	q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img1.jpg" alt=""  />
</p>
<h4 id="入队">入队</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PushQueue</span>(LinkQueue <span style="color:#f92672">*</span>q, elem e) {
	QNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (PNode)malloc(<span style="color:#66d9ef">sizeof</span>(QNode));
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> ERROR;
	}
	p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
	p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
	q<span style="color:#f92672">-&gt;</span>rear<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
	q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> p;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img2.jpg" alt=""  />
</p>
<h4 id="出队">出队</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PopQueue</span>(LinkQueue <span style="color:#f92672">*</span>q) {
	<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">==</span> q<span style="color:#f92672">-&gt;</span>rear) {
		<span style="color:#66d9ef">return</span> ERROR;
	}

	QNode<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
	printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
	q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
	<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">==</span> p) q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>front;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="销毁-2">销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DestroyQueue</span>(LinkQueue <span style="color:#f92672">*</span>q) {
	<span style="color:#66d9ef">while</span> (q<span style="color:#f92672">-&gt;</span>front) {
		q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
		free(q<span style="color:#f92672">-&gt;</span>front);
		q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>rear;
	}
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>单链表</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 30 Jan 2021 17:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
      <description>简单介绍了一下单链表</description>
      <content:encoded><![CDATA[<p>链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。</p>
<!-- raw HTML omitted -->
<p>每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。</p>
<p>在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为<em>随机存取</em>方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为<em>顺序存取</em>方式。</p>
<h3 id="头指针和头节点">头指针和头节点</h3>
<h4 id="基本概念">基本概念</h4>
<h5 id="头指针">头指针</h5>
<p><strong>通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。</strong></p>
<h5 id="头节点">头节点</h5>
<p><strong>在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。</strong></p>
<p><strong>[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。</strong></p>
<p>空链表
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e7%a9%ba%e9%93%be%e8%a1%a8.jpg" alt=""  />
</p>
<p>单链表
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%8d%95%e9%93%be%e8%a1%a8.jpg" alt=""  />
</p>
<h4 id="引入头结点的优势">引入头结点的优势</h4>
<p>链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。</p>
<h5 id="优势1第一个位置的插入删除特别方便">优势1：第一个位置的插入删除特别方便</h5>
<p>若使用头结点，则第1个位置的插入和删除都是对p—&gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：</p>
<h6 id="插入操作如下">插入操作如下</h6>
<ol>
<li>p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。</li>
<li>让新结点s的next指向p的next，即s—&gt;next = p—&gt;next;</li>
<li>让p—&gt;next指向s，即p—&gt;next = s;</li>
</ol>
<h6 id="删除操作如下">删除操作如下</h6>
<ol>
<li>p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。</li>
<li>让临时指针q指向要删除的结点，即q = p—&gt;next；</li>
<li>让p的next指向要删除结点的下一个结点，即p—&gt;next = q—&gt;next；</li>
<li>释放q的空间，即free(q);</li>
</ol>
<hr>
<p>若没有头结点，在第1个位置插入或删除时，需要动头指针。</p>
<h6 id="插入操作如下-1">插入操作如下</h6>
<ol>
<li>判断要插入的是否是第1个位置，若是需要特殊处理。</li>
<li>若是第1个位置，让新结点s的next指向头指针PtrL。</li>
<li>return s，此时s作为链表的头指针。此时的更新了链表的头指针。</li>
<li>若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。</li>
<li>让新结点s的next指向p的next，即s—&gt;next = p—&gt;next;</li>
<li>让p—&gt;next指向s，即p—&gt;next = s;</li>
<li>return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。</li>
</ol>
<h6 id="删除操作如下-1">删除操作如下</h6>
<ol>
<li>判断要删除的是否是第1个位置，若是需要特殊处理。</li>
<li>若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—&gt;next；</li>
<li>free(s);然后return PtrL</li>
<li>若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。</li>
<li>让临时指针q指向要删除的结点，即q = p—&gt;next；</li>
<li>让p的next指向要删除结点的下一个结点，即p—&gt;next = q—&gt;next；</li>
<li>释放q的空间，即free(q);</li>
<li>return PtrL</li>
</ol>
<h5 id="优势2统一空表和非空表的处理">优势2：统一空表和非空表的处理</h5>
<p>若使用头结点，<em>无论表是否为空，头指针都指向头结点，也就是</em>LNode类型*，对于空表和非空表的操作是一致的。</p>
<p>若不使用头结点，<em>当表非空时，头指针指向第1个结点的地址，即</em>LNode类型，但是对于空表，头指针指向的是NULL*，此时空表和非空表的操作是不一致的。</p>
<h3 id="链表的建立">链表的建立</h3>
<h4 id="有头结点链表的建立">有头结点链表的建立</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;


<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> LNode{
    elem data;          <span style="color:#75715e">//数据域
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> LNode<span style="color:#f92672">*</span> next; <span style="color:#75715e">//指针域
</span><span style="color:#75715e"></span>}Node, <span style="color:#f92672">*</span>List;
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">HeadCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//带头结点_头插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s;
    List head <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));<span style="color:#75715e">//生成头结点
</span><span style="color:#75715e"></span>    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;<span style="color:#75715e">//头结点的指针域next指向s结点，使得s成为结点
</span><span style="color:#75715e"></span>    }   
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">TailCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//带头结点_尾插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s, <span style="color:#f92672">*</span>r;
    List head <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    r <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;
        r <span style="color:#f92672">=</span> s;
    }

    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL){
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    }
    
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><hr>
<p>下面这个是建立头结点与建立链表分离</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">CreatHNode</span>(){<span style="color:#75715e">//建立头结点
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s, <span style="color:#f92672">*</span>r;
    List head <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">HeadList</span>(List head, <span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//头插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;<span style="color:#75715e">//头结点的指针域next指向s结点，使得s成为结点
</span><span style="color:#75715e"></span>    }   
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">TailList</span>(List head, <span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//尾插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s, <span style="color:#f92672">*</span>r;
    r <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;
        r <span style="color:#f92672">=</span> s;
    }

    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL){
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    }
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p>为了方便测试，先写出遍历并打印链表的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PrintList</span>(List head){<span style="color:#75715e">//打印链表数据
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>t <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
    <span style="color:#66d9ef">while</span> (t <span style="color:#f92672">!=</span> NULL){
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,t<span style="color:#f92672">-&gt;</span>data);
        t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next;
    }
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    <span style="color:#75715e">//head = HeadCreatList(10);
</span><span style="color:#75715e"></span>    head <span style="color:#f92672">=</span> TailCreatList(<span style="color:#ae81ff">10</span>);
    <span style="color:#75715e">//head = CreatHNode();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//HeadList(head, 10);
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//TailList(head, 10);
</span><span style="color:#75715e"></span>    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="无头结点链表的建立">无头结点链表的建立</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">HeadCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//头插法
</span><span style="color:#75715e"></span>	List head <span style="color:#f92672">=</span> NULL;
	Node <span style="color:#f92672">*</span>p;
	<span style="color:#66d9ef">while</span>(n<span style="color:#f92672">--</span>){
		p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
		p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> n;
		<span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL){
			p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
			head <span style="color:#f92672">=</span> p;
		}
		<span style="color:#66d9ef">else</span>{
			p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
			head <span style="color:#f92672">=</span> p;
		}
	}
	<span style="color:#66d9ef">return</span> head;
}

</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">TailCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//尾插法
</span><span style="color:#75715e"></span>	List head <span style="color:#f92672">=</span> NULL;
	Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q;
	<span style="color:#66d9ef">while</span>(n<span style="color:#f92672">--</span>){
		p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
		p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> n;
		<span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL){
			head <span style="color:#f92672">=</span> p;
		}
		<span style="color:#66d9ef">else</span>{
			q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
		}
		p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
		q <span style="color:#f92672">=</span> p;
	}
	<span style="color:#66d9ef">return</span> head;
}
</code></pre></div><p>为了测试，先写出打印链表的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PrintList</span>(List head){<span style="color:#75715e">//打印链表元素
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL){
		<span style="color:#66d9ef">return</span> ERROR;
    }
    Node <span style="color:#f92672">*</span>t <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">while</span>(t <span style="color:#f92672">!=</span> NULL){
        printf(<span style="color:#e6db74">&#34;%d&#34;</span>, t<span style="color:#f92672">-&gt;</span>data);		
        t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next;
    }
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>);
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>	List head;
	<span style="color:#75715e">//head = HeadCreatList(10);
</span><span style="color:#75715e"></span>	head <span style="color:#f92672">=</span> TailCreatList(<span style="color:#ae81ff">10</span>);
	PrintList(head);
	<span style="color:#66d9ef">return</span> ;
}
</code></pre></div><h3 id="链表的各个功能的实现有头结点">链表的各个功能的实现（有头结点）</h3>
<p>上面介绍了有无头结点对于功能实现的影响，接下来先使用有头结点的链表进行</p>
<h4 id="链表元素的添加">链表元素的添加</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表添加元素（插头）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">HeadInsertList</span>(List head,Node a){
    Node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a.data;
    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表添加元素（插尾）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">TailInsertList</span>(List head,Node a){
    Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>t, <span style="color:#f92672">*</span>s;
    t <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
    p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a.data;
    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">!=</span> NULL){
        s <span style="color:#f92672">=</span> t;
        t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next;
    }
    s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    <span style="color:#75715e">//HeadInsertList(head, a);
</span><span style="color:#75715e"></span>    TailInsertList(head, a);

    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的插入">链表元素的插入</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表的插入（插在之前）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InsertIndexFront</span>(List head,<span style="color:#66d9ef">int</span> i){
    Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q, <span style="color:#f92672">*</span>r;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    p <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">while</span>(p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> i){
        r <span style="color:#f92672">=</span> p;
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
        j<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j<span style="color:#f92672">&gt;</span>i){
        <span style="color:#66d9ef">return</span> ERROR;
    }

    q <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>data);
    q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
    r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> q;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表的插入（插在之后）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InsertIndexBack</span>(List head,<span style="color:#66d9ef">int</span> i){
    Node <span style="color:#f92672">*</span>p,<span style="color:#f92672">*</span>q;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    p <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">while</span>(p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> i){
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
        j<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;</span> i){
        <span style="color:#66d9ef">return</span> ERROR;
    }

    q <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>data);
    q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> q;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">oid <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>        List head;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    InsertIndexFront(head,<span style="color:#ae81ff">2</span>);
    <span style="color:#75715e">//InsertIndexBack(head,2);
</span><span style="color:#75715e"></span>
    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的查找">链表元素的查找</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表元素的查找
</span><span style="color:#75715e"></span>elem <span style="color:#a6e22e">GetElem</span>(List head, <span style="color:#66d9ef">int</span> index){<span style="color:#75715e">//按序号查找
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j;
    Node<span style="color:#f92672">*</span> p;
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向第一个数据结点
</span><span style="color:#75715e"></span>    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//j为计数器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> index ){ <span style="color:#75715e">//顺着链表向后扫描，直到p指向第i个元素或p为空
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向下一个结点
</span><span style="color:#75715e"></span>        j<span style="color:#f92672">++</span>; <span style="color:#75715e">//计数器j相应加1
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;</span> index)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">//i值不合法i＞n或i&lt;=0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>data;<span style="color:#75715e">//返回第i个结点的数据域
</span><span style="color:#75715e"></span>
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">elem <span style="color:#a6e22e">GetIndex</span>(List head, <span style="color:#66d9ef">int</span> e) {<span style="color:#75715e">//按值查找
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//在带头结点的单链表L中查找值为e的元素
</span><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> p;
    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;

    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span>e){
        <span style="color:#75715e">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向下一个结点
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>index;
    }
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">//查找失败p为NULL
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> index;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,GetElem(head,<span style="color:#ae81ff">6</span>));
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,GetIndex(head,<span style="color:#ae81ff">6</span>));

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的删除">链表元素的删除</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DeleteList</span>(List head, <span style="color:#66d9ef">int</span> index) {<span style="color:#75715e">//单链表的删除
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//在带头结点的单链表L中，删除第i个位置
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q;
    <span style="color:#66d9ef">int</span> j;
    p <span style="color:#f92672">=</span> head;
    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span>((p<span style="color:#f92672">-&gt;</span>next)<span style="color:#f92672">&amp;&amp;</span>(j <span style="color:#f92672">&lt;</span> index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) {<span style="color:#75715e">//查找第i-1个结点，p指向该结点
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
        j<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(p<span style="color:#f92672">-&gt;</span>next)<span style="color:#f92672">||</span>(j <span style="color:#f92672">&gt;</span> index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))<span style="color:#75715e">//当i&gt;n或i&lt;1时，删除位置不合理
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ERROR;
    q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//临时保存被删结点的地址以备释放空间
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//改变删除结点前驱结点的指针域
</span><span style="color:#75715e"></span>    free(q); <span style="color:#75715e">//释放被删除结点的空间
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    DeleteList(head,<span style="color:#ae81ff">4</span>);

    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的修改">链表元素的修改</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表元素的修改
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">ReverseElem</span>(List head, <span style="color:#66d9ef">int</span> index,<span style="color:#66d9ef">int</span> e){
    <span style="color:#66d9ef">int</span> j;
    Node<span style="color:#f92672">*</span> p;
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向第一个数据结点
</span><span style="color:#75715e"></span>    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//j为计数器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> index ){ <span style="color:#75715e">//顺着链表向后扫描，直到p指向第i个元素或p为空
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向下一个结点
</span><span style="color:#75715e"></span>        j<span style="color:#f92672">++</span>; <span style="color:#75715e">//计数器j相应加1
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;</span> index)
        <span style="color:#66d9ef">return</span> ERROR; <span style="color:#75715e">//i值不合法i＞n或i&lt;=0
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
    <span style="color:#66d9ef">return</span> OK;<span style="color:#75715e">//返回第i个结点的数据域
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    ReverseElem(head,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">999</span>);

    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的清空">链表元素的清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//清空链表
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">ClearList</span>(List head)  
{  
    Node<span style="color:#f92672">*</span>p,<span style="color:#f92672">*</span>q;
    <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL)  
        <span style="color:#66d9ef">return</span> ERROR;  
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;  
    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL)  
    {  
        q<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;  
        free(p);  
        p<span style="color:#f92672">=</span>q;  
    }  
    head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;  
    <span style="color:#66d9ef">return</span> OK;  
}
</code></pre></div><h4 id="链表元素的排序">链表元素的排序</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">SwapElem</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>j){<span style="color:#75715e">//交换数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span>  temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>i;
    <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>j;
    <span style="color:#f92672">*</span>j <span style="color:#f92672">=</span> temp;
    <span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SortList</span>(List head){<span style="color:#75715e">//冒泡排序
</span><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> NULL;
    Node<span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> NULL;
    Node<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">if</span>(head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL){
        <span style="color:#66d9ef">return</span> ;
    }

    <span style="color:#66d9ef">for</span> ( p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; p <span style="color:#f92672">!=</span> NULL; p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next){
        <span style="color:#66d9ef">for</span> ( q <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL; q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next){
            <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data){
                SwapElem(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>data, <span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data);
            }
        }
    }
}
</code></pre></div><h4 id="无头结点链表的功能实现就不在此赘述所有源码都在githubhttpsgithubcom28251536datanote">无头结点链表的功能实现就不在此赘述，所有源码都在<a href="https://github.com/28251536/DataNote">Github</a></h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>顺序表</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</link>
      <pubDate>Fri, 29 Jan 2021 17:38:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</guid>
      <description>简单介绍了一下顺序表</description>
      <content:encoded><![CDATA[<h3 id="概念">概念</h3>
<p>具有 <em>一对一</em> 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define MAXSIZE 100
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;


<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Sqlist{
    elem <span style="color:#f92672">*</span>e;<span style="color:#75715e">//存储空间的及地址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length;<span style="color:#75715e">//长度
</span><span style="color:#75715e"></span>}Sqlist;
</code></pre></div><h3 id="功能的实现">功能的实现</h3>
<h4 id="顺序表的初始化">顺序表的初始化</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//数组的初始化
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InitArray</span>(Sqlist <span style="color:#f92672">*</span>L){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e) {<span style="color:#75715e">//判断指针是否为空
</span><span style="color:#75715e"></span>        free(L<span style="color:#f92672">-&gt;</span>e);
        L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">=</span> NULL;
    }

    L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">=</span> (elem<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> MAXSIZE);<span style="color:#75715e">//申请capacity大小的空间
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL){
        printf(<span style="color:#e6db74">&#34;内存分配失败!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);<span style="color:#75715e">//判断内存分配是否成功
</span><span style="color:#75715e"></span>        exit(<span style="color:#ae81ff">0</span>);
    }

    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的添加">元素的添加</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//添加元素
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">PushBackArray</span>(Sqlist <span style="color:#f92672">*</span>L,elem value){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL){
        printf(<span style="color:#e6db74">&#34;请初始化顺序表</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> ERROR;
    }

    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">==</span> MAXSIZE) {
        <span style="color:#66d9ef">return</span> ERROR;
    }
    L<span style="color:#f92672">-&gt;</span>e[L<span style="color:#f92672">-&gt;</span>length] <span style="color:#f92672">=</span> value;
    <span style="color:#f92672">++</span>L<span style="color:#f92672">-&gt;</span>length;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的插入">元素的插入</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InsertArray</span>(Sqlist <span style="color:#f92672">*</span>L,<span style="color:#66d9ef">int</span> index,elem value){
    <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> index <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>){
        <span style="color:#66d9ef">return</span> ERROR;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length; i <span style="color:#f92672">&gt;=</span> index; i<span style="color:#f92672">--</span>) {
		L<span style="color:#f92672">-&gt;</span>e[i] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>e[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
	}

	L<span style="color:#f92672">-&gt;</span>e[index] <span style="color:#f92672">=</span> value;

	<span style="color:#f92672">++</span>L<span style="color:#f92672">-&gt;</span>length;
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的查找">元素的查找</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据位置查找
</span><span style="color:#75715e"></span>elem <span style="color:#a6e22e">FindByIndex</span>(Sqlist<span style="color:#f92672">*</span> L,<span style="color:#66d9ef">int</span> index){
    <span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>e[index];
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据值查找
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">FindByValue</span>(Sqlist<span style="color:#f92672">*</span> L,elem value){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e[i] <span style="color:#f92672">==</span> value){
            <span style="color:#66d9ef">return</span> i;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
</code></pre></div><h4 id="元素的删除">元素的删除</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据值删除
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">RemoveByValue</span>(Sqlist<span style="color:#f92672">*</span> L,elem value){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e[i] <span style="color:#f92672">==</span> value){
	        <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
		        L<span style="color:#f92672">-&gt;</span>e[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>e[i];
	        }

	        <span style="color:#f92672">--</span>L<span style="color:#f92672">-&gt;</span>length;
	        <span style="color:#66d9ef">return</span> OK;
        }
    }
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据位置删除
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">RemoveByIndex</span>(Sqlist<span style="color:#f92672">*</span> L,<span style="color:#66d9ef">int</span> index){
	<span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> index <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) {
		<span style="color:#66d9ef">return</span> ERROR;
	}

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> index; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
		L<span style="color:#f92672">-&gt;</span>e[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>e[i];
	}

	<span style="color:#f92672">--</span>L<span style="color:#f92672">-&gt;</span>length;
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的清空">元素的清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//清空
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">CleanArray</span>(Sqlist <span style="color:#f92672">*</span>L){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL) {
        printf(<span style="color:#e6db74">&#34;未初始化</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> ERROR;
    
    }

    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="线性表的销毁">线性表的销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//销毁
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">FreeArray</span>(Sqlist<span style="color:#f92672">*</span> L){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">!=</span> NULL){
        free(L<span style="color:#f92672">-&gt;</span>e);
        L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">=</span> NULL;
    }

    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="获取当前长度">获取当前长度</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(Sqlist<span style="color:#f92672">*</span> L){
     <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>length;
}
</code></pre></div><h4 id="判断是否为空">判断是否为空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//判断是否为空
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">IsEmptyArray</span>(Sqlist <span style="color:#f92672">*</span>L){
    <span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h4 id="顺序表的合并">顺序表的合并</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//合并
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">CombineArray</span>(Sqlist <span style="color:#f92672">*</span>L1,Sqlist <span style="color:#f92672">*</span>L2){
    <span style="color:#66d9ef">if</span> (L1<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> L2<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;</span> MAXSIZE) {
        printf(<span style="color:#e6db74">&#34;空间不足，合并失败</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
		<span style="color:#66d9ef">return</span> ERROR;
	}

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L2<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
		L1<span style="color:#f92672">-&gt;</span>e[L1<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> L2<span style="color:#f92672">-&gt;</span>e[i];
	}
    L1<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+=</span>L2<span style="color:#f92672">-&gt;</span>length;

    free(L2<span style="color:#f92672">-&gt;</span>e);
    L2<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="顺序表的打印">顺序表的打印</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//打印
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintArray</span>(Sqlist<span style="color:#f92672">*</span> L){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,L<span style="color:#f92672">-&gt;</span>e[i]);
    }
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    Sqlist L,L2;
      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/********初始化及添加元素********/</span>
    <span style="color:#75715e">/******************************/</span>
    InitArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//初始化顺序表
</span><span style="color:#75715e"></span>    InitArray(<span style="color:#f92672">&amp;</span>L2);
    <span style="color:#75715e">//srand(time(NULL));
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>){<span style="color:#75715e">//赋值
</span><span style="color:#75715e"></span>        PushBackArray(<span style="color:#f92672">&amp;</span>L,i);
        PushBackArray(<span style="color:#f92672">&amp;</span>L2,i);
    }
    printf(<span style="color:#e6db74">&#34;初始化...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
     <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/************插入元素***********/</span>
    <span style="color:#75715e">/******************************/</span>
    InsertArray(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">100</span>);<span style="color:#75715e">//插入元素
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;插入元素...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/************查找元素***********/</span>
    <span style="color:#75715e">/******************************/</span>
    printf(<span style="color:#e6db74">&#34;查找元素...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;%d &#34;</span>,FindByIndex(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">10</span>));<span style="color:#75715e">//根据位置查找
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d &#34;</span>,FindByValue(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">4</span>));<span style="color:#75715e">//根据值查找
</span><span style="color:#75715e"></span>


      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/************删除元素***********/</span>
    <span style="color:#75715e">/******************************/</span>
    RemoveByIndex(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">3</span>);<span style="color:#75715e">//根据位置删除
</span><span style="color:#75715e"></span>    RemoveByValue(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">9</span>);<span style="color:#75715e">//根据值删除
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;删除元素...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>

      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/***********合并顺序表**********/</span>
    <span style="color:#75715e">/******************************/</span>
    CombineArray(<span style="color:#f92672">&amp;</span>L,<span style="color:#f92672">&amp;</span>L2);<span style="color:#75715e">//合并
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;合并顺序表...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
     <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/***********清空顺序表**********/</span>
    <span style="color:#75715e">/******************************/</span>
    CleanArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//清空
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;清空顺序表...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/***********销毁顺序表**********/</span>
    <span style="color:#75715e">/******************************/</span>
    FreeArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//销毁
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;销毁顺序表...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>,PushBackArray(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">1</span>));
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    test();
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>数据结构概括</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Fri, 29 Jan 2021 16:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>基础知识</description>
      <content:encoded><![CDATA[<h3 id="数据">数据</h3>
<p>所有能够输入到计算机中的去的描述客观事物的符号</p>
<h3 id="数据元素">数据元素</h3>
<p>数据的基本单位，也称结点或记录</p>
<h3 id="数据结构">数据结构</h3>
<p>相互之间存在一种或多种特定关系的数据元素的集合</p>
<h3 id="逻辑结构和存储结构">逻辑结构和存储结构</h3>
<h4 id="逻辑结构">逻辑结构</h4>
<p>数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。</p>
<h5 id="1集合">1.集合</h5>
<p>数据元素间除同属于一个集合外，无其他关系
集合中的元素是离散的、无序的、相互之间没有关系的</p>
<h5 id="2线性结构">2.线性结构</h5>
<p>一个对一个
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e7%ba%bf%e6%80%a7%e7%bb%93%e6%9e%84.jpg" alt=""  />
</p>
<ul>
<li>线性表</li>
<li>栈</li>
<li>队列
线性结构像是珠子穿在一根线上，不会分叉，有且只有唯一的开始和结束</li>
</ul>
<h5 id="3树形结构">3.树形结构</h5>
<p>一个对多个
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84.jpg" alt=""  />

树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支。树枝和树枝之间是不相交的。</p>
<ul>
<li>树</li>
</ul>
<h5 id="4图形结构">4.图形结构</h5>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%9b%be%e5%bd%a2%e7%bb%93%e6%9e%84.jpg" alt=""  />

图形结构就像我们经常见到的地图，任何一个结点都可能和其它结点有关系，就像一张错综复杂的网。</p>
<h4 id="存储结构">存储结构</h4>
<p>存储结构是数据元素及其关系在计算机中的存储方式。</p>
<h5 id="1顺序结构">1.顺序结构</h5>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e9%a1%ba%e5%ba%8f%e5%82%a8%e5%ad%98.jpg" alt=""  />

顺序存储在计算机内的存储位置是连续的，可以快速定位第几个元素的问题。中间不允许有空，所以插入、删除时需要移动大量元素。</p>
<h5 id="2链式结构">2.链式结构</h5>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e9%93%be%e5%bc%8f%e5%82%a8%e5%ad%98.png" alt=""  />

链式存储就像一个铁链子，一环扣一环才能连在一起。每个结点除了数据域，还有一个指针域，记录下一个元素的存储地址。</p>
<h5 id="3散列机构">3.散列机构</h5>
<h5 id="4索引结构">4.索引结构</h5>
<h3 id="算法复杂性">算法复杂性</h3>
<h4 id="时间复杂度">时间复杂度</h4>
<p>程序运行所需的时间</p>
<ol>
<li>常数阶 O(1)</li>
<li>O(n)</li>
<li>O(n²)</li>
<li>O(log(n))-二分查找</li>
<li>O(nlogn)-快排</li>
</ol>
<h5 id="递归时间复杂度">递归时间复杂度</h5>
<p>O(T * depth)  T是每一次递归的时间复杂度</p>
<h5 id="最好最坏情况时间复杂度">最好最坏情况时间复杂度</h5>
<h5 id="平均时间复杂度">平均时间复杂度</h5>
<h4 id="空间复杂度">空间复杂度</h4>
<p>程序运行所需的空间</p>
<p>主要分为两部分：</p>
<ol>
<li>固定部分：指令空间、数据空间（静态空间）</li>
<li>可变空间：动态分配的空间</li>
</ol>
<p>S(n) = O(f(n))</p>]]></content:encoded>
    </item>
    
  </channel>
</rss>
