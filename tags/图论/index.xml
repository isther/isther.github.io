<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>图论 on Ther&#39;s Blog</title>
    <link>https://www.niuwx.cn/tags/%E5%9B%BE%E8%AE%BA/</link>
    <description>Recent content in 图论 on Ther&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 27 Mar 2021 19:02:51 +0800</lastBuildDate><atom:link href="https://www.niuwx.cn/tags/%E5%9B%BE%E8%AE%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>拓扑排序</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 27 Mar 2021 19:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>简单介绍了一下拓扑排序</description>
      <content:encoded><![CDATA[<p>这篇文章将介绍图论中的拓扑排序。</p>
<h3 id="什么是拓扑排序">什么是拓扑排序？</h3>
<p>对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。</p>
<h3 id="拓扑排序">拓扑排序</h3>
<ul>
<li>入度：指向v的边的个数叫做v的入度。</li>
<li>出度：v指向的点的个数叫做v的出度。</li>
</ul>
<p>如果一个点的入度是<code>0</code>，那么说明这个点是起点（起点不止一个）。如果一个点的出度为<code>0</code>，那么说明这个点排在最后。</p>
<p>举例说明：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgDAG1.jpg" alt="DAG1"  />
</p>
<p>如图所示，这是一个有向无环图，其指向顺序为<code>a,(b,c),d,e</code>,则<code>abcde</code>和<code>acbde</code>都是这个图的拓扑排序。</p>
<p>很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。</p>
<h3 id="拓扑排序的实现">拓扑排序的实现</h3>
<p>DFS和BFS都可以实现拓扑排序。</p>
<h4 id="bfs实现拓扑排序">BFS实现拓扑排序</h4>
<p>这种算法也叫做Kahn算法</p>
<p>继续使用上面的例子进行说明</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgDAG1.jpg" alt="DAG1"  />
</p>
<p>BFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。</p>
<p>无前驱的顶点优先就是顺着找，a的入度为<code>0</code>，则其为起点，a入队；</p>
<p>a出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；</p>
<p>目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；</p>
<p>b出队，b指向d，d入度减一，d入度为零，入队；</p>
<p>d出队，d指向e，e入度减一，e入度为零，入队；</p>
<p>e出队，无后续结点，结束。</p>
<p>由上述过程可得拓扑排序为<code>acbde</code>。</p>
<h6 id="时间复杂度">时间复杂度</h6>
<p>假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。</p>
<p>代码实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
<span style="color:#66d9ef">int</span> T, n, m, u, v;

<span style="color:#66d9ef">int</span> deg[N];
<span style="color:#66d9ef">int</span> vis[N];
<span style="color:#66d9ef">int</span> dest[N];
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g[N];
queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">toposort</span>() {
    <span style="color:#75715e">//将入度为零的点放入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>deg[i]) {
            vis[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            q.push(i);
        }
    }

    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
        <span style="color:#66d9ef">int</span> now <span style="color:#f92672">=</span> q.front();
        q.pop();
        dest[num<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> now;

        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> to : g[now]) {
            <span style="color:#66d9ef">if</span> (vis[to])  <span style="color:#75715e">//判断该节点是否在队列中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span> {
                deg[to]<span style="color:#f92672">--</span>;        <span style="color:#75715e">//入度减一
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>deg[to]) {   <span style="color:#75715e">//判断入度是否为零
</span><span style="color:#75715e"></span>                    q.push(to);   <span style="color:#75715e">//入队
</span><span style="color:#75715e"></span>                    vis[to] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//标记其在队列中
</span><span style="color:#75715e"></span>                }
            }
        }
    }
    <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">==</span> n)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    memset(deg, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(deg));
    memset(vis, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(vis));
    memset(dest, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(dest));

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> N; i<span style="color:#f92672">++</span>)
        g[i].clear();

    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty())
        q.pop();
    <span style="color:#75715e">//以上为初始化
</span><span style="color:#75715e"></span>
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);  <span style="color:#75715e">//读入
</span><span style="color:#75715e"></span>        g[u].push_back(v);
        deg[v]<span style="color:#f92672">++</span>;  <span style="color:#75715e">//统计入度
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">if</span> (toposort()) {<span style="color:#75715e">//如果可以生成拓扑排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)  <span style="color:#75715e">//输出结果
</span><span style="color:#75715e"></span>            printf(<span style="color:#e6db74">&#34;%d%c&#34;</span>, dest[i], i <span style="color:#f92672">==</span> n <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39; &#39;</span>);
    }
    <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//测试数据
</span><span style="color:#75715e">//有向有环图
</span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">2</span>
<span style="color:#75715e">//有向无环图
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>
</code></pre></div><h4 id="dfs实现拓扑排序">DFS实现拓扑排序</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;

<span style="color:#66d9ef">int</span> n, u, v;
<span style="color:#66d9ef">int</span> c[N];          <span style="color:#75715e">// 标志数组
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[N];  <span style="color:#75715e">// vector 实现的邻接表
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> topo;  <span style="color:#75715e">// 拓扑排序后的节点
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u) {
    c[u] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v : G[u]) {
        <span style="color:#66d9ef">if</span> (c[v] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[v])
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(v))
                <span style="color:#66d9ef">return</span> false;
    }
    c[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    topo.push_back(u);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">toposort</span>() {
    topo.clear();
    memset(c, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(c));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; u <span style="color:#f92672">&lt;</span> n; u<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[u])
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(u))
                <span style="color:#66d9ef">return</span> false;
    reverse(topo.begin(), topo.end());
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
