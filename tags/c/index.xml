<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C on Ther&#39;s Blog</title>
    <link>https://www.niuwx.cn/tags/c/</link>
    <description>Recent content in C on Ther&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 27 Mar 2021 19:02:51 +0800</lastBuildDate><atom:link href="https://www.niuwx.cn/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>拓扑排序</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 27 Mar 2021 19:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>简单介绍了一下拓扑排序</description>
      <content:encoded><![CDATA[<p>这篇文章将介绍图论中的拓扑排序。</p>
<h3 id="什么是拓扑排序">什么是拓扑排序？</h3>
<p>对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。</p>
<h3 id="拓扑排序">拓扑排序</h3>
<ul>
<li>入度：指向v的边的个数叫做v的入度。</li>
<li>出度：v指向的点的个数叫做v的出度。</li>
</ul>
<p>如果一个点的入度是<code>0</code>，那么说明这个点是起点（起点不止一个）。如果一个点的出度为<code>0</code>，那么说明这个点排在最后。</p>
<p>举例说明：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgDAG1.jpg" alt="DAG1"  />
</p>
<p>如图所示，这是一个有向无环图，其指向顺序为<code>a,(b,c),d,e</code>,则<code>abcde</code>和<code>acbde</code>都是这个图的拓扑排序。</p>
<p>很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。</p>
<h3 id="拓扑排序的实现">拓扑排序的实现</h3>
<p>DFS和BFS都可以实现拓扑排序。</p>
<h4 id="bfs实现拓扑排序">BFS实现拓扑排序</h4>
<p>这种算法也叫做Kahn算法</p>
<p>继续使用上面的例子进行说明</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgDAG1.jpg" alt="DAG1"  />
</p>
<p>BFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。</p>
<p>无前驱的顶点优先就是顺着找，a的入度为<code>0</code>，则其为起点，a入队；</p>
<p>a出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；</p>
<p>目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；</p>
<p>b出队，b指向d，d入度减一，d入度为零，入队；</p>
<p>d出队，d指向e，e入度减一，e入度为零，入队；</p>
<p>e出队，无后续结点，结束。</p>
<p>由上述过程可得拓扑排序为<code>acbde</code>。</p>
<h6 id="时间复杂度">时间复杂度</h6>
<p>假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。</p>
<p>代码实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
<span style="color:#66d9ef">int</span> T, n, m, u, v;

<span style="color:#66d9ef">int</span> deg[N];
<span style="color:#66d9ef">int</span> vis[N];
<span style="color:#66d9ef">int</span> dest[N];
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g[N];
queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">toposort</span>() {
    <span style="color:#75715e">//将入度为零的点放入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>deg[i]) {
            vis[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            q.push(i);
        }
    }

    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
        <span style="color:#66d9ef">int</span> now <span style="color:#f92672">=</span> q.front();
        q.pop();
        dest[num<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> now;

        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> to : g[now]) {
            <span style="color:#66d9ef">if</span> (vis[to])  <span style="color:#75715e">//判断该节点是否在队列中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span> {
                deg[to]<span style="color:#f92672">--</span>;        <span style="color:#75715e">//入度减一
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>deg[to]) {   <span style="color:#75715e">//判断入度是否为零
</span><span style="color:#75715e"></span>                    q.push(to);   <span style="color:#75715e">//入队
</span><span style="color:#75715e"></span>                    vis[to] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//标记其在队列中
</span><span style="color:#75715e"></span>                }
            }
        }
    }
    <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">==</span> n)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    memset(deg, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(deg));
    memset(vis, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(vis));
    memset(dest, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(dest));

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> N; i<span style="color:#f92672">++</span>)
        g[i].clear();

    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty())
        q.pop();
    <span style="color:#75715e">//以上为初始化
</span><span style="color:#75715e"></span>
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);  <span style="color:#75715e">//读入
</span><span style="color:#75715e"></span>        g[u].push_back(v);
        deg[v]<span style="color:#f92672">++</span>;  <span style="color:#75715e">//统计入度
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">if</span> (toposort()) {<span style="color:#75715e">//如果可以生成拓扑排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)  <span style="color:#75715e">//输出结果
</span><span style="color:#75715e"></span>            printf(<span style="color:#e6db74">&#34;%d%c&#34;</span>, dest[i], i <span style="color:#f92672">==</span> n <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39; &#39;</span>);
    }
    <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//测试数据
</span><span style="color:#75715e">//有向有环图
</span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">2</span>
<span style="color:#75715e">//有向无环图
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>
</code></pre></div><h4 id="dfs实现拓扑排序">DFS实现拓扑排序</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;

<span style="color:#66d9ef">int</span> n, u, v;
<span style="color:#66d9ef">int</span> c[N];          <span style="color:#75715e">// 标志数组
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[N];  <span style="color:#75715e">// vector 实现的邻接表
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> topo;  <span style="color:#75715e">// 拓扑排序后的节点
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u) {
    c[u] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v : G[u]) {
        <span style="color:#66d9ef">if</span> (c[v] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[v])
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(v))
                <span style="color:#66d9ef">return</span> false;
    }
    c[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    topo.push_back(u);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">toposort</span>() {
    topo.clear();
    memset(c, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(c));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; u <span style="color:#f92672">&lt;</span> n; u<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[u])
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(u))
                <span style="color:#66d9ef">return</span> false;
    reverse(topo.begin(), topo.end());
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>高精度计算</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Fri, 19 Mar 2021 22:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</guid>
      <description>简单介绍了一下高精度计算</description>
      <content:encoded><![CDATA[<p>C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题</p>
<h2 id="存储">存储</h2>
<p>高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出</p>
<h4 id="头文件及全局变量">头文件及全局变量</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> LEN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1004</span>;
<span style="color:#66d9ef">int</span> a[LEN], b[LEN], c[LEN], d[LEN];
<span style="color:#66d9ef">int</span> flag;
</code></pre></div><h4 id="清空">清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clean</span>(<span style="color:#66d9ef">int</span> temp[]) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN; <span style="color:#f92672">++</span>i)
        temp[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="存储-1">存储</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">int</span> temp[]) {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> s[LEN <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
    scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, s);

    clean(temp);

    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> strlen(s);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) {
        temp[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i] <span style="color:#f92672">=</span> s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
    }
}
</code></pre></div><h4 id="输出">输出</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">int</span> a[]) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>i)
        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>)
        putchar(a[i] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>);
    putchar(<span style="color:#e6db74">&#39;\n&#39;</span>);
}
</code></pre></div><p>这样就完成了对于数据的存储与输出</p>
<h2 id="加法">加法</h2>
<p>高精度加法其实就是按照竖式加法法则来计算</p>
<p>从低位开始相加，满十则向高一位进一，本位取余</p>
<p>{% note info, 这里使用十进制，也可以使用其他更大的进制，如1000进制 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度加法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> c[]) {
    clean(c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
        c[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {<span style="color:#75715e">//判断是否满十
</span><span style="color:#75715e"></span>            c[i] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">10</span>;
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><h2 id="减法">减法</h2>
<p>高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。</p>
<p>因为要考虑到小数减大数的情况，所以用此函数来判断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">compare</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[]) {
    <span style="color:#66d9ef">int</span> i, j;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>i)
        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>j)
        <span style="color:#66d9ef">if</span> (b[j] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;

    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> j) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> i; p <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>p) {
            <span style="color:#66d9ef">if</span> (a[p] <span style="color:#f92672">==</span> b[p])
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#66d9ef">if</span> (a[p] <span style="color:#f92672">&gt;</span> b[p])
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度减法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sub</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> b, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> c) {
    flag <span style="color:#f92672">=</span> compare(a, b);<span style="color:#75715e">//判断是否是小数减大数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (flag) {<span style="color:#75715e">//如果是
</span><span style="color:#75715e"></span>        putchar(<span style="color:#e6db74">&#39;-&#39;</span>);<span style="color:#75715e">//则输出负号
</span><span style="color:#75715e"></span>        sub(b, a, c);<span style="color:#75715e">//按照大数减小数计算
</span><span style="color:#75715e"></span>        flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span>;
    }

    clean(c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
        c[i] <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">-</span> b[i];
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
            c[i] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><h2 id="乘法">乘法</h2>
<h4 id="高精度低精度">高精度*低精度</h4>
<p>如果是高精度与低精度相乘的话，就没必要使用高精度乘法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mul</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c[]) {
    clean(c);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
        c[i] <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">*</span> b;<span style="color:#75715e">//每位都乘低精度
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> c[i] <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>;
            c[i] <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
        }
    }
}
</code></pre></div><h4 id="高精度高精度">高精度*高精度</h4>
<p>高精度与高精度相乘也是模拟了手写计算乘法的方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度乘法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mul</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> c[]) {
    clean(c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#75715e">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>) {
            c[i] <span style="color:#f92672">+=</span> a[j] <span style="color:#f92672">*</span> b[i <span style="color:#f92672">-</span> j];
        }
        
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> c[i] <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>;
            c[i] <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
        }
    }
}
</code></pre></div><h2 id="除法">除法</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//判断长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">greater_eq</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> last_dg, <span style="color:#66d9ef">int</span> len) {
    <span style="color:#66d9ef">if</span> (a[last_dg <span style="color:#f92672">+</span> len] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
        <span style="color:#66d9ef">if</span> (a[last_dg <span style="color:#f92672">+</span> i] <span style="color:#f92672">&gt;</span> b[i])
            <span style="color:#66d9ef">return</span> true;
        <span style="color:#66d9ef">if</span> (a[last_dg <span style="color:#f92672">+</span> i] <span style="color:#f92672">&lt;</span> b[i])
            <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度除法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">div</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> c[], <span style="color:#66d9ef">int</span> d[]) {
    clean(c);
    clean(d);

    <span style="color:#66d9ef">int</span> la, lb;
    <span style="color:#66d9ef">for</span> (la <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; la <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>la)
        <span style="color:#66d9ef">if</span> (a[la <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">for</span> (lb <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; lb <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>lb)
        <span style="color:#66d9ef">if</span> (b[lb <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">if</span> (lb <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        puts(<span style="color:#e6db74">&#34;除数为零，错误&#34;</span>);
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> la; <span style="color:#f92672">++</span>i) d[i] <span style="color:#f92672">=</span> a[i];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> la <span style="color:#f92672">-</span> lb; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
        <span style="color:#66d9ef">while</span> (greater_eq(d, b, i, lb)) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> lb; <span style="color:#f92672">++</span>j) {
                d[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">-=</span> b[j];
                <span style="color:#66d9ef">if</span> (d[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
                    d[i <span style="color:#f92672">+</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
                    d[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
                }
            }
            c[i] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><h2 id="测试">测试</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    read(a);
    read(b);

    add(a, b, c);
    print(c);

    sub(a, b, c);
    print(c);

    mul(a, b, c);
    print(c);

    div(a, b, c, d);
    print(c);
    print(d);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>快速幂</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Wed, 10 Mar 2021 20:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>简单介绍了一下快速幂</description>
      <content:encoded><![CDATA[<h2 id="引入">引入</h2>
<p>例题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1097">hdu1097</a></p>
<p>这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法</p>
<p>{% folding green, 点击展开 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power){
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> power; i<span style="color:#f92672">++</span>){
        ans <span style="color:#f92672">*=</span>base;
    }
    <span style="color:#66d9ef">return</span> ans <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div><p>{%endfolding%}</p>
<p>那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power){
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    base <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> power; i<span style="color:#f92672">++</span>){
        ans <span style="color:#f92672">*=</span> base;
        <span style="color:#66d9ef">if</span>(ans <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>)
            ans <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
    }
    <span style="color:#66d9ef">return</span> ans;
}
</code></pre></div><p>结果同样，如果数据过大，还是会超时。</p>
<h2 id="快速幂">快速幂</h2>
<p>{% folding green, 取模的运算法则 %}</p>
<p>$(a+b) mod M = (amodM + bmodM)modM$</p>
<p>$(a-b)modM = (amodM - bmodM)modM$</p>
<p>$(a*b)modM = (amodM * bmodM)modM$</p>
<p>{% endfolding %}</p>
<hr>
<h4 id="入门">入门</h4>
<p>快速幂算法可以高效快速的算出$a^n$。</p>
<p>下面举一个例子</p>
<p>如果计算$2^{10}$</p>
<p>$2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2</p>
<p>尽量将指数变小，如下</p>
<p>$2^{10} = (2*2)^5 = 4^5$</p>
<p>此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。</p>
<p>那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样</p>
<p>$2^{10} = 4^4*4^1$</p>
<p>将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作：</p>
<p>$2^{10} = 16^2*4^1$</p>
<p>将指数再次缩小一半</p>
<p>$2^{10} = 256^1*4^1$</p>
<p>此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，<strong>得到的结果是变化过程中所有指数为奇数时的底数的乘积</strong></p>
<h4 id="初步实现">初步实现</h4>
<p>用代码实现上面的算法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power) {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (power) {
        <span style="color:#66d9ef">if</span> (power <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) {
            power <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
            result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
            power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
            base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        } <span style="color:#66d9ef">else</span> {
            power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
            base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        }
    }
    <span style="color:#66d9ef">return</span> result <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div><h4 id="优化">优化</h4>
<p>1.由于if、else中有重复语句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
</code></pre></div><p>2.且在整形运算中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">-=</span><span style="color:#ae81ff">1</span>;
power <span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
</code></pre></div><p>可以压缩成下面一句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
</code></pre></div><hr>
<p>于是代码就可以压缩成以下这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power) {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (power) {
        <span style="color:#66d9ef">if</span> (power <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>)
            result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
    }
    <span style="color:#66d9ef">return</span> result <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div><h4 id="再次优化">再次优化</h4>
<p>在C/C++中可以利用更快位运算来代替一些计算，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
power <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//位运算
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
power <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//位运算
</span></code></pre></div><p>于是代码就变成了这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power) {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (power) {
        <span style="color:#66d9ef">if</span> (power <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)
            result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        power <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
        base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
    }

    <span style="color:#66d9ef">return</span> result <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Wed, 03 Feb 2021 20:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>简单介绍了一下并查集</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6%e6%9f%a5%e9%9b%86.jpg" alt=""  />
</p>
<p>“你只看见我渺小的身躯，却没有看到我心中的广阔森林”</p>
<p>并查集可以总结为三句话：</p>
<ul>
<li>“并”的意思是把两个有某些关系的结点并到一起</li>
<li>“查”的意思是查找一个结点的根节点</li>
<li>“并”的时候需要用到“查”</li>
</ul>
<h3 id="初始化">初始化</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> father[len];<span style="color:#75715e">//此数组定义在全局
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Init</span>(<span style="color:#66d9ef">int</span> n){
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) {<span style="color:#75715e">//len为结点总数
</span><span style="color:#75715e"></span>		father[i] <span style="color:#f92672">=</span> i;
	}
}
</code></pre></div><h3 id="查">查</h3>
<p>初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点）</p>
<p>假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.</p>
<p>如图即是对应关系</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%9f%a5.jpg" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//查（非递归算法）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FindRoot</span>(<span style="color:#66d9ef">int</span> x){
	r <span style="color:#f92672">=</span> x;
    <span style="color:#66d9ef">while</span>(r <span style="color:#f92672">!=</span> father[r]){<span style="color:#75715e">//自己是自己的爹即是找到了根结点
</span><span style="color:#75715e"></span>        r <span style="color:#f92672">=</span> father[r];
    }
    
    <span style="color:#66d9ef">return</span> r;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//递归算法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FindRoot</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">return</span> x <span style="color:#f92672">==</span> father[x] <span style="color:#f92672">?</span> x : FindRoot(father[x]);
}
</code></pre></div><h3 id="并">并</h3>
<p>如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作；</p>
<p>相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//并
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
	x <span style="color:#f92672">=</span> FindRoot(x);
	y <span style="color:#f92672">=</span> FindRoot(y);
    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">!=</span> y){
		parent[y] <span style="color:#f92672">=</span> x;
    }
}
</code></pre></div><h3 id="例题">例题</h3>
<p>hdu1213</p>
<h5 id="问题描述">问题描述</h5>
<p>今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。
此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。</p>
<p>例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上
所以伊格纳修斯至少需要 2 张桌子。</p>
<h5 id="输入">输入</h5>
<p>输入以表示测试用例数的整数 T（1&lt;=T&lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1&lt;=N，M&lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。</p>
<h5 id="输出">输出</h5>
<p>对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。</p>
<h5 id="示例输入">示例输入</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">5</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>

<span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">5</span>

</code></pre></div><h5 id="示例输出">示例输出</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">4</span>
</code></pre></div><p>这道题用一句话概括就是在一张桌子上，每个人都要有认识的人</p>
<h5 id="代码">代码</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> father[<span style="color:#ae81ff">1001</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x) {
	<span style="color:#66d9ef">return</span> father[x] <span style="color:#f92672">==</span> x <span style="color:#f92672">?</span> x : find(father[x]);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span> (<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
	x <span style="color:#f92672">=</span> find(x);
	y <span style="color:#f92672">=</span> find(y);
	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">!=</span> y) {
		a[x] <span style="color:#f92672">=</span> y;
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	<span style="color:#66d9ef">int</span> t, m, n, x, y;
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>t);
	<span style="color:#66d9ef">while</span> (t<span style="color:#f92672">--</span>) {
		scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
		<span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
			father[i] <span style="color:#f92672">=</span> i;
		}

		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">++</span>i) {
			scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
			merge(x, y);
		}
		
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
			<span style="color:#66d9ef">if</span> (father[i] <span style="color:#f92672">==</span> i) {
				cnt<span style="color:#f92672">++</span>;
			}
		}
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cnt);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="优化">优化</h3>
<h4 id="合并的优化">合并的优化</h4>
<p>如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免</p>
<p>不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度</p>
<p>初始化代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> father[len];
<span style="color:#66d9ef">int</span> height[len];
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>){
	father[i] <span style="color:#f92672">=</span> i;
	height[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//初始深度为1
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//并
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
	x <span style="color:#f92672">=</span> FindRoot(x);
	y <span style="color:#f92672">=</span> FindRoot(y);
	<span style="color:#66d9ef">if</span>(height[x] <span style="color:#f92672">==</span> height[y]){<span style="color:#75715e">//此处无需判断x，y根结点是否一致
</span><span style="color:#75715e"></span>		height[x] <span style="color:#f92672">=</span> height[x] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
		father[y] <span style="color:#f92672">=</span> x;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(height[x] <span style="color:#f92672">&gt;</span> height [y]){
		father[y] <span style="color:#f92672">=</span> x;
    }
    <span style="color:#66d9ef">else</span> {
        father[x] <span style="color:#f92672">=</span> y;
    }
}
</code></pre></div><h4 id="查询的优化">查询的优化</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> <span style="color:#75715e">//对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。
</span><span style="color:#75715e">//这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span> (<span style="color:#66d9ef">int</span> x){
    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">!=</span> parent[x]){
		father[x] <span style="color:#f92672">=</span> find(father[x]);
    }
	<span style="color:#66d9ef">return</span> father[x];   
}
</code></pre></div><p>此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并</p>
<p>但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Find</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> x;
    <span style="color:#66d9ef">while</span>(father[r] <span style="color:#f92672">!=</span> r){<span style="color:#75715e">//找到根结点
</span><span style="color:#75715e"></span>		r <span style="color:#f92672">=</span> father[r];
    }
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> x;
    <span style="color:#66d9ef">int</span> j;
    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">!=</span> r){<span style="color:#75715e">//循环修改这条路径上的根结点
</span><span style="color:#75715e"></span>		j <span style="color:#f92672">=</span> father[i];<span style="color:#75715e">//j记录元素i此时的父亲
</span><span style="color:#75715e"></span>		father[i] <span style="color:#f92672">=</span> r;<span style="color:#75715e">//将i的父亲改为根结点
</span><span style="color:#75715e"></span>		i <span style="color:#f92672">=</span> j;<span style="color:#75715e">//i记录为要“查询”的结点
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> r;
}
</code></pre></div><p>经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$</p>
<h3 id="总结">总结</h3>
<ul>
<li>并查集的思想很精妙，用一个数组表示了整片森林</li>
<li>优化的关键在于记录每棵树的结点数量，根据结点关系合并</li>
</ul>]]></content:encoded>
    </item>
    
  </channel>
</rss>
