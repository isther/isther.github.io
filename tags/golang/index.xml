<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Golang on Ther&#39;s Blog</title>
    <link>https://www.niuwx.cn/tags/golang/</link>
    <description>Recent content in Golang on Ther&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 18 Mar 2021 22:33:51 +0800</lastBuildDate><atom:link href="https://www.niuwx.cn/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang学习笔记</title>
      <link>https://www.niuwx.cn/posts/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 13 Mar 2021 10:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Golang学习笔记目录，记录点滴。</description>
      <content:encoded><![CDATA[<p>这里将记录Golang学习的笔记。</p>
<h3 id="go基础">Go基础</h3>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/">Go语言基础之变量与常量</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Go语言基础之基本数据类型</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/">Go语言基础之运算符</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">Go语言基础之流程控制</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/">Go语言基础之数组</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/">Go语言基础之切片</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/">Go语言基础之map</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/">Go语言基础之函数</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/">Go语言基础之指针</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%B8%80%EF%BC%89/">Go语言基础之结构体（一）</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%BA%8C%EF%BC%89/">Go语言基础之结构体（二）</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/">Go语言基础之接口</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/">Go语言基础之并发</a></p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之并发</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Thu, 18 Mar 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</guid>
      <description>并发</description>
      <content:encoded><![CDATA[<p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。</p>
<h3 id="并发和并行">并发和并行</h3>
<p>并发：同一时间段内执行多个任务。</p>
<p>并行：同一时刻执行多个任务。</p>
<p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于进程，属于用户态的进程。可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时调度完成，而线程是由操作系统调度完成。</p>
<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是Go语言并成的CSP并发模式的重要实现基础。</p>
<h3 id="goroutine">goroutine</h3>
<p>Go语言中<code>goroutine</code>的概念类似于线程但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。</p>
<h4 id="goroutine的使用">goroutine的使用</h4>
<p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>gotoutine</code>必定对应一个函数，可以创建的多个<code>goroutine</code>去执行相同的函数。</p>
<h4 id="启动单个goroutine">启动单个goroutine</h4>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">hello</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
}
</code></pre></div><p>这个例子的输出结果是<code>Hello goroutine!</code> 和<code>main goroutine done!</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
}
</code></pre></div><p>这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了<code>main goroutine done!</code>，这是为什么呢？</p>
<p>在程序启动时，Go程序为<code>main()</code>函数创建一个默认的goroutine，当<code>main()</code>函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，<code>hello()</code>还没来得及进行，程序就结束了。</p>
<p>如何才能将hello()进行呢？最简单粗暴的方式就是<code>time.Sleep</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1000</span>)
}
</code></pre></div><p>执行上面的代码会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
<h4 id="启动多个goroutine">启动多个goroutine</h4>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>() <span style="color:#75715e">//goroutine结束也要登记,-1
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine&#34;</span>, <span style="color:#a6e22e">i</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>) <span style="color:#75715e">//启动一个goroutine就登记一次,+1
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>() <span style="color:#75715e">//等待所有登记的goroutine都结束
</span><span style="color:#75715e"></span>}
</code></pre></div><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p>
<h3 id="goroutine与线程">goroutine与线程</h3>
<h4 id="goroutine调度">goroutine调度</h4>
<p>GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<h4 id="gomaxprocs">GOMAXPROCS</h4>
<p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;runtime&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">a</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;A:&#34;</span>, <span style="color:#a6e22e">i</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">b</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;B:&#34;</span>, <span style="color:#a6e22e">i</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOMAXPROCS</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">a</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">b</span>()
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
}
</code></pre></div><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。</p>
<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ol>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ol>
<h3 id="channel">channel</h3>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h4 id="channel类型">channel类型</h4>
<p><code>channel</code>是一种类型，一种引用类型。声明格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">变量</span> <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">元素类型</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch1</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch2</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch3</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">int</span>
</code></pre></div><h4 id="创建channel">创建channel</h4>
<p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ch</span>) <span style="color:#75715e">//nil
</span></code></pre></div><p>声明的通道在<code>make</code>初始化后才能使用。</p>
<p>格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">元素类型</span>, [<span style="color:#a6e22e">大小</span>])
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
<span style="color:#a6e22e">ch3</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">int</span>)
</code></pre></div><h4 id="channel操作">channel操作</h4>
<p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</code></pre></div><h5 id="发送">发送</h5>
<p>将一个值发送到通道中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">// 把10发送到ch中
</span></code></pre></div><h5 id="接收">接收</h5>
<p>从一个通道中接收值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span> <span style="color:#75715e">// 从ch中接收值并赋值给变量x
</span><span style="color:#75715e"></span><span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>       <span style="color:#75715e">// 从ch中接收值，忽略结果
</span></code></pre></div><h5 id="关闭">关闭</h5>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">close(<span style="color:#a6e22e">ch</span>)
</code></pre></div><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<h4 id="无缓冲的通道">无缓冲的通道</h4>
<p>无缓冲的通道又称为阻塞的通道。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;成功&#34;</span>)
}
</code></pre></div><p>这段代码在执行时会出现错误</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fatal error: all goroutines are asleep - deadlock!

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>chan send<span style="color:#f92672">]</span>:
main.main<span style="color:#f92672">()</span>
        E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5f
exit status <span style="color:#ae81ff">2</span>
</code></pre></div><p>因为<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁。</p>
<p>解决方法：</p>
<p>一种方法就是启用一个goroutine去接受，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rec</span>(<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;成功&#34;</span>, <span style="color:#a6e22e">ret</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">rec</span>(<span style="color:#a6e22e">ch</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;成功&#34;</span>)
}
</code></pre></div><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h4 id="有缓冲的通道">有缓冲的通道</h4>
<p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 创建一个容量为1的有缓冲区通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;发送成功&#34;</span>)
}
</code></pre></div><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量。</p>
<h4 id="for-range-从通道循环取值">for range 从通道循环取值</h4>
<p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p>
<p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p>
<p>看这个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#75715e">// 开启goroutine将0~100的数发送到ch1中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
			<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
		}
		close(<span style="color:#a6e22e">ch1</span>)
	}()
	<span style="color:#75715e">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> {
			<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span> <span style="color:#75715e">// 通道关闭后再取值ok=false
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
				<span style="color:#66d9ef">break</span>
			}
			<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">i</span>
		}
		close(<span style="color:#a6e22e">ch2</span>)
	}()
	<span style="color:#75715e">// 在主goroutine中从ch2中接收值打印
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch2</span> { <span style="color:#75715e">// 通道关闭后会退出for range循环
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}

}
</code></pre></div><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p>
<h4 id="单向通道">单向通道</h4>
<p>有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">counter</span>(<span style="color:#a6e22e">out</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">out</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
	}
	close(<span style="color:#a6e22e">out</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">squarer</span>(<span style="color:#a6e22e">out</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">in</span> {
		<span style="color:#a6e22e">out</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">i</span>
	}
	close(<span style="color:#a6e22e">out</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printer</span>(<span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">in</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">counter</span>(<span style="color:#a6e22e">ch1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">squarer</span>(<span style="color:#a6e22e">ch2</span>, <span style="color:#a6e22e">ch1</span>)
	<span style="color:#a6e22e">printer</span>(<span style="color:#a6e22e">ch2</span>)
}
</code></pre></div><p>其中，</p>
<ul>
<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li>
<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li>
</ul>
<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>
<h3 id="worker-pool-goroutine池">worker pool （goroutine池）</h3>
<p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">results</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">jobs</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;worker:%d start job:%d\n&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;worker:%d end job:%d\n&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">i</span>)

		<span style="color:#a6e22e">results</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">jobs</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)
	<span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)

    <span style="color:#75715e">//只开启3个goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">w</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">w</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">jobs</span>, <span style="color:#a6e22e">results</span>)
	}
	<span style="color:#75715e">//5个任务
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">j</span>
	}

	close(<span style="color:#a6e22e">jobs</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">a</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">a</span><span style="color:#f92672">++</span> {
		<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">results</span>
	}
}

</code></pre></div><h3 id="select多路复用">select多路复用</h3>
<p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span>{
    <span style="color:#75715e">// 尝试从ch1接收值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span>
    <span style="color:#75715e">// 尝试从ch2接收值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch2</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
}
</code></pre></div><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>
<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">select</span>{
    <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch2</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ch3</span><span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">data</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">default</span>:
        <span style="color:#a6e22e">默认操作</span>
}
</code></pre></div><p>举个例子来演示下<code>select</code>的使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>:
		}
	}
}
</code></pre></div><p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>
</ul>
<h3 id="并发安全和锁">并发安全和锁</h3>
<p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">50000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)
}

</code></pre></div><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h4 id="互斥锁">互斥锁</h4>
<p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">50000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>() <span style="color:#75715e">//上锁
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
		<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>() <span style="color:#75715e">//解锁
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)
}
</code></pre></div><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>
<h4 id="读写互斥锁">读写互斥锁</h4>
<p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<p>读写锁示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> (
	<span style="color:#a6e22e">x</span>      <span style="color:#66d9ef">int64</span>
	<span style="color:#a6e22e">wg</span>     <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#75715e">//lock   sync.Mutex
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">write</span>() {
	<span style="color:#75715e">// lock.Lock()   // 加互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">Lock</span>() <span style="color:#75715e">// 加写锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// 假设读操作耗时10毫秒
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">Unlock</span>()                   <span style="color:#75715e">// 解写锁
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// lock.Unlock()                     // 解互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">read</span>() {
	<span style="color:#75715e">// lock.Lock()                  // 加互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">RLock</span>()               <span style="color:#75715e">// 加读锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// 假设读操作耗时1毫秒
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">RUnlock</span>()             <span style="color:#75715e">// 解读锁
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// lock.Unlock()                // 解互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">write</span>()
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">read</span>()
	}

	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">start</span>))
}
</code></pre></div><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h4 id="syncwaitgroup">sync.WaitGroup</h4>
<p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(wg * WaitGroup) Add(delta int)</td>
<td style="text-align:center">计数器+delta</td>
</tr>
<tr>
<td style="text-align:center">(wg *WaitGroup) Done()</td>
<td style="text-align:center">计数器-1</td>
</tr>
<tr>
<td style="text-align:center">(wg *WaitGroup) Wait()</td>
<td style="text-align:center">阻塞直到计数器变为0</td>
</tr>
</tbody>
</table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello Goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>() <span style="color:#75715e">// 启动另外一个goroutine去执行hello函数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
<h4 id="synconce">sync.Once</h4>
<p>说在前面的话：这是一个进阶知识点。</p>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Once</span>) <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()) {}
</code></pre></div><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p>
<h5 id="加载配置文件示例">加载配置文件示例</h5>
<p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">icons</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadIcons</span>() {
	<span style="color:#a6e22e">icons</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>{
		<span style="color:#e6db74">&#34;left&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;left.png&#34;</span>),
		<span style="color:#e6db74">&#34;up&#34;</span>:    <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;up.png&#34;</span>),
		<span style="color:#e6db74">&#34;right&#34;</span>: <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;right.png&#34;</span>),
		<span style="color:#e6db74">&#34;down&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;down.png&#34;</span>),
	}
}

<span style="color:#75715e">// Icon 被多个goroutine调用时不是并发安全的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Icon</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">icons</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">loadIcons</span>()
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">icons</span>[<span style="color:#a6e22e">name</span>]
}
</code></pre></div><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadIcons</span>() {
	<span style="color:#a6e22e">icons</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;left&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;left.png&#34;</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;up&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;up.png&#34;</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;right&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;right.png&#34;</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;down&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;down.png&#34;</span>)
}
</code></pre></div><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">icons</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">loadIconsOnce</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadIcons</span>() {
	<span style="color:#a6e22e">icons</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>{
		<span style="color:#e6db74">&#34;left&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;left.png&#34;</span>),
		<span style="color:#e6db74">&#34;up&#34;</span>:    <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;up.png&#34;</span>),
		<span style="color:#e6db74">&#34;right&#34;</span>: <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;right.png&#34;</span>),
		<span style="color:#e6db74">&#34;down&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;down.png&#34;</span>),
	}
}

<span style="color:#75715e">// Icon 是并发安全的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Icon</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span> {
	<span style="color:#a6e22e">loadIconsOnce</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">loadIcons</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">icons</span>[<span style="color:#a6e22e">name</span>]
}
</code></pre></div><h5 id="并发安全的单例模式">并发安全的单例模式</h5>
<p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">singleton</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">singleton</span> <span style="color:#66d9ef">struct</span> {}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">singleton</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">once</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetInstance</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">singleton</span> {
    <span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">instance</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">singleton</span>{}
    })
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">instance</span>
}
</code></pre></div><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h4 id="syncmap">sync.Map</h4>
<p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
			<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;k=:%v,v:=%v\n&#34;</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>))
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Map</span>{}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
			<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">key</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;k=:%v,v:=%v\n&#34;</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><h3 id="原子操作">原子操作</h3>
<p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h4 id="示例">示例</h4>
<p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
	<span style="color:#e6db74">&#34;sync/atomic&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Counter</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Inc</span>()
	<span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span>
}

<span style="color:#75715e">// 普通版
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CommonCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">CommonCounter</span>) <span style="color:#a6e22e">Inc</span>() {
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">CommonCounter</span>) <span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">counter</span>
}

<span style="color:#75715e">// 互斥锁版
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MutexCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int64</span>
	<span style="color:#a6e22e">lock</span>    <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MutexCounter</span>) <span style="color:#a6e22e">Inc</span>() {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MutexCounter</span>) <span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span> {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">counter</span>
}

<span style="color:#75715e">// 原子操作版
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AtomicCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AtomicCounter</span>) <span style="color:#a6e22e">Inc</span>() {
	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">counter</span>, <span style="color:#ae81ff">1</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AtomicCounter</span>) <span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">LoadInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">counter</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Counter</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Inc</span>()
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}()
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Load</span>(), <span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">start</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">CommonCounter</span>{} <span style="color:#75715e">// 非并发安全
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">c1</span>)
	<span style="color:#a6e22e">c2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MutexCounter</span>{} <span style="color:#75715e">// 使用互斥锁实现并发安全
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c2</span>)
	<span style="color:#a6e22e">c3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">AtomicCounter</span>{} <span style="color:#75715e">// 并发安全且比互斥锁效率更高
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c3</span>)
}
</code></pre></div><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之接口</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 18 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口</description>
      <content:encoded><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h3 id="接口类型">接口类型</h3>
<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p><code>interface</code>是一组<code>method</code>的集合，不关心属性（数据），只关心行为（方法）。</p>
<h3 id="引入">引入</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cat</span> <span style="color:#66d9ef">struct</span>{} <span style="color:#75715e">//猫
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">Say</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;喵喵喵&#34;</span> }

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span>{} <span style="color:#75715e">//狗
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">Say</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;汪汪汪&#34;</span> }

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Cat</span>{}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Say</span>())

	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Say</span>())
}
</code></pre></div><p>上述代码定义了猫和狗，以及他们叫声的方法，可以发现，main中会有重复的代码，如果再加上其他动物，代码还会重复，那如果把他们都归类成“会叫的动物”来处理呢？</p>
<p>像这样类似的例子还有很多，例如：</p>
<p>支付宝、微信、银联等在线支付的方式，可以把它们当成支付方式来处理。</p>
<p>计算三角形、正方形、圆形等的周长和面积，可以把他们当成图形来处理</p>
<p>等等……</p>
<p>而在Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于所有的具体类型，接口是一种抽象的类型。当看到一个接口类型的值时，你不知道它是什么，只知道通过它的方法能做什么。</p>
<h3 id="接口的定义">接口的定义</h3>
<p>Go语言提倡面向接口编程</p>
<p>每个接口由数个方法组成，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">接口类型名</span> <span style="color:#66d9ef">interface</span>{
    <span style="color:#a6e22e">方法名1</span>( <span style="color:#a6e22e">参数列表1</span> ) <span style="color:#a6e22e">返回值列表1</span>
    <span style="color:#a6e22e">方法名2</span>( <span style="color:#a6e22e">参数列表2</span> ) <span style="color:#a6e22e">返回值列表2</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
}
</code></pre></div><ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">writer</span> <span style="color:#66d9ef">interface</span>{
    <span style="color:#a6e22e">Write</span>([]<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span>
}
</code></pre></div><p>当你看到这个接口类型的值时，并不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p>
<h3 id="接口实现的条件">接口实现的条件</h3>
<p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个{% emp 需要实现的方法列表 %}</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Sayer</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Say</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cat</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">Say</span>() { <span style="color:#75715e">//Cat实现了Sayer接口
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;喵喵喵&#34;</span>) 
} 

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">Say</span>() { <span style="color:#75715e">//Dog实现了Sayer接口
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;汪汪汪&#34;</span>) 
} 
</code></pre></div><h3 id="接口类型的变量">接口类型的变量</h3>
<p>实现了接口有什么作用呢？</p>
<p>接口类型变量能够储存所有实现了该接口的实例。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Sayer</span>

	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Cat</span>{}
	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Dog</span>{}

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">Say</span>()

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">d</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">Say</span>()
}
</code></pre></div><h3 id="值接收者和指针接收者实现接口的区别">值接收者和指针接收者实现接口的区别</h3>
<p>定义一个<code>Mover</code>接口和一个<code>Dog</code>结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span>{}
</code></pre></div><p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;狗跑了&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wangcai</span> = <span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">wangcai</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fugui</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">fugui</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
}
</code></pre></div><p>从上面这段代码不难发现，使用值接收者实现接口之后，不管是Dog结构体还是*Dog结构体指针类型的变量都可以赋值给该接口变量。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>同样的代码，如果使用指针接受实现接口呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;狗跑了&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wangcai</span> = <span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">wangcai</span> <span style="color:#75715e">//x不可以接收Dog类型
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fugui</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">fugui</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
}
</code></pre></div><p>此时实现<code>Mover</code>接口的是<code>*Dog</code>类型，所以不能给<code>x</code>传入<code>Dog</code>类型。</p>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="类型与接口的关系">类型与接口的关系</h3>
<h4 id="一个类型实现多个接口">一个类型实现多个接口</h4>
<p>一个类型可以同时实现多个接口，而接口之间批次独立。例如，狗可以叫，也可以跑。就可以分别定义Sayer接口和Mover接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Sayer</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">say</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">say</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s说\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s跑了\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#a6e22e">Sayer</span>

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">Dog</span>{<span style="color:#e6db74">&#34;旺财&#34;</span>}

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">a</span>

	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
	<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">say</span>()
}
</code></pre></div><h4 id="多个类型实现同一接口">多个类型实现同一接口</h4>
<p>Go语言中不同的类型还可以实现同一接口，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s跑了\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Car</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Car</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s跑了\n&#34;</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> = <span style="color:#a6e22e">Dog</span>{<span style="color:#e6db74">&#34;旺财&#34;</span>}
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">Car</span>{<span style="color:#e6db74">&#34;保时捷&#34;</span>}

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">d</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">move</span>()
    <span style="color:#75715e">//不关心具体是什么，只需调用方法即可
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="接口嵌套">接口嵌套</h3>
<p>接口与接口之间可以通过嵌套创造出新的接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//Sayer接口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Sayer</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">say</span>()
}

<span style="color:#75715e">//Mover接口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#75715e">//接口嵌套
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">animal</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">Sayer</span>
	<span style="color:#a6e22e">Mover</span>
}
</code></pre></div><p>嵌套得到的接口的使用与普通接口一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cat</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">say</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;喵喵喵&#34;</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;猫跑了&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">animal</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">Cat</span>{<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;臭宝&#34;</span>}

	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">say</span>()
}
</code></pre></div><h3 id="空接口">空接口</h3>
<h4 id="空接口的定义">空接口的定义</h4>
<p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{}

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">s</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)

	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">i</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)

	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">b</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)
}
</code></pre></div><h4 id="空接口的应用">空接口的应用</h4>
<p>{% tabs tab-2 %}</p>
<!-- raw HTML omitted -->
<p>使用空接口实现可以接受任意类型的函数参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">show</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">a</span>)
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>使用空接口实现可以保存任意值的字典。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">studentInfo</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
	<span style="color:#a6e22e">studentInfo</span>[<span style="color:#e6db74">&#34;name&#34;</span>] = <span style="color:#e6db74">&#34;臭宝&#34;</span>
	<span style="color:#a6e22e">studentInfo</span>[<span style="color:#e6db74">&#34;age&#34;</span>] = <span style="color:#ae81ff">18</span>
	<span style="color:#a6e22e">studentInfo</span>[<span style="color:#e6db74">&#34;married&#34;</span>] = <span style="color:#66d9ef">false</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">studentInfo</span>)
	<span style="color:#75715e">//map[age:18 married:false name:臭宝]
</span><span style="color:#75715e"></span>}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="类型断言">类型断言</h3>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之结构体（二）</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/</link>
      <pubDate>Wed, 17 Mar 2021 20:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/</guid>
      <description>结构体</description>
      <content:encoded><![CDATA[<p>在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。</p>
<h3 id="构造函数">构造函数</h3>
<p>在C++面向对象中，声明一个对象后，可以写一些针对该对象的一些方法，例如构造函数等。Go语言中的结构体没有构造函数，可以自己实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">//构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Student</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">student</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{ <span style="color:#75715e">//struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">name</span>,
		<span style="color:#a6e22e">age</span>,
		<span style="color:#a6e22e">id</span>,
		<span style="color:#a6e22e">score</span>,
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#75715e">//&amp;main.student{name:&#34;小学生&#34;, age:7, id:&#34;666&#34;, score:60}
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="方法和接收者">方法和接收者</h3>
<p>Go语言中的<code>方法(Method)</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者(Receiver)</code>。接收者的概念类似于C++中的<code>this</code>。</p>
<p>定义格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">接收者变量</span> <span style="color:#a6e22e">接收者类型</span>) <span style="color:#a6e22e">方法名</span>(<span style="color:#a6e22e">参数列表</span>) (<span style="color:#a6e22e">返回参数</span>) {
    <span style="color:#a6e22e">函数体</span>
}
</code></pre></div><ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>this</code>之类的命名。例如，student类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">//构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Student</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">student</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{ <span style="color:#75715e">//struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">name</span>,
		<span style="color:#a6e22e">age</span>,
		<span style="color:#a6e22e">id</span>,
		<span style="color:#a6e22e">score</span>,
	}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">student</span>) <span style="color:#a6e22e">study</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;我要好好学习！\n&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">study</span>()
}
</code></pre></div><p>方法和函数的区别就是函数不属于任何类型，方法只属于特定的类型</p>
<p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<p>指针类型的接收者由一个结构的指针组成，由于指针的特性，调用方法时可以修改接收者指针的任何成员变量，在方法结束后，修改依然有效。这种方法类似于C++中使用<code>this</code>。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">student</span>) <span style="color:#a6e22e">setAge</span>(<span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#a6e22e">age</span>
}
</code></pre></div><p>这是一个修改student的age 的方法</p>
<p>调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//7
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">setAge</span>(<span style="color:#ae81ff">18</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//18
</span><span style="color:#75715e"></span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>与指针类型的接收者对比，调用方法时，拿到的是值类型接收者的值的拷贝份。在值类型接收者的方法中可以获取接收者的成员值，但修改成员变量指针对这个副本，无法修改接收者变量本身。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">student</span>) <span style="color:#a6e22e">setAge</span>(<span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#a6e22e">age</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//7
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">setAge</span>(<span style="color:#ae81ff">18</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//7
</span><span style="color:#75715e"></span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ol>
<li>需要修改接收者的成员值</li>
<li>接收者是比较复杂的结构体，拷贝开销大</li>
</ol>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="任意类型添加方法">任意类型添加方法</h3>
<p>Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。例如，基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为这个自定义类型添加方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">MyInt</span>) <span style="color:#a6e22e">SayHello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello, I&#39;m SatHello&#34;</span>) <span style="color:#75715e">//Hello, I&#39;m SatHello
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">MyInt</span>
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">SayHello</span>()
	<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v %T\n&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>) <span style="color:#75715e">//100 main.MyInt
</span><span style="color:#75715e"></span>}
</code></pre></div><p>注意：只可以给本包的类型定义方法</p>
<h3 id="结构体的匿名字段">结构体的匿名字段</h3>
<p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段称为匿名字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#66d9ef">string</span>
	<span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{
		<span style="color:#e6db74">&#34;小学生&#34;</span>,
		<span style="color:#ae81ff">7</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">s</span>) <span style="color:#75715e">//&amp;main.student{string:&#34;小学生&#34;, int:7}
</span><span style="color:#75715e"></span>}
</code></pre></div><p>匿名字段的说法并不代表没有字段名，而是默认采用类型名作为字段名。从其定义中不难发现，</p>
<p>由于结构体要求字段名必须唯一，因此一个结构体中一种类型的匿名字段只能有一个。</p>
<h3 id="嵌套结构体">嵌套结构体</h3>
<p>一个结构体中可以嵌套包含另一个结构体或结构体指针，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">//成绩信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">grade</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">math</span>    <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">chinese</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">english</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">//学生信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">mygrade</span> <span style="color:#a6e22e">grade</span>
    <span style="color:#75715e">//grade
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//↑可采用匿名字段的方式嵌套
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{
		<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;小学生&#34;</span>,
		<span style="color:#a6e22e">age</span>:  <span style="color:#ae81ff">7</span>,
		<span style="color:#a6e22e">mygrade</span>: <span style="color:#a6e22e">grade</span>{
			<span style="color:#a6e22e">math</span>:    <span style="color:#ae81ff">60</span>,
			<span style="color:#a6e22e">chinese</span>: <span style="color:#ae81ff">60</span>,
			<span style="color:#a6e22e">english</span>: <span style="color:#ae81ff">60</span>,
		},
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#75715e">//&amp;main.student{name:&#34;小学生&#34;, age:7, mygrade:main.grade{math:60, chinese:60, english:60}}
</span><span style="color:#75715e"></span>}

</code></pre></div><h3 id="结构体的继承">结构体的“继承”</h3>
<p>Go语言中使用结构体也可以实现C++中面向对象的继承。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Animal</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Animal</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s会动\n&#34;</span>, <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">age</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">Animal</span> <span style="color:#75715e">//通过嵌套匿名结构体实现继承
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">wang</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s汪汪汪的叫\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Dog</span>{
		<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">4</span>,
		<span style="color:#a6e22e">Animal</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Animal</span>{
			<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;小明&#34;</span>,
		},
	}
	<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">move</span>()
	<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">wang</span>()
}

</code></pre></div><h3 id="结构体字段的可见性">结构体字段的可见性</h3>
<p>结构体中字段大写开头表示可公开访问，小写代表私有（仅在定义当前结构体的包中可访问）</p>
<p>{% note warning, 区别私有概念 %}</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之结构体（一）</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80/</link>
      <pubDate>Wed, 17 Mar 2021 18:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80/</guid>
      <description>结构体</description>
      <content:encoded><![CDATA[<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<h2 id="自定义类型和类型别名">自定义类型和类型别名</h2>
<p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以像C/C++一样使用<code>type</code>关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//将MyInt定义为int类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> <span style="color:#66d9ef">int</span>
</code></pre></div><p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>类型别名规定：MyType只是Type的别名，本质上MyType与Type是同一个类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyType</span> = <span style="color:#a6e22e">Type</span>
</code></pre></div><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">byte</span> = <span style="color:#66d9ef">uint8</span>
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">rune</span> = <span style="color:#66d9ef">int32</span>
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>自定义类型和类型别名在语法上看似只有一个等号的差别，但其实不然，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//自定义类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NewInt</span> <span style="color:#66d9ef">int</span>

<span style="color:#75715e">//类型别名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> = <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">NewInt</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#a6e22e">MyInt</span>
   	
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">a</span>) <span style="color:#75715e">//main.NewInt
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T&#34;</span>, <span style="color:#a6e22e">b</span>) <span style="color:#75715e">//int
</span><span style="color:#75715e"></span>}
</code></pre></div><p>输出结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的``NewInt<code>类型；b的类型是</code>int`。</p>
<p><code>MyInt</code>类型在编译完成时，会被替换成int</p>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h2 id="结构体">结构体</h2>
<p>Go语言中结构体的定义与C/C++中类似。</p>
<p>我们想表达一个事物的全部或部分属性时，这时用单一的基本数据类型无法满足需求，Go语言提供了自定义数据类型，可以封装多个基本数据类型，这就是结构体。</p>
<p>通过<code>struct</code>来定义，同时在Go语言中，也通过<code>struct</code>实现面向对象</p>
<h3 id="结构体的定义">结构体的定义</h3>
<p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyType</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Name1</span> <span style="color:#a6e22e">Type1</span>
	<span style="color:#a6e22e">Name2</span> <span style="color:#a6e22e">Type2</span>
	<span style="color:#f92672">...</span>
}
</code></pre></div><ul>
<li>MyType：自定义类型的名称，同一个包中不可重复</li>
<li>Name1和Name2：结构体中成员名称，同一结构体中不可重复</li>
<li>Type1和Type2：成员的具体类型</li>
</ul>
<p>例如，定义一个学生的结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}
</code></pre></div><p>这样，使用student结构体就可以很方便在代码中表示和储存信息了</p>
<p>Go语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>
<h3 id="结构体实例化">结构体实例化</h3>
<p>只有结构体实例化后，才会对相应的变量分配内存。结构体实例化与声明内置类型一样，使用<code>var</code>关键字声明变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">student1</span> <span style="color:#a6e22e">student</span>
</code></pre></div><p>{% tabs tab-2 %}</p>
<!-- raw HTML omitted -->
<p>通过<code>.</code>访问结构体的成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stu</span> <span style="color:#a6e22e">student</span> <span style="color:#75715e">//声明结构体变量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//赋值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span>
	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">id</span> = <span style="color:#e6db74">&#34;666&#34;</span>
	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">60</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)

}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">666</span> <span style="color:#ae81ff">60</span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>在定义一些临时数据结构等场景下，可以使命匿名结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span> {
		<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
		<span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
	}
	<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span>
	<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">user</span>)
}

</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Go语言中还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> = new(<span style="color:#a6e22e">student</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span> <span style="color:#75715e">//Go语言中支持对结构体指针直接使用.来访问结构体成员
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">id</span> = <span style="color:#e6db74">&#34;666&#34;</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">60</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">*</span><span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">student</span>
<span style="color:#f92672">&amp;</span>{ <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>}
<span style="color:#f92672">&amp;</span>{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">666</span> <span style="color:#ae81ff">60</span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>使用<code>&amp;</code>对结构体进行取址操作相当于对该结构体进行了依次<code>new</code>实例化操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">id</span> = <span style="color:#e6db74">&#34;666&#34;</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">60</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}

</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">*</span><span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">student</span>
<span style="color:#f92672">&amp;</span>{ <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>}
<span style="color:#f92672">&amp;</span>{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">666</span> <span style="color:#ae81ff">60</span>}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="结构体初始化">结构体初始化</h3>
<p>没有初始化的结构体，其成员变量都是对应类型的零值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stu</span> <span style="color:#a6e22e">student</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">stu</span>)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">student</span>{<span style="color:#a6e22e">name</span>:<span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">age</span>:<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">id</span>:<span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">score</span>:<span style="color:#ae81ff">0</span>}
</code></pre></div><p>{% tabs tab-3 %}</p>
<!-- raw HTML omitted -->
<p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#a6e22e">name</span>:  <span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#a6e22e">age</span>:   <span style="color:#ae81ff">7</span>,
	<span style="color:#a6e22e">id</span>:    <span style="color:#e6db74">&#34;666&#34;</span>,
	<span style="color:#a6e22e">score</span>: <span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//{小学生 7 666 60}
</span></code></pre></div><p>也可以对结构体指针进行键值对初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#a6e22e">name</span>:  <span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#a6e22e">age</span>:   <span style="color:#ae81ff">7</span>,
	<span style="color:#a6e22e">id</span>:    <span style="color:#e6db74">&#34;666&#34;</span>,
	<span style="color:#a6e22e">score</span>: <span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//&amp;{小学生 7 666 60}
</span></code></pre></div><p>当某些字段没有初始值时，该字段可以不写。此时，没有指定初始值的字段的值时该字段类型的零值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#a6e22e">name</span>:  <span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#a6e22e">score</span>: <span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v&#34;</span>, <span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//main.student{name:&#34;小学生&#34;, age:0, id:&#34;&#34;, score:60}
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>初始话结构体时可以简写，也就是初始化时不写键，直接写值即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#ae81ff">7</span>,
	<span style="color:#e6db74">&#34;666&#34;</span>,
	<span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//{小学生 7 666 60}
</span></code></pre></div><p>使用这种格式要注意：</p>
<ul>
<li>必须初始化结构体的所有字段</li>
<li>顺序必须一致</li>
<li>不可与简直初始化混用</li>
</ul>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="结构体内存布局">结构体内存布局</h3>
<p>结构体占用一块连续的内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int8</span>
	<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int8</span>
	<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int8</span>
	<span style="color:#a6e22e">d</span> <span style="color:#66d9ef">int8</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>{
		<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.a %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">a</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.b %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">b</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.c %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">c</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.d %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">d</span>)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">a</span> <span style="color:#ae81ff">0xc000012090</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">b</span> <span style="color:#ae81ff">0xc000012091</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">c</span> <span style="color:#ae81ff">0xc000012092</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">d</span> <span style="color:#ae81ff">0xc000012093</span>
</code></pre></div><h4 id="空结构体">空结构体</h4>
<p>空结构体不占用空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">struct</span>{}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">t</span>)) <span style="color:#75715e">// 0
</span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之指针</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 17 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</guid>
      <description>Go指针</description>
      <content:encoded><![CDATA[<p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<h2 id="go语言中的指针">Go语言中的指针</h2>
<p>Go语言中的指针与C/C++中指针有一定的区别，Go语言中的指针不能进行偏移和运算，是安全指针。因此，Go语言中的指针操作比较简单，只需要记住两个符号<code>&amp;</code>（取址）和<code>*</code>（取值）</p>
<h3 id="指针地址和指针类型">指针地址和指针类型</h3>
<p>每个变量在运行都有一个地址，这个地址也就代表变量在内存中的位置。Go语言中使用<code>&amp;</code>对变量进行取地址。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">//定义整型变量a
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#ae81ff">10</span><span style="color:#75715e">//p为整型类型的指针类型，其中保存的是变量a的地址
</span></code></pre></div><p>在Go语言中，每个值类型都有对应的指针类型。</p>
<h3 id="指针取值">指针取值</h3>
<p>在对变量使用<code>&amp;</code>取地址后，可以使用<code>*</code>对接收了地址的指针变量进行取值，有一个很简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>{% folding green, 输出结果 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#ae81ff">10</span>
</code></pre></div><p>{% endfolding %}</p>
<h3 id="指针传值示例">指针传值示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {
	<span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">20</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">myfunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>{% folding blue, 输出结果 %}</p>
<pre tabindex="0"><code>20
</code></pre><p>{% endfolding %}</p>
<h2 id="new--make">new &amp; make</h2>
<p>先分析一个经典的例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">b</span>[<span style="color:#e6db74">&#34;哈哈哈&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>执行这段代码，其实是会报错的。</p>
<ol>
<li>在声明了整型的指针类型a之后，系统并没有给变量分配内存空间</li>
<li>在声明了map类型的b之后，同样，系统并没有给其分配内存空间</li>
</ol>
<p>Go语言中对于值类型的声明，在声明的时候就默认分配了内存空间。然而对于引用类型，在使用的时候不仅要声明它，还要给它分配内存空间，否则无法储存。</p>
<p>所以就要使用Go语言中new和make来分配内存</p>
<h3 id="new">new</h3>
<p><code>new</code>是一个内置的函数，语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Type</span>)
<span style="color:#75715e">//name 变量名
</span><span style="color:#75715e">//Type 指针变量指向的变量的类型
</span></code></pre></div><p>举例说明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> new(<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#66d9ef">bool</span>)
    
    <span style="color:#75715e">//使用new函数后得到的是一个指针变量，且该指针对应的值为该类型的零值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>在上述开始的经典例子中，<code>var a *int</code>只是声明了指针变量a，但是并未初始化，指针作为引用类型需要初始化才会有内存空间，才可对其进行赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">a</span> = new(<span style="color:#66d9ef">int</span>)
    <span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">100</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)
}
</code></pre></div><h3 id="make">make</h3>
<p>make也用于内存分配，区别于new，只用于slice(切片)，map以及chan(通道)的内存创建，而不是他们的指针类型，因为这三种类型本来就是引用类型。</p>
<p>语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">Type1</span>]<span style="color:#a6e22e">Type2</span>, <span style="color:#a6e22e">Size</span>)
</code></pre></div><p>make函数是无可替代的，在使用slice，map以及chan时，都需要使用make初始化。</p>
<p>在上述开始的经典例子中，<code>var b map[string]int</code>只是声明了b是一个map类型的变量，并未初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">b</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
    <span style="color:#a6e22e">b</span>[<span style="color:#e6db74">&#34;哈哈哈&#34;</span>] = <span style="color:#ae81ff">10</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)
}
</code></pre></div><h3 id="new和make的异同">new和make的异同</h3>
<ol>
<li>new和make都是用来做内存分配的</li>
<li>make只用于slice，map，channel的初始化</li>
<li>new用于指针类型的分配，而且内存对应的值为类型零值</li>
</ol>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之函数</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 16 Mar 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</guid>
      <description>函数</description>
      <content:encoded><![CDATA[<p>函数是基本的代码块，用于执行一个任务。</p>
<p>Go 语言至少要有个 main() 函数。</p>
<p>本文将介绍Go语言中函数的相关内容。</p>
<h2 id="函数">函数</h2>
<p>Go语言中支持函数、匿名函数、闭包。</p>
<h3 id="函数定义">函数定义</h3>
<p>Go语言中定义函数使用关键字<code>func</code>，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">函数名</span>(<span style="color:#a6e22e">参数1</span>,<span style="color:#a6e22e">参数2</span>)(<span style="color:#a6e22e">返回值1</span>,<span style="color:#a6e22e">返回值2</span>){
    <span style="color:#a6e22e">函数体</span>
}
</code></pre></div><ul>
<li>函数名：命名规则与变量相同</li>
<li>参数：参数由参数变量和参数变量类型组成</li>
<li>返回值：返回值由返回值变量和返回值类型组成，也可以只写返回值的类型。Go语言支持多个返回值，须用<code>()</code>包裹。</li>
</ul>
<p>具体用以下例子说明：</p>
<p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mysum</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myhello</span>(){
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello Boy!&#34;</span>)
}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="函数调用">函数调用</h3>
<p>在定义了函数之后，可以通过<code>函数名()</code>的方式对函数进行调用。</p>
<p>例如调用上述定义的两个函数，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">myhello</span>();
    <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret</span>)
}
</code></pre></div><h3 id="参数">参数</h3>
<p>{% tabs tab-2 %}</p>
<!-- raw HTML omitted -->
<p>函数中的参数如果相邻变量的类型相同，则可以省略类型，只留一个，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mysum</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>可变参数是指函数的参数数量不固定，Go语言中的可变参数通过在参数名后加<code>...</code>来表示。</p>
<p>{% note warning, 可变参数通常要作为函数的最后一个参数 %}</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mysum2</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>) <span style="color:#75715e">//x是一个切片
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">x</span>{
        <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}


<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">ret1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum2</span>()
    <span style="color:#a6e22e">ret2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum2</span>(<span style="color:#ae81ff">10</span>)
    <span style="color:#a6e22e">ret3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum3</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret1</span>,<span style="color:#a6e22e">ret2</span>,<span style="color:#a6e22e">ret3</span>)
}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="返回值">返回值</h3>
<p>Go语言中通过关键字<code>return</code>返回</p>
<p>{% tabs tab-3 %}</p>
<!-- raw HTML omitted -->
<p>Go语言中函数支持多个返回值，函数如果有多个返回值时，必须用<code>()</code>将返回值括起来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>){
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
    <span style="color:#a6e22e">sub</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>,<span style="color:#a6e22e">sub</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">sum</span>, <span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
	<span style="color:#a6e22e">sub</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// 没必要返回[]int{}
</span><span style="color:#75715e"></span>	}
	<span style="color:#f92672">...</span>
}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h2 id="函数进阶">函数进阶</h2>
<h3 id="函数类型和变量">函数类型和变量</h3>
<p>使用<code>type</code>关键字来定义一个函数类型，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mytype</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>
</code></pre></div><p>上面的语句定义了一个<code>mytype</code>类型，一种函数类型，且这种函数接受两个int类型的参数并且返回一个int类型的返回值。简单点来说，凡是满足这个条件的函数都是mytype类型的函数，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sub</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mytype</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">mytype</span>
	<span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">add</span>              <span style="color:#75715e">//将函数add赋值给变量c
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)) <span style="color:#75715e">// 可以像add一样调用c
</span><span style="color:#75715e"></span>}

</code></pre></div><h3 id="高阶函数">高阶函数</h3>
<h4 id="函数作为参数">函数作为参数</h4>
<p>Go语言中，函数可以作为参数。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">canshu</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">canshu</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ret1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">add</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret1</span>)
}
</code></pre></div><p>也可以使用定义函数类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mytype</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">canshu</span> <span style="color:#a6e22e">mytype</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">canshu</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ret1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">add</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret1</span>)
}

</code></pre></div><h4 id="函数作为返回值">函数作为返回值</h4>
<p>Go语言中，函数可以作为返回值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//待补充
</span></code></pre></div><h3 id="匿名函数和闭包">匿名函数和闭包</h3>
<h4 id="匿名函数">匿名函数</h4>
<p>Go语言中函数内部定义函数与之前有所不同，只能定义匿名函数。匿名函数就是没有函数名的函数，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">参数</span>)(<span style="color:#a6e22e">返回值</span>){
    <span style="color:#a6e22e">函数体</span>
}
</code></pre></div><p>匿名函数因为没有函数名，没办法想普通函数一样被调用，所以匿名函数需要保存到某个变量或者立即执行该函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">add</span> <span style="color:#f92672">:=</span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>){<span style="color:#75715e">//将匿名函数保存到变量中
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>)
    }
    <span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>)<span style="color:#75715e">//通过变量调用匿名函数
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">//自执行函数，匿名函数定义完加()直接执行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>){
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>)
    }(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>)
}
</code></pre></div><h4 id="闭包">闭包</h4>
<p>闭包指的是一个函数和其相关的引用环境组合而成的实体。简单点说，<code>闭包 = 函数 + 引用环境</code>。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adder</span>() <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">y</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">adder</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e">//10
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">20</span>)) <span style="color:#75715e">//30
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">30</span>)) <span style="color:#75715e">//60
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">adder</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">40</span>)) <span style="color:#75715e">//40
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">50</span>)) <span style="color:#75715e">//90
</span><span style="color:#75715e"></span>}
</code></pre></div><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中<code>x</code>变量，此时<code>f</code>是一个闭包。在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p>
<h5 id="闭包进阶示例">闭包进阶示例</h5>
<p>{% tabs tab-4 %}</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adder2</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">y</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">adder2</span>(<span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e">//20
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">20</span>)) <span style="color:#75715e">//40
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">30</span>)) <span style="color:#75715e">//70
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">adder2</span>(<span style="color:#ae81ff">20</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">40</span>)) <span style="color:#75715e">//60
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">50</span>)) <span style="color:#75715e">//110
</span><span style="color:#75715e"></span>}

</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">base</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">add</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">base</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">base</span>
	}

	<span style="color:#a6e22e">sub</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">base</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">i</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">base</span>
	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">add</span>, <span style="color:#a6e22e">sub</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">f1</span>, <span style="color:#a6e22e">f2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">2</span>)) <span style="color:#75715e">//11 9
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">3</span>), <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">4</span>)) <span style="color:#75715e">//12 8
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">5</span>), <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">6</span>)) <span style="color:#75715e">//13 7
</span><span style="color:#75715e"></span>}

</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="defer语句">defer语句</h3>
<p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句最先被执行，和C语言中栈的顺序一样</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;start&#34;</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">3</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;end&#34;</span>)
}
</code></pre></div><p>运行结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">start
end
<span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">1</span>
</code></pre></div><p>利用<code>defer</code>语句延迟调用的特性，可以很方便的处理资源释放的问题</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之map</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</link>
      <pubDate>Tue, 16 Mar 2021 18:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</guid>
      <description>Map</description>
      <content:encoded><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p>
<h1 id="map">map</h1>
<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h2 id="map定义">map定义</h2>
<p>Go语言中 <code>map</code>的定义语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">KeyType</span>]<span style="color:#a6e22e">ValueType</span>
</code></pre></div><p>其中，</p>
<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">KeyType</span>]<span style="color:#a6e22e">ValueType</span>, [<span style="color:#a6e22e">cap</span>])
</code></pre></div><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<h2 id="map基本使用">map基本使用</h2>
<p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">8</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">scoreMap</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>])
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of a:%T\n&#34;</span>, <span style="color:#a6e22e">scoreMap</span>)
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">map<span style="color:#f92672">[</span>小明:100 张三:90<span style="color:#f92672">]</span>
<span style="color:#ae81ff">100</span>
type of a:map<span style="color:#f92672">[</span>string<span style="color:#f92672">]</span>int
</code></pre></div><p>map也支持在声明的时候填充元素，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">userInfo</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
		<span style="color:#e6db74">&#34;username&#34;</span>: <span style="color:#e6db74">&#34;沙河小王子&#34;</span>,
		<span style="color:#e6db74">&#34;password&#34;</span>: <span style="color:#e6db74">&#34;123456&#34;</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">userInfo</span>) <span style="color:#75715e">//
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="判断某个键是否存在">判断某个键是否存在</h2>
<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">key</span>]
</code></pre></div><p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#75715e">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>]
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;查无此人&#34;</span>)
	}
}
</code></pre></div><h2 id="map的遍历">map的遍历</h2>
<p>Go语言中使用<code>for range</code>遍历map。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;娜扎&#34;</span>] = <span style="color:#ae81ff">60</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
	}
}
</code></pre></div><p>但我们只想遍历key的时候，可以按下面的写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;娜扎&#34;</span>] = <span style="color:#ae81ff">60</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>)
	}
}
</code></pre></div><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h2 id="使用delete函数删除键值对">使用delete()函数删除键值对</h2>
<p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">delete(<span style="color:#66d9ef">map</span>, <span style="color:#a6e22e">key</span>)
</code></pre></div><p>其中，</p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<p>示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;娜扎&#34;</span>] = <span style="color:#ae81ff">60</span>
	delete(<span style="color:#a6e22e">scoreMap</span>, <span style="color:#e6db74">&#34;小明&#34;</span>)<span style="color:#75715e">//将小明:100从map中删除
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span>{
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
	}
}
</code></pre></div><h2 id="按照指定顺序遍历map">按照指定顺序遍历map</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Seed</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">UnixNano</span>()) <span style="color:#75715e">//初始化随机数种子
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">scoreMap</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">200</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;stu%02d&#34;</span>, <span style="color:#a6e22e">i</span>) <span style="color:#75715e">//生成stu开头的字符串
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Intn</span>(<span style="color:#ae81ff">100</span>)          <span style="color:#75715e">//生成0~99的随机整数
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">scoreMap</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
	}
	<span style="color:#75715e">//取出map中的所有key存入切片keys
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">keys</span> = make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">200</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span> {
		<span style="color:#a6e22e">keys</span> = append(<span style="color:#a6e22e">keys</span>, <span style="color:#a6e22e">key</span>)
	}
	<span style="color:#75715e">//对切片进行排序
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Strings</span>(<span style="color:#a6e22e">keys</span>)
	<span style="color:#75715e">//按照排序后的key遍历map
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">keys</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">scoreMap</span>[<span style="color:#a6e22e">key</span>])
	}
}
</code></pre></div><h2 id="元素为map类型的切片">元素为map类型的切片</h2>
<p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mapSlice</span> = make([]<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">3</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">mapSlice</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;index:%d value:%v\n&#34;</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;after init&#34;</span>)
	<span style="color:#75715e">// 对切片中的map元素进行初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>] = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#34;name&#34;</span>] = <span style="color:#e6db74">&#34;小王子&#34;</span>
	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#34;password&#34;</span>] = <span style="color:#e6db74">&#34;123456&#34;</span>
	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#34;address&#34;</span>] = <span style="color:#e6db74">&#34;沙河&#34;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">mapSlice</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;index:%d value:%v\n&#34;</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><h2 id="值为切片类型的map">值为切片类型的map</h2>
<p>下面的代码演示了map中值为切片类型的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sliceMap</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">3</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sliceMap</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;after init&#34;</span>)
	<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;中国&#34;</span>
	<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sliceMap</span>[<span style="color:#a6e22e">key</span>]
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">value</span> = make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
	}
	<span style="color:#a6e22e">value</span> = append(<span style="color:#a6e22e">value</span>, <span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>)
	<span style="color:#a6e22e">sliceMap</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sliceMap</span>)
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之切片</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</link>
      <pubDate>Tue, 16 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</guid>
      <description>Go切片</description>
      <content:encoded><![CDATA[<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p>
<h2 id="引入">引入</h2>
<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">arraySum</span>(<span style="color:#a6e22e">x</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>{
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">x</span>{
        <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}
</code></pre></div><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</code></pre></div><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了，这样就难受的一批。而切片可以很好的解决这个问题</p>
<h2 id="切片">切片</h2>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<h3 id="切片的定义">切片的定义</h3>
<p>声明切片类型的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> []<span style="color:#a6e22e">T</span>
</code></pre></div><ul>
<li>name:表示变量名</li>
<li>T:表示切片中的元素类型</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// 声明切片类型
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">string</span>              <span style="color:#75715e">//声明一个字符串切片
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> = []<span style="color:#66d9ef">int</span>{}             <span style="color:#75715e">//声明一个整型切片并初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> = []<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>} <span style="color:#75715e">//声明一个布尔切片并初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> = []<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>} <span style="color:#75715e">//声明一个布尔切片并初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)              <span style="color:#75715e">//[]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)              <span style="color:#75715e">//[]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>)              <span style="color:#75715e">//[false true]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)       <span style="color:#75715e">//true
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)       <span style="color:#75715e">//false
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)       <span style="color:#75715e">//false
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="切片的长度和容量">切片的长度和容量</h3>
<p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p>
<h3 id="切片表达式">切片表达式</h3>
<h4 id="简单切片表达式">简单切片表达式</h4>
<p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// s := a[low:high]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s:%v len(s):%v cap(s):%v\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
}
</code></pre></div><p>输入结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">s:<span style="color:#f92672">[</span><span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:4
</code></pre></div><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>:]  <span style="color:#75715e">// 等同于 a[2:len(a)]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// 等同于 a[0:3]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[:]   <span style="color:#75715e">// 等同于 a[0:len(a)]
</span></code></pre></div><p>{% span red, 注意： %}</p>
<p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p>
<p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// s := a[low:high]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s:%v len(s):%v cap(s):%v\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">4</span>]  <span style="color:#75715e">// 索引的上限是cap(s)而不是len(s)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s2:%v len(s2):%v cap(s2):%v\n&#34;</span>, <span style="color:#a6e22e">s2</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>))
}
</code></pre></div><p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">s:<span style="color:#f92672">[</span><span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:4
s2:<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>s2<span style="color:#f92672">)</span>:1 cap<span style="color:#f92672">(</span>s2<span style="color:#f92672">)</span>:1
</code></pre></div><h4 id="完整切片表达式">完整切片表达式</h4>
<p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">low</span> : <span style="color:#a6e22e">high</span> : <span style="color:#a6e22e">max</span>]
</code></pre></div><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">5</span>]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;t:%v len(t):%v cap(t):%v\n&#34;</span>, <span style="color:#a6e22e">t</span>, len(<span style="color:#a6e22e">t</span>), cap(<span style="color:#a6e22e">t</span>))
}
</code></pre></div><p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">t:<span style="color:#f92672">[</span><span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>t<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>t<span style="color:#f92672">)</span>:4
</code></pre></div><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p>
<h3 id="使用make函数构造切片">使用make()函数构造切片</h3>
<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">make<span style="color:#f92672">([]</span>T, size, cap<span style="color:#f92672">)</span>
</code></pre></div><p>其中：</p>
<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)      <span style="color:#75715e">//[0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">a</span>)) <span style="color:#75715e">//2
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(cap(<span style="color:#a6e22e">a</span>)) <span style="color:#75715e">//10
</span><span style="color:#75715e"></span>}
</code></pre></div><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p>
<h3 id="切片的本质">切片的本质</h3>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<ul>
<li>多个切片指向同一数组时，对任一切片进行操作时，都有可能对其他切片造成影响</li>
</ul>
<h3 id="切片不能直接比较">切片不能直接比较</h3>
<p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> []<span style="color:#66d9ef">int</span>         <span style="color:#75715e">//len(s1)=0;cap(s1)=0;s1==nil
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}        <span style="color:#75715e">//len(s2)=0;cap(s2)=0;s2!=nil
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">//len(s3)=0;cap(s3)=0;s3!=nil
</span></code></pre></div><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<h3 id="切片的赋值拷贝">切片的赋值拷贝</h3>
<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">//[0 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s1</span>             <span style="color:#75715e">//将s1直接赋值给s2，s1和s2共用一个底层数组
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>) <span style="color:#75715e">//[100 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s2</span>) <span style="color:#75715e">//[100 0 0]
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="切片遍历">切片遍历</h3>
<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>])
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><h3 id="append方法为切片添加元素">append()方法为切片添加元素</h3>
<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>)        <span style="color:#75715e">// [1]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)  <span style="color:#75715e">// [1 2 3 4]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>}  
	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s2</span><span style="color:#f92672">...</span>)    <span style="color:#75715e">// [1 2 3 4 5 6 7]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>**注意：**通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</code></pre></div><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}  <span style="color:#75715e">// 没有必要初始化
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> = make([]<span style="color:#66d9ef">int</span>)  <span style="color:#75715e">// 没有必要初始化
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</code></pre></div><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">//append()添加元素和切片扩容
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numSlice</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">numSlice</span> = append(<span style="color:#a6e22e">numSlice</span>, <span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v  len:%d  cap:%d  ptr:%p\n&#34;</span>, <span style="color:#a6e22e">numSlice</span>, len(<span style="color:#a6e22e">numSlice</span>), cap(<span style="color:#a6e22e">numSlice</span>), <span style="color:#a6e22e">numSlice</span>)
	}
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>  len:1  cap:1  ptr:0xc0000a8000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> 1<span style="color:#f92672">]</span>  len:2  cap:2  ptr:0xc0000a8040
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> 2<span style="color:#f92672">]</span>  len:3  cap:4  ptr:0xc0000b2020
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span>  len:4  cap:4  ptr:0xc0000b2020
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>  len:5  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> 5<span style="color:#f92672">]</span>  len:6  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> 6<span style="color:#f92672">]</span>  len:7  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> 7<span style="color:#f92672">]</span>  len:8  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> 8<span style="color:#f92672">]</span>  len:9  cap:16  ptr:0xc0000b8000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span>  len:10  cap:16  ptr:0xc0000b8000
</code></pre></div><p>从上面的结果可以看出：</p>
<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>
<p>append()函数还支持一次性追加多个元素。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">citySlice</span> []<span style="color:#66d9ef">string</span>
<span style="color:#75715e">// 追加一个元素
</span><span style="color:#75715e"></span><span style="color:#a6e22e">citySlice</span> = append(<span style="color:#a6e22e">citySlice</span>, <span style="color:#e6db74">&#34;北京&#34;</span>)
<span style="color:#75715e">// 追加多个元素
</span><span style="color:#75715e"></span><span style="color:#a6e22e">citySlice</span> = append(<span style="color:#a6e22e">citySlice</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>)
<span style="color:#75715e">// 追加切片
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>}
<span style="color:#a6e22e">citySlice</span> = append(<span style="color:#a6e22e">citySlice</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">...</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">citySlice</span>) <span style="color:#75715e">//[北京 上海 广州 深圳 成都 重庆]
</span></code></pre></div><h3 id="使用copy函数复制切片">使用copy()函数复制切片</h3>
<p>首先我们来看一个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1000</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1000 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">//[1000 2 3 4 5]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>
<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">copy<span style="color:#f92672">(</span>destSlice, srcSlice <span style="color:#f92672">[]</span>T<span style="color:#f92672">)</span>
</code></pre></div><p>其中：</p>
<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// copy()复制切片
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>)
	copy(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">a</span>)     <span style="color:#75715e">//使用copy()函数将切片a中的元素复制到切片c
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1000</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>) <span style="color:#75715e">//[1000 2 3 4 5]
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="从切片中删除元素">从切片中删除元素</h3>
<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// 从切片中删除元素
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">37</span>}
	<span style="color:#75715e">// 要删除索引为2的元素
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> = append(<span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">3</span>:]<span style="color:#f92672">...</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[30 31 33 34 35 36 37]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之数组</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 15 Mar 2021 18:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</guid>
      <description>Go数组</description>
      <content:encoded><![CDATA[<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p>
<h1 id="array数组">Array(数组)</h1>
<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 定义一个长度为3元素类型为int的数组a
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</code></pre></div><h3 id="数组定义">数组定义：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var 数组变量名 <span style="color:#f92672">[</span>元素数量<span style="color:#f92672">]</span>T
</code></pre></div><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">b</span> <span style="color:#75715e">//不可以这样做，因为此时a和b是不同的类型
</span></code></pre></div><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<h3 id="数组的初始化">数组的初始化</h3>
<p>数组的初始化也有很多方式。</p>
<h4 id="方法一">方法一</h4>
<p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testArray</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>                        <span style="color:#75715e">//数组会初始化为int类型的零值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numArray</span> = [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}                 <span style="color:#75715e">//使用指定的初始值完成初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cityArray</span> = [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>} <span style="color:#75715e">//使用指定的初始值完成初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">testArray</span>)                      <span style="color:#75715e">//[0 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">numArray</span>)                       <span style="color:#75715e">//[1 2 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cityArray</span>)                      <span style="color:#75715e">//[北京 上海 深圳]
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="方法二">方法二</h4>
<p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testArray</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numArray</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cityArray</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">testArray</span>)                          <span style="color:#75715e">//[0 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">numArray</span>)                           <span style="color:#75715e">//[1 2]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of numArray:%T\n&#34;</span>, <span style="color:#a6e22e">numArray</span>)   <span style="color:#75715e">//type of numArray:[2]int
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cityArray</span>)                          <span style="color:#75715e">//[北京 上海 深圳]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of cityArray:%T\n&#34;</span>, <span style="color:#a6e22e">cityArray</span>) <span style="color:#75715e">//type of cityArray:[3]string
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="方法三">方法三</h4>
<p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>: <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)                  <span style="color:#75715e">// [0 1 0 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of a:%T\n&#34;</span>, <span style="color:#a6e22e">a</span>) <span style="color:#75715e">//type of a:[4]int
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="数组的遍历">数组的遍历</h3>
<p>遍历数组a有以下两种方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>}
	<span style="color:#75715e">// 方法1：for循环遍历
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">a</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>])
	}

	<span style="color:#75715e">// 方法2：for range遍历
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><h3 id="多维数组">多维数组</h3>
<p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p>
<h3 id="二维数组的定义">二维数组的定义</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>{
		{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
		{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
		{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[[北京 上海] [广州 深圳] [成都 重庆]]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>]) <span style="color:#75715e">//支持索引取值:重庆
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="二维数组的遍历">二维数组的遍历</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>{
		{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
		{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
		{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v2</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">v1</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s\t&#34;</span>, <span style="color:#a6e22e">v2</span>)
		}
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	}
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">北京	上海	
广州	深圳	
成都	重庆	
</code></pre></div><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//支持的写法
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>{
	{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
	{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
	{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
}
<span style="color:#75715e">//不支持多维数组的内层使用...
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#f92672">...</span>]<span style="color:#66d9ef">string</span>{
	{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
	{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
	{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
}
</code></pre></div><h3 id="数组是值类型">数组是值类型</h3>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">modifyArray</span>(<span style="color:#a6e22e">x</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">modifyArray2</span>(<span style="color:#a6e22e">x</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>}
	<span style="color:#a6e22e">modifyArray</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//在modify中修改的是a的副本x
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[10 20 30]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>{
		{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>},
		{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>},
		{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>},
	}
	<span style="color:#a6e22e">modifyArray2</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">//在modify中修改的是b的副本x
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)  <span style="color:#75715e">//[[1 1] [1 1] [1 1]]
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong>注意：</strong></p>
<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li>
</ol>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之流程控制</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 15 Mar 2021 16:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制</description>
      <content:encoded><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。</p>
<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<h4 id="if-else-分支结构">if else (分支结构)</h4>
<h5 id="if条件判断基本写法">if条件判断基本写法</h5>
<p>Go语言中if条件判断的格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">表达式1</span> {
    <span style="color:#a6e22e">分支1</span>
} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">表达式2</span> {
    <span style="color:#a6e22e">分支2</span>
} <span style="color:#66d9ef">else</span>{
    <span style="color:#a6e22e">分支3</span>
}
</code></pre></div><p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>() {
	<span style="color:#a6e22e">score</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">65</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">90</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;A&#34;</span>)
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">85</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;B&#34;</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;C&#34;</span>)
	}
}
</code></pre></div><h5 id="if条件判断特殊写法">if条件判断特殊写法</h5>
<p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>() {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">65</span>; <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">90</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;A&#34;</span>)
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">85</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;B&#34;</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;C&#34;</span>)
	}
}
</code></pre></div><p><strong>两种写法有什么不同呢？</strong></p>
<h4 id="for-循环结构">for (循环结构)</h4>
<p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p>
<p>for循环的基本格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">初始语句</span>;<span style="color:#a6e22e">条件表达式</span>;<span style="color:#a6e22e">结束语句</span>{
    <span style="color:#a6e22e">循环体语句</span>
}
</code></pre></div><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc1</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}
</code></pre></div><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc2</span>() {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}
</code></pre></div><p>for循环的初始语句和结束语句都可以省略，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc3</span>() {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<p>{% noteblock, 无限循环 %}</p>
<p>{% folding yellow, Folding 点击打开 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> {
    <span style="color:#a6e22e">循环体语句</span>
}
</code></pre></div><p>{% endfolding %}</p>
<p>for循环可以通过break、goto、return、panic语句强制退出循环。</p>
<p>{% endnoteblock %}</p>
<h4 id="for-range键值循环">for range(键值循环)</h4>
<p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h4 id="switch-case">switch case</h4>
<p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">switch1</span>() {
	<span style="color:#a6e22e">finger</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">finger</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;大拇指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;食指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;中指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;无名指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;小拇指&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;无效的输入！&#34;</span>)
	}
}
</code></pre></div><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>
<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Switch2</span>() {
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">7</span>; <span style="color:#a6e22e">n</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;奇数&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;偶数&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span>)
	}
}
</code></pre></div><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">switch3</span>() {
	<span style="color:#a6e22e">age</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">30</span>
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">age</span> &lt; <span style="color:#ae81ff">25</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;好好学习！&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">age</span> &gt; <span style="color:#ae81ff">25</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">age</span> &lt; <span style="color:#ae81ff">35</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;好好工作！&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">age</span> &gt; <span style="color:#ae81ff">60</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;好好享受！&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;长命百岁！&#34;</span>)
	}
}
</code></pre></div><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">switch4</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;a&#34;</span>
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;a&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a&#34;</span>)
		<span style="color:#66d9ef">fallthrough</span>
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;b&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;b&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;c&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;c&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;...&#34;</span>)
	}
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">a
b
</code></pre></div><p>{% note warning, 注意Go与C中switch的区别 %}</p>
<h4 id="goto跳转到指定标签">goto(跳转到指定标签)</h4>
<p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goto1</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">breakFlag</span> <span style="color:#66d9ef">bool</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#75715e">// 设置退出标签
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">breakFlag</span> = <span style="color:#66d9ef">true</span>
				<span style="color:#66d9ef">break</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
		<span style="color:#75715e">// 外层for循环判断
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">breakFlag</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
}
</code></pre></div><p>使用<code>goto</code>语句能简化代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goto2</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#75715e">// 设置退出标签
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">breakTag</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
	}
	<span style="color:#66d9ef">return</span>
	<span style="color:#75715e">// 标签
</span><span style="color:#75715e"></span><span style="color:#a6e22e">breakTag</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;结束for循环&#34;</span>)
}
</code></pre></div><h4 id="break跳出循环">break(跳出循环)</h4>
<p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>
<p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">break1</span>() {
<span style="color:#a6e22e">BREAKDEMO1</span>:
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">BREAKDEMO1</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;...&#34;</span>)
}
</code></pre></div><h4 id="continue继续下次循环">continue(继续下次循环)</h4>
<p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>
<p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">continue1</span>() {
<span style="color:#a6e22e">forloop1</span>:
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#75715e">// forloop2:
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">forloop1</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
	}
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之运算符</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 15 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Go运算符</description>
      <content:encoded><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p>
<p>Go 语言内置的运算符有五类：</p>
<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>
<h4 id="算数运算符">算数运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">相加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">相减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">相乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">相除</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">求余</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
<h4 id="关系运算符">关系运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody>
</table>
<h4 id="逻辑运算符">逻辑运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody>
</table>
<h4 id="位运算符">位运算符</h4>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td style="text-align:center">&laquo;</td>
<td style="text-align:center">左移n位就是乘以2的n次方。 “a&laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td style="text-align:center">&raquo;</td>
<td style="text-align:center">右移n位就是除以2的n次方。 “a&raquo;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody>
</table>
<h4 id="赋值运算符">赋值运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">相加后再赋值</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">相减后再赋值</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">相乘后再赋值</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">相除后再赋值</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">求余后再赋值</td>
</tr>
<tr>
<td style="text-align:center">&laquo;=</td>
<td style="text-align:center">左移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&raquo;=</td>
<td style="text-align:center">右移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&amp;=</td>
<td style="text-align:center">按位与后赋值</td>
</tr>
<tr>
<td style="text-align:center">|=</td>
<td style="text-align:center">按位或后赋值</td>
</tr>
<tr>
<td style="text-align:center">^=</td>
<td style="text-align:center">按位异或后赋值</td>
</tr>
</tbody>
</table>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之基本数据类型</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 14 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型</description>
      <content:encoded><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>
<h3 id="基本数据类型">基本数据类型</h3>
<h4 id="整型">整型</h4>
<p>整数分为以下两个大类：</p>
<p>按长度分为：int8，int16，int64</p>
<p>对应的无符号整型：uint16，uint32，uint64</p>
<p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p>
<h5 id="特殊整型">特殊整型</h5>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uint</td>
<td style="text-align:center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td style="text-align:center">uintptr</td>
<td style="text-align:center">无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<h4 id="浮点型">浮点型</h4>
<p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
        <span style="color:#e6db74">&#34;fmt&#34;</span>
        <span style="color:#e6db74">&#34;math&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%f\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>)
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%.2f\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>)
}
</code></pre></div><h4 id="复数">复数</h4>
<p><code>complex64</code>和<code>complex128</code></p>
<p>具体用法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c1</span> <span style="color:#66d9ef">complex64</span>
<span style="color:#a6e22e">c1</span> = <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2i</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c2</span> <span style="color:#66d9ef">complex128</span>
<span style="color:#a6e22e">c2</span> = <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3i</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c2</span>)
</code></pre></div><h4 id="布尔值">布尔值</h4>
<p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>
<p><strong>注意：</strong></p>
<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<h4 id="字符串">字符串</h4>
<p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;hello&#34;</span>
<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;你好&#34;</span>
</code></pre></div><h5 id="转义字符">转义字符</h5>
<table>
<thead>
<tr>
<th style="text-align:center"><code>\r</code></th>
<th style="text-align:center">回车符（返回行首）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\'</code></td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\&quot;</code></td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">反斜杠</td>
</tr>
</tbody>
</table>
<p>例如，我们要打印Windows平台的文件路径</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;str := \&#34;c:\\Code\\lesson1\\go.exe\&#34;&#34;</span>)
}
</code></pre></div><h5 id="多行字符串">多行字符串</h5>
<p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">`第一行
</span><span style="color:#e6db74">第二行
</span><span style="color:#e6db74">第三行
</span><span style="color:#e6db74">`</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>)
</code></pre></div><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h5 id="字符串的常用操作">字符串的常用操作</h5>
<table>
<thead>
<tr>
<th style="text-align:center">len(str)</th>
<th style="text-align:center">求长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+ 或 fmt.Sprintf</td>
<td style="text-align:center">拼接字符串</td>
</tr>
<tr>
<td style="text-align:center">strings.Split</td>
<td style="text-align:center">分割</td>
</tr>
<tr>
<td style="text-align:center">strings.contains</td>
<td style="text-align:center">判断是否包含</td>
</tr>
<tr>
<td style="text-align:center">strings.HasPrefix,strings.HasSuffix</td>
<td style="text-align:center">前缀/后缀判断</td>
</tr>
<tr>
<td style="text-align:center">strings.Index(),strings.LastIndex()</td>
<td style="text-align:center">子串出现的位置</td>
</tr>
</tbody>
</table>
<h5 id="byte和rune类型">byte和rune类型</h5>
<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（'）包裹起来，如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#39;中&#39;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#39;x&#39;</span>
</code></pre></div><p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
<p>如下，可以知道rune和byte的区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 遍历字符串
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traversalString</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;GO你好&#34;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">//byte
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v(%c) &#34;</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>])
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> { <span style="color:#75715e">//rune
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v(%c) &#34;</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">r</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
}
</code></pre></div><p>这是我们的输出结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">71</span>(<span style="color:#a6e22e">G</span>) <span style="color:#ae81ff">79</span>(<span style="color:#a6e22e">O</span>) <span style="color:#ae81ff">228</span>(<span style="color:#a6e22e">ä</span>) <span style="color:#ae81ff">189</span>(<span style="color:#960050;background-color:#1e0010">½</span>) <span style="color:#ae81ff">160</span>( ) <span style="color:#ae81ff">229</span>(<span style="color:#a6e22e">å</span>) <span style="color:#ae81ff">165</span>(<span style="color:#960050;background-color:#1e0010">¥</span>) <span style="color:#ae81ff">189</span>(<span style="color:#960050;background-color:#1e0010">½</span>) 
<span style="color:#ae81ff">71</span>(<span style="color:#a6e22e">G</span>) <span style="color:#ae81ff">79</span>(<span style="color:#a6e22e">O</span>) <span style="color:#ae81ff">20320</span>(<span style="color:#a6e22e">你</span>) <span style="color:#ae81ff">22909</span>(<span style="color:#a6e22e">好</span>) 
</code></pre></div><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>
<h5 id="修改字符串">修改字符串</h5>
<p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeString</span>() {
	<span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;big&#34;</span>
	<span style="color:#75715e">// 强制类型转换
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">byteS1</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">s1</span>)
	<span style="color:#a6e22e">byteS1</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;p&#39;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">byteS1</span>))

	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;白萝卜&#34;</span>
	<span style="color:#a6e22e">runeS2</span> <span style="color:#f92672">:=</span> []rune(<span style="color:#a6e22e">s2</span>)
	<span style="color:#a6e22e">runeS2</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;红&#39;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">runeS2</span>))
}
</code></pre></div><h4 id="类型转化">类型转化</h4>
<p>强制类型转换的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">T<span style="color:#f92672">(</span>表达式<span style="color:#f92672">)</span>
</code></pre></div><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为<code>float64</code>类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sqrtDemo</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> = <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>
	<span style="color:#75715e">// math.Sqrt()接收的参数是float64类型，需要强制转换
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span> = int(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(float64(<span style="color:#a6e22e">a</span><span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span><span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>)
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之变量与常量</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Sat, 13 Mar 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</guid>
      <description>常量与变量</description>
      <content:encoded><![CDATA[<p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p>
<h3 id="标识符与关键字">标识符与关键字</h3>
<h4 id="标识符">标识符</h4>
<p>关于Go语言中的命名规则，与C类似。Go语言中标识符由字母、数字和<code>_</code>(下划线)组成，并且只能以字母和<code>_</code>开头。
例如<code>aaa</code>,<code>_ </code>,<code>_123</code>,<code>a123</code></p>
<h4 id="关键字">关键字</h4>
<p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。且不能将关键字和保留字作为变量名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//25个关键字
</span><span style="color:#75715e"></span><span style="color:#66d9ef">break</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">func</span> <span style="color:#66d9ef">interface</span> <span style="color:#66d9ef">select</span>
<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">map</span> <span style="color:#66d9ef">struct</span> 
<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">continue</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">goto</span> <span style="color:#f92672">package</span> <span style="color:#66d9ef">range</span> 
<span style="color:#f92672">import</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">var</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//37个保留字
</span><span style="color:#75715e"></span><span style="color:#a6e22e">Constants</span>: <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">false</span> <span style="color:#66d9ef">iota</span> <span style="color:#66d9ef">nil</span>

<span style="color:#a6e22e">Types</span>: <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">int8</span> <span style="color:#66d9ef">int16</span> <span style="color:#66d9ef">int32</span> <span style="color:#66d9ef">int64</span> <span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">uint8</span> <span style="color:#66d9ef">uint16</span> <span style="color:#66d9ef">uint32</span> <span style="color:#66d9ef">uint64</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#66d9ef">float32</span> <span style="color:#66d9ef">float64</span> <span style="color:#66d9ef">complex128</span> <span style="color:#66d9ef">complex64</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">rune</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">error</span> <span style="color:#a6e22e">Functions</span>: <span style="color:#a6e22e">make</span> <span style="color:#a6e22e">len</span> <span style="color:#a6e22e">cap</span> <span style="color:#a6e22e">new</span> <span style="color:#a6e22e">append</span> <span style="color:#a6e22e">copy</span> <span style="color:#a6e22e">close</span> <span style="color:#a6e22e">delete</span> <span style="color:#a6e22e">complex</span> <span style="color:#a6e22e">real</span> <span style="color:#a6e22e">imag</span> <span style="color:#a6e22e">panic</span> <span style="color:#a6e22e">recover</span>
</code></pre></div><h3 id="变量">变量</h3>
<h4 id="变量类型">变量类型</h4>
<p>变量的功能是存储数据，不同类型的变量存储不同类型的数据。</p>
<p>常见变量的数据类型有：整型、浮点型、布尔型等。</p>
<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h4 id="变量声明">变量声明</h4>
<p>Go语言声明变量的格式为:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">变量名</span> <span style="color:#a6e22e">变量类型</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">isOK</span> <span style="color:#66d9ef">bool</span>
</code></pre></div><p>当然，在Go语言中，可以批量声明变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span>(
    <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">bool</span>
    <span style="color:#a6e22e">d</span> <span style="color:#66d9ef">float32</span>
)
</code></pre></div><h4 id="变量初始化">变量初始化</h4>
<p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p>
<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">变量名</span> <span style="color:#a6e22e">类型</span> = <span style="color:#a6e22e">值</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span> = <span style="color:#e6db74">&#34;Q1mi&#34;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">18</span>
</code></pre></div><p>同样，也支持多个变量初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span> = <span style="color:#e6db74">&#34;Q1mi&#34;</span>, <span style="color:#ae81ff">20</span>
</code></pre></div><p>{% note info, 类型推导 %}</p>
<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;Q1mi&#34;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">18</span>
</code></pre></div><p>{% note info, 短变量声明 %}</p>
<p>在函数内部，可以使用更简略的<code>:=</code>方式声明并初始化变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#75715e">// 全局变量m
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">100</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">200</span> <span style="color:#75715e">// 此处声明局部变量m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">n</span>)
}
</code></pre></div><p>{% note info, 匿名变量 %}
在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量</code>。 匿名变量用一个下划线<code>_</code>表示。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;hahaha&#34;</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>()
	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x=&#34;</span>, <span style="color:#a6e22e">x</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;y=&#34;</span>, <span style="color:#a6e22e">y</span>)
}
</code></pre></div><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<p>注意事项：</p>
<ul>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li>:=不能使用在函数外。</li>
<li>_多用于占位，表示忽略值。</li>
</ul>
<h3 id="常量">常量</h3>
<p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>ar</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pi</span> = <span style="color:#ae81ff">3.1415</span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">e</span> = <span style="color:#ae81ff">2.7182</span>
</code></pre></div><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>
<p>多个常量也可以一起声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> (
    <span style="color:#a6e22e">pi</span> = <span style="color:#ae81ff">3.1415</span>
    <span style="color:#a6e22e">e</span> = <span style="color:#ae81ff">2.7182</span>
)
</code></pre></div><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> (
    <span style="color:#a6e22e">n1</span> = <span style="color:#ae81ff">100</span>
    <span style="color:#a6e22e">n2</span>
    <span style="color:#a6e22e">n3</span>
)
</code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
