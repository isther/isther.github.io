[{"content":"结构-\u0026gt;执行-\u0026gt;管理-\u0026gt;用户\n外键约束 概念：foreign key，表中指向外部主键的字段\n 外键必须要通过语法指定才能称之为外键  [constraint 外键名] foreign key (当前表字段名) references 外部表(主键字段)   外键构成条件  外键字段必须与对应表的主键字段类型一致 外键字段本身要求是一个索引（创建外键会自动生成一个索引）    示例   创建专业表和学生表，学生表中的专业id指向专业表id\n# 专业表 CREATE table t1 ( id int primary key AUTO_INCREMENT, name varchar(50) not null unique ) charset utf8; # 学生表 create table t2( id int primary key AUTO_INCREMENT, name varchar(50) not null, c_id int comment \u0026#39;指向专业表t1的主键\u0026#39; constraint `c_id` FOREIGN KEY(c_id) REFERENCES t1(id) ) charset utf8; 外键可以不指定名字，系统会自动生成\n  外键约束  当表建立外键关系后，外键就会对主表和子表里的数据产生约束效果 外键约束的是写操作（默认操作）  新增：子表插入的数据对应的外键必须在主表存在 修改：主表的记录如果在子表存在，那么主表的主键不能修改（其他字段可修改） 删除：主表的记录如果在子表存在，那么主表的主键不能删除   外键约束控制：外键可以定义时控制外键的约束作用  控制类型  on update：父表更新时子表的表现 on delete：父表删除时子表的表现   控制方式  cascade：级联操作，父表操作后自编跟随操作 set null：置空操作，父表操作后，子表关联的外键字段置空 restrict/no action：严格模式，不允许父表操作（默认）      示例   子表不能插入主表不存在的数据\ninsert into t2 values(null,\u0026#39;Tony\u0026#39;,2);# 此时父表中还没有id=2的记录，错误  insert into t1 values(null,\u0026#39;English\u0026#39;); insert into t2 values(null,\u0026#39;Peny\u0026#39;,1);   默认的外键产生后，主键不能更新被关联的主键字段或者删除被关联的主键记录\n# 错误 update t1 set id = 2; delete from t1 where id = 1;   限制外键约束，一般使用更新级联，删除置空\n on update cascade：更新级联 on delete set null：删除置空  create table t3( id int primary key AUTO_INCREMENT, name varchar(50) not null unique )charset utf8; create table t4( id int primary key AUTO_INCREMENT, name varchar(50) not null, c_id int , # 如果允许置空，就不能not null  FOREIGN KEY(c_id) references t3(id) on update cascade on delete set null )charset utf8; insert into t3 values(null,\u0026#39;Chinese\u0026#39;),(null,\u0026#39;Computer\u0026#39;); insert into t4 values(null,\u0026#39;Tony\u0026#39;,1),(null,\u0026#39;Lily\u0026#39;,2);  子表依然不允许插入父表不存在的外键 但是可以插入外键为Null的数据  # 错误 insert into t2 values(null,\u0026#39;Lilei\u0026#39;,3); insert into t2 vlaues(null,\u0026#39;Lilei\u0026#39;,null);  父表的更新（主键）会让关联的外键自动级联更新  update t1 set id = 3 where id = 1;   外键管理   在表创建后期维护外键\n  新增外键\nalter table 表名 add [constraint `外键名`] foreign key(外键字段) references 表名(主键) [on 外键约束]   删除外键\nalter table 表名 drop foreign key 外键名;   更新外键：先删除后新增\n  事务安全 事务：要做的某个事情\n  计算机中的事务是指某个程序执行单元（写操作）\n  事务安全：当事务执行后，保障事务的执行是有效的，而不会导致数据错乱\n  事务安全通常针对的是一连串的操作（多个事务）而产生的统一结果\n  MySQL中默认的写操作是直接写入的\n 执行写操作SQL 同步到数据表    示例 银行转账\ncreate table t1( id int primary key auto_increment, `name` varchar(50) not null, account decimal(10,2) default 0.00 )charset utf8; insert into t1 values(null,\u0026#39;Tom\u0026#39;,10000),(null,\u0026#39;Lucy\u0026#39;,100); # Tom扣钱 update t1 set account = account - 100 where id = 1; # Lucy收钱 update t1 set account = account + 1000;  扣钱，收钱两步都成功转账才叫成功 为了保障两步都成功才能叫事务安全  事务处理  利用手动或者手动方式实现事务管理 自动事务处理：系统默认，操作结束直接同步到数据表（事务关闭状态）  系统控制：变量autocommit（值为ON，自动提交）   手动事务处理  开启事务：start transaction 关闭事务：  提交事务：commit，同步到数据表，同时清空日志数据 回滚事务：rollback 只清空日志数据     事务回滚：在长事务执行中，可以在某个已经成功的节点设置回滚点，后续回滚的可以回到某个成功点  设置回滚点：savepoint 回滚点名字 回滚到回滚点：rollback to 回滚点名字    示例   手动事务：启用事务转账，成功提交事务\n# 开启事务 start transaction; # Tom扣钱 update t1 set account = account - 1000; # Lucy收钱 update t1 set account = account + 1000; # 提交事务 commit;   手动事务：启用事务转账，成功提交事务（回滚点）\n# 开启事务 start transaction; # Tom扣钱 update t1 set account = account - 1000 where id = 1; # 设置回滚点 savepoint spl; # Lucy收钱 update t1 set account = account + 1000 where id = 2; # 操作失败回到回滚点 rollback spl; update t1 set account = account - 1000 where id = 2; # 提交事务 commit;   自动事务\n MySQL默认自动提交事务，事务一旦发生就会立即写入数据表  show variables like \u0026#39;autucommit\u0026#39;;  关闭自动提交事务（当前设置级别用户级：当前用户当此连接有效）  set autocommit = 0;  手动提交事务  insert into t1 values(null,\u0026#39;Liu\u0026#39;,1000); commit;   事务特点  ACID四大特性 原子性(Atomicity)：一个事务操作是一个整体，不可拆分，要么都成功，要么都失败 一致性(Consistency)：事务执行之前和执行之后都必须处于一致性状态，数据的完整性没有被破坏（事务逻辑的准确性） 隔离性(Isolation)：事务操作过程中，其他事务不可见 持久性(Durability)：事务一旦提交，结果不可改变  预处理 预处理：prepare statement，一种预先编译SQL指令的方式\n 预处理不同于直接处理，是将要执行的SQL指令先发送给服务器编译，然后通过指令执行  发送预处理：prepare 预处理名字 from '要执行的SQL指令' 执行预处理：execute 预处理名字   预处理管理  预处理属于会话级别：即当前用户当次连接有效（断开会被服务器清理掉） 删除预处理：deallocate | drop 预处理名字    示例 查询学生的SQL指令需要重复执行很多次\n# 普通操作 select * from t1; # 预处理操作：发送预处理 prepare pl from \u0026#39;select * from t1\u0026#39;; # 预处理操作：执行预处理 execute pl; # 删除预处理 deallocate | drop pl; 预处理传参   在执行预处理的时候传入预处理需要的可变数据\n  一般预处理都不会是固定死的SQL指令，而是具有一些数据可变的执行（条件）\n  可变数据的位置使用占位符?占位\nprepare 预处理名字 from \u0026#39;预处理指令 变化部分使用?代替\u0026#39;     在执行预处理的时候将实际数据传进去代替占位符执行SQL\n  数据存储到变量（预处理传入的值必须是变量保存的）\nset @变量名 = 值   使用using关键字传参\nexecute 预处理名字 using @变量名   数据传入的顺序与预处理中占位符的顺序一致\n    示例 向表中插入数据\n# 准备预处理：涉及参数 prepare t1 insert from \u0026#39;insert into t1 values(null,?,?,?,?)\u0026#39;; # 设置变量并传入参数 set @name = \u0026#39;药师兜\u0026#39;; set @gender = \u0026#39;男\u0026#39;; set @age = 23; set @class_name = \u0026#39;木叶1班\u0026#39;; #执行预处理 execute t1 insert using @name,@gender,@age,@@class_name; 视图 视图：view，一种由select指令组成的虚拟表\n  视图时虚拟表，可以使用表管理（结构管理）\n 为视图提供数据的表叫做基表    # 创建视图 create view 视图名字 as select指令; # 访问视图：一般都是查询 select */字段名 from 视图名字;   视图有结构，但不存储数据\n 结构：select选择的字段 数据：访问视图时执行的select指令    对外部系统提供数据支撑(保护基表数据)\n  示例   需要对外提供一个学生详情的数据，经常使用，可以利用视图实现\n# 对外提供数据，要保护数据本身的安全 # 需要长期使用  # 创建视图 create view v_student_info as select * from t1 left join t2 using(c_id); # 使用视图：像表一样使用 select * from v_student_info;   有些复杂的SQL又是经常用到的，如多张表的连表操作：可以利用视图实现\n# 院系表 create table t1( id int primary key auto_increment, `name` varchar(50) not null )charset utf8; insert into t1 values(null,\u0026#39;语言系\u0026#39;),(null,\u0026#39;考古系\u0026#39;); # 专业表 create table t2( id int primary key auto_increment, `name` varchar(50) not null, s_id int not null comment \u0026#39;学院id\u0026#39; )charset utf8; insert into t2 values(null,\u0026#39;English\u0026#39;,1),(null,\u0026#39;Chinese\u0026#39;,1); # 学生表 create table t3( id int primary key auto_increment, `name` varchar(50) not null, s_id int not null comment \u0026#39;专业id\u0026#39; )charset utf8; insert into t3 values(null,\u0026#39;Lilei\u0026#39;,2),(null,\u0026#39;Hanmeimei\u0026#39;,2),(null,\u0026#39;Tony\u0026#39;,1); # 获取所有学生的明细信息 select stu.*,sub.name as sub_name,sub.s_id as sch_id,sch.name as sch_name from t3 as stu left join t2 sub on stu.s_id = sub.id left join t1 sch on sub.s_id = sch.id; # 以视图保存这类复杂指令，后续可以直接访问视图 create view v_student_detail as select stu.*,sub.name as sub_name,sub.s_id as sch_id,sch.name as sch_name from t3 as stu left join t2 sub on stu.s_id = sub.id left join t1 sch on sub.s_id = sch.id;   视图管理   视图查看：显示视图结构和具体视图信息\nshow tables; #查看全部视图 show create table/view 视图名字; # 查看视图创建指令 desc 视图名字; # 查看视图结构   视图修改：更改视图逻辑\nalter view 视图名 as 新的查询命令; create or replace view 视图名 as 新的查询命令 # 创建新的或者替换新的   删除视图\ndrop view 视图名;   视图的数据操作   视图所有的数据操作都是最终对基表的数据操作\n  视图操作条件\n  多基表视图：不允许操作\n  单基表视图：允许增删改\n 新增条件：视图的字段必须包含基表中所有不允许为空的字段    with check option：操作检查规则\n 默认不需要这个规则（创建视图时指定）：视图操作只要满足前面上述条件即可 增加此规则：视图的数据操作后，必须要保证该视图还能把通过视图操作的数据查出来（否则失败）    示例     增加一个单表视图和多表视图\ncreate view v_student_1 as select s_id,s_name from t1; create view v_student_2 as select s.*,c.c_name from t1 s left join t2 c using(c_id); create or replace view v_student_3 as select * from t1 where c_id is not null with check option;   新增数据\ninsert into v_student_1 values(null,\u0026#39;student7\u0026#39;); # 正确：视图包含所有必有字段 insert into v_student_2 values(null,\u0026#39;student8\u0026#39;,null,null) # 错误：不可插入 insert into v_student_3 values(null,\u0026#39;student8\u0026#39;,null) # 错误：check option，因为第三个字段c_id为null,不符合视图筛选条件，查不出来 insert into v_student_3 valeus(null,\u0026#39;student9\u0026#39;,1) # 正确   更新数据\nupdate v_student_1 set s_name = \u0026#39;boy\u0026#39; where s_id = 8; update v_student_2 set s_name = \u0026#39;boy\u0026#39; where s_id = 7; # 错误：不可修改 update v_student_3 set c_id = null where s_id = 1; # 错误：check option，修改后c_id为null，变得不符合视图筛选条件 update v_student_3 set s_name = \u0026#39;boy\u0026#39; where s_id = 1;   删除数据\ndelete from v_student_1 where s_id = 2; delete from v_student_2 where s_id = 3; # 错误：不可修改 delete from v_student_3 where s_id = 1; # 可以删除，check option不影响删除操作   视图算法   视图在执行过程中对于内部的select指令的处理方式\n  视图算法在创建视图时指定\ncreate ALGORITHM = 算法 view 视图名字 as select指令;   视图算法一共有三种\n undefined：默认的，未定义算法，即系统自动选择算法 merge：合并算法，就是将视图外部查询语句跟视图内部select语句合并执行，效率高（系统优先选择） temptable：临时表算法，即系统将视图的select语句查出来先得出一张临时表，然后外部再查询（temptable算法视图不允许写操作）    数据备份与还原 表数据备份  单独针对表里的数据部分进行备份（数据导出） 将数据从表中查出，按照一定格式存储到外部文件  字段格式化：fields  terminated by：字段数据结束后使用的符号，默认是空格 enclosed by：字段数据包裹，默认什么都没有 escaped by：特殊字符的处理，默认是转义   行格式化：lines  terminated by：行结束符号，默认是\\n，自动换行 starting by：行开始符号，默认没有      select 字段列表|* into outfile \u0026#39;外部文件路径\u0026#39; [fields terminated by 格式 enclosed by 格式] [lines terminated by 格式 starting by 格式] from 数据表;  表数据备份不限定数据的来源是一张表还是多张表（可以连表）  表数据还原  将符合数据结构的数据导入到数据表中（数据导入） 将一定格式的数据按照一定的解析方式解析成符合表字段格式的数据导入到数据表  字段处理 行处理    load data infile \u0026#39;数据文件所在路径\u0026#39; into table 表名 [fields terminated by 格式 enclosed by 格式] [lines terminated by 格式 starting by 格式] [(字段列表)];  数据文件来源  表数据备份的数据文件 外部获取或者制作的符合格式的数据    文件备份  直接对数据表进行文件保留，属于物理备份 文件备份操作简单，直接将数据表（或者数据库文件夹）进行保存迁移 MySQL中不同表存储引擎产生的文件不一致，保存手段也不一致  InnoDB：表结构文件再ibd文件夹中，数据和索引存储在外部统一的ibdata文件夹中 MyIsam：每张表的数据、结构和索引都是独立文件，直接找到三个文件迁移即可    文件还原  利用备份的文件，替换出现问题的文件，还原到备份前的良好状态 直接将备份文件放到相应位置即可 文件还原影响  InnoDB：单表结构，整库数据，知识和整库备份还原，否则会影响其他InnoDB存储表 MyIsam：单表备份，单表还原，不影响其他任何数据    ​\n","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/","summary":"\u003cp\u003e结构-\u0026gt;执行-\u0026gt;管理-\u0026gt;用户\u003c/p\u003e\n\u003ch3 id=\"外键约束\"\u003e外键约束\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e概念\u003c/strong\u003e：\u003ccode\u003eforeign key\u003c/code\u003e，表中\u003cstrong\u003e指向外部主键\u003c/strong\u003e的字段\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e外键必须要通过语法指定才能称之为外键\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e[constraint 外键名] foreign key (当前表字段名) references 外部表(主键字段)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e外键构成条件\n\u003cul\u003e\n\u003cli\u003e外键字段必须与对应表的主键字段类型一致\u003c/li\u003e\n\u003cli\u003e外键字段本身要求是一个索引（创建外键会自动生成一个索引）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"MySQL安全管理"},{"content":"多表：因为单表会出现数据冗余，所以采用多表的方式\n联合查询 联合查询   union，是指将多个查询结果合并成一个结果显示\n  联合查询是针对查询结果的合并（多条select语句合并）\n  联合查询语法\nselect 查询 # 决定字段表 \tunion 查询选项 select 查询 ...   联合查询要求：联合查询是结果联合显示\n 多个联合查询的字段结果数量一致 联合查询的字段来源于第一个查询语句的字段    查询选项：与select选项一样\n all：保留所有记录 distinct：保留去重记录（默认）    示例   创建一个表，并插入数据\ncreate table t2 like t1; insert into t2 values(null, \u0026#39;犬夜叉\u0026#39;, \u0026#39;男\u0026#39;, 200, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;日暮戈薇\u0026#39;, \u0026#39;女\u0026#39;, 16, \u0026#39;现代1班\u0026#39;), (null, \u0026#39;桔梗\u0026#39;, \u0026#39;女\u0026#39;, 88, \u0026#39;法师1班\u0026#39;), (null, \u0026#39;弥勒\u0026#39;, \u0026#39;男\u0026#39;, 28, \u0026#39;法师2班\u0026#39;), (null, \u0026#39;珊瑚\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;法师2班\u0026#39;), (null, \u0026#39;七宝\u0026#39;, \u0026#39;保密\u0026#39;, 5, \u0026#39;宠物1班\u0026#39;), (null, \u0026#39;杀生丸\u0026#39;, \u0026#39;男\u0026#39;, 220, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;铃\u0026#39;, \u0026#39;女\u0026#39;, 4, \u0026#39;现代1班\u0026#39;), (null, \u0026#39;钢牙\u0026#39;, \u0026#39;男\u0026#39;, 68, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;奈落\u0026#39;, \u0026#39;男\u0026#39;, 255, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;神乐\u0026#39;, \u0026#39;女\u0026#39;, 15, \u0026#39;神妖2班\u0026#39;);  t1与t2结构一致，可以理解为因为数据量较大，拆分到两个表中\r   使用联合查询两张表的数据拼接到一起显示\nselect * from t1 union select * form t2;   联合查询选项默认是distinct\nselect * from t1 union select * from t2; select * from t1 union all select * from t2;   联合查询不要求字段类型一致，只对数量要求一致，而且字段名称与第一条查询语句相关\nselect name from t1 union select age from t2; 如果数据不能与字段对应，那么查询没有意义\n  联合查询排序  针对联合查询的结果进行排序 order by本身是对内存结果进行排序，union的优先级高于order by，所以order by默认是对union结果进行排序 如果想对单独select的结果进行排序，需要两个步骤  将需要排序的select指令进行括号包裹（括号使用order by） order by必须配合limit才能生效（limit一个足够大的数值即可）    示例   将t1和t2表的结果使用年龄降序排序\nselect * from t1 union all select * from t2 order by age desc;   t1表按年龄降序排序，t2表按年龄升序排序\n# 无效方式 (select * from t1 order by age desc) union (select * from t1 order by age asc); # 有效方式 (select * from t1 order by age desc limit 9999) union (select * from t2 order by age asc limit 9999);   连接查询 交叉连接  cross join，不需要任何条件的连接 交叉连接产生的效果就是笛卡尔积  左表的每一条记录都会与右表的所有记录连接并保存   交叉连接没有实际数据价值，只是丰富了连接查询的完整性  示例 # 交叉连接t1和t2表 select * from t1 cross join t2; 内连接  [inner] join，将两张表根据指定的条件连接起来，严格连接 内连接是将一张表的每一个记录去另外一张表根据条件匹配  匹配成功：保留连接的数据 匹配失败：都不保留   内连接语法：左表 join 右表 on 连接条件  示例   设计学生表和专业表：学生对专业多对一关系\n# 学生表 create table t1( id int primary key auto_increment, name varchar(50) not null, course_no int )charset utf8; insert into t1 values(null,\u0026#39;student1\u0026#39;,1), (null,\u0026#39;student2\u0026#39;,1), (null,\u0026#39;student3\u0026#39;,2), (null,\u0026#39;student4\u0026#39;,3), (null,\u0026#39;student5\u0026#39;,1), (null,\u0026#39;student6\u0026#39;,default); # 专业表 create table t2( id int primary key auto_increment, name varchar(50) not null unique )charset utf8; insert into t2 values(null,\u0026#39;Computer\u0026#39;),(null,\u0026#39;Software\u0026#39;),(null,\u0026#39;Network\u0026#39;);   获取已经选择了专业的学生信息，包括所选专业\n# 学生和专业在两个表中，所以需要连表 # 学生必须有专业，而专业也必须存在，所以是内连接 # 连接条件：专业编号 # 两张表有两个字段冲突：id,name,所以需要使用别名 select t1.*,t2.name as course_name from t1 inner join t2 on t1.course_no = t2.id; # 表名的使用也可以使用别名 select s.*,c.name as c_name from t1 as s inner join t2 c on s.course_no = c.id;   外连接  outer join，是一种不严格的连接方式 外连接分为两种  左连接：left join 右连接：right join   外连接有主表和从表之分  左连接：左表为主表 右连接：右表为主表   外连接是将主表的记录去匹配从表的记录  匹配成功保留 全表匹配失败：也保留，只是从表字段置空    示例   查出学生所有信息，包括所在班级（左连接）\n# 主要数据是学生，而且是全部学生：外连接、且学生表为主表 select s.*,c.name c_name from t1 s left join t2 c on s.course_no = c.id;   查出所有班级里的所有学生\n#主表是班级 select s.*,c.name c_name from t1 s right join t2 c on s.course_no = c.id;   自然连接  natural join，是一种自动寻找连接条件的连接查询 自然连接不是一种特殊的连接方式，而是自动匹配条件的连接 自然连接包含  自然内连接：natural join 自然外连接：natural left/right join   自然连接条件匹配模式：自动寻找相同字段名作为连接条件  示例   自然连接t1和t2表\nselect * from t1 natural join t2;   自然连接是不管字段是否有关系，只管名字是否相同，如果想要自然连接成功，那么字段的设计就必须非常规范\ncreate table t11( s_id int primary key auto_increment, s_name varchar(50) not null, c_id int comment \u0026#39;课程id\u0026#39; )charset utf8; insert into t11 select * from t1; create table t22( c_id int primary key auto_increment, c_name varchar(50) not null unique )charset utf8; insert into t22 select * from t2; # 自然连接 成功 select * from t11 natural join t22;   using 关键字  连接查询时，如果是同名字段作为连接条件，using可以代替on出现，且比on更好  using是针对同名字段（using(id) === A.id = B.id） using关键字使用后会自动合并对应字段为一个 using可以同时使用多个字段作为条件    示例 查询t11中所有学生信息，包括所在班级名字\nselect s.*,c.c_name from t11 s left join t22 c using(c_id); select * from t11 s left join t22 c using(c_id); 子查询 子查询分类  根据子查询出现的位置或者产生的数据效果分类  位置分类  from子查询：子查询出现在from后做数据源 where子查询：子查询出现在where后做数据条件   按子查询得到的结果分类  标量子查询：子查询返回的结果是一行一列（一个数据） 列子查询：子查询返回的结果是一列多行（一列数据） 行子查询：子查询返回的结果是一行多列（一行数据） 表子查询：子查询返回的结果是一个二维表 exists子查询：子查询返回的结果是布尔结果（验证型）     子查询都需要使用括号()包裹，必要时需要对子查询结果进行别名处理（from子查询）  标量子查询  通常是用来做其他查询的条件  示例 获取computer专业的所有学生\n# 数据目标：学生表t11 # 条件：专业名字，不在t11中  select * from t11 where c_id = (select c_id from t_22 where c_name = \u0026#39;Computer\u0026#39;); 列子查询  通常是用来做查询条件的  示例 获取所有有学生的班级信息\n# 数据获取目标是班级信息 # 数据获取条件是在学生表中的班级id，是多个  select * from t22 where c_id in (select c_id from t11); 行子查询  子查询返回的结果是一行多列 行子查询需要条件中构造元素  (元素1),(元素2),...(元素N)   行子查询通常也是用来作为主查询的条件  示例 获取学生表中性别和年龄都和弥勒相同的学生信息\n# 查询条件有多个：性别和年龄 # 数据的条件的来源在另一张表中  # 解决思路：两个标量子查询 select * from t1 where gender = (select gender from t2 where name = \u0026#39;弥勒\u0026#39;) and age = (select from t2 where name = \u0026#39;弥勒\u0026#39;);  以上查询方式使用了两次子查询，效率降低  # 构造条件行元素(gender,age) select * from t1 where (gender,age) = (select gender,age from t2 where name = \u0026#39;弥勒\u0026#39;); 表子查询  表子查询多出现在from之后，当作数据源 表子查询通常是为了想对数据进行一次加工处理，然后再交给外部进行二次加工处理  示例 获取学生表中每个班级里年龄最大的学生信息，然后按年龄降序排序显示\n# 尝试直接解决 select any_value(name),max(age) m_age, clas_name from t1 group by class_name order by m_age desc;  分组统计中any_value()取的是分组后的第一条数据，而需要的是最大  # 解决方案：要入在分组之前将所有班级里的学生本身是降序排序，那么分组的第一条数据就是满足条件的数据，但是问题是order by必须出现在group by之后 select any_value(name),max(age),class_name from (select name,age,class_name from t1 order by age desc) as t group by class_name;  依然无效，原因是MySQL7之后若要子查询中``order by生效，需要像联合查询一样，加上limit`  select any_value(name),max(age),class_name from (select name,age,class_name from t1 order by age desc limit 99999) as t group by class_name; exists子查询  exists子查询通常是作为where条件使用  where exists(子查询)    示例 获取所有学生的班级信息\n# 获取的数据是班级表t22 # 班级是否有学生需要在t11中确认，并不需要t11提供任何数据显示 select * from t22 c where exists(select c_id from t11 where c.c_id = c_id); 比较方式  特定的比较方式都是基于比较符号一起使用的 all：满足后面全部条件  \u0026gt;all(结果集)：数据要大于结果集中的全部数据   any：满足任何条件  =any(结果集)：数据只要与结果集中的任何一个元素相等   some：满足任意条件(与any完全一样) 结果集：可以是直接的数据也可以是子查询的结果（通常是列子查询）  示例 找出t1表中与t2表中年龄相同的信息\n# 数据获取在t1表 # 数据条件在t2表  # 解决方案1：使用in列子查询 select * from t1 where age in (select distinct age from t2); # 解决方案2：使用exists子查询 select * from t1 where exists(select id from t2 where t1.age = age); # 解决方案3：使用any或者some匹配（列子查询） select * from t1 where age = some(select age from t2); ","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","summary":"\u003cp\u003e\u003cstrong\u003e多表\u003c/strong\u003e：因为单表会出现数据冗余，所以采用多表的方式\u003c/p\u003e","title":"MySQL多表操作"},{"content":"常见的SQL高级操作，主要集中在数据操作（增删改查），基于基础操作之上实现一些复杂业务的数据操作\n数据新增 主要是在新增数据时的高级操作技巧，提升数据插入的效率问题、安全问题。\n批量插入   批量插入分两种\n  全字段批量插入\ninsert into 表名 values(值列表1),(值列表2)...(值列表n);   部分字段批量插入\ninsert into 表名 (字段列表) values(值列表1),(值列表2)...(值列表n);     示例   批量插入学生成绩(全字段)\ninsert into t1 values(null,\u0026#39;Tom\u0026#39;,\u0026#39;Computer\u0026#39;,\u0026#39;90\u0026#39;),(null,\u0026#39;Lily\u0026#39;,\u0026#39;Computer\u0026#39;,\u0026#39;100\u0026#39;);   批量插入学生考试信息(不含成绩)\ninsert into t1 (stu_name,course) values(\u0026#39;Tony\u0026#39;,\u0026#39;English\u0026#39;),(\u0026#39;Ray\u0026#39;,\u0026#39;Math\u0026#39;);   蠕虫复制   从已有的表中复制数据直接插入到另外一张表\n  目的是快速增加表中的数据\n 实现表中数据复制（用于数据备份和迁移） 实现数据的指数级递增（多用于测试）    蠕虫复制语法\ninsert into 表名 [(字段列表)] select 字段列表 from 表名;   注意事项\n 字段列表必须对应 字段类型必须匹配 数据冲突需要事先考虑    示例   创建一张新表，将t1表中的数据迁移到新表中\ncreate table t2( id int primary key auto_increment, stu_name varchar(20) not null, course varchar(20) not null, score decimal(5,2) )charset utf8; insert into t2 select * from t1;   快速让t1表中的数据达到超过100条（重复执行）\ninsert into t2 (stu_name,course,score) select stu_name,course,score from t1; #   主键冲突   在数据进行插入时包含主键指定，而主键在数据表已经存在\n  主键冲突的业务通常是发生在业务主键上（业务主键本身有业务意义）\n  主键冲突的解决方案\n  忽略冲突：保留原始记录\ninsert ignore into 表名 [(字段列表)] values(值列表); # 产生主键冲突后，保留原始记录，插入数据无效   冲突更新：冲突后部分字段变成更新后的值\ninsert into 表名 [(字段列表)] values(值列表) on duplicate key update 字段 = 新值[,字段=新值...]; # 1.尝试新增 # 2.失败，更新   冲突替换：先删除原有记录，后新增记录\nreplace into 表名 [(字段列表)] values(值列表); #效率没有insert高（需要检查是否冲突）     示例   用户名作为主键的用户注册（冲突不能覆盖）：username，password，regtime\ncreate table t1( `username` varchar(50) primary key, `password` char(32) not null, regtime int unsigned not null )charset utf8; insert into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,1234546789); #冲突忽略，且数据不插入 insert ignore into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,123456789);   用户名作为主键的记录用户使用信息（不存在新增，存在则更新时间）：username，logintime\ncreate table t1( `username` varchar(50) primary key, logintime int unsigned )charset utf8; insert into t1 values(\u0026#39;username\u0026#39;,12345678); #冲突更新（替换部分字段数据） insert into t1 values(\u0026#39;username\u0026#39;,12345678) on duplicate key update logintime = unix_timestamp();  如果主键不冲突：新增 如果主键冲突：更新指定字段 上述方式适用于字段较多，但是可能冲突时数据变化的字段较少    用户名作为主键，记录用户登录信息（不存在新增、存在则更新全部）：username、login time、clientinfo\ncreate table t1( `username` varchar(50) primary key, logintime int unsigned, clientinfo varchar(255) not null )charset utf8; replace into t1 values(\u0026#39;username\u0026#39;,unix_timestamp(),\u0026#39;{PC:chrome}\u0026#39;); replace into t1 values(\u0026#39;username\u0026#39;,unix_timestamp(),\u0026#39;{phone:uc}\u0026#39;);  replace遇到主键重复就会先删除、后新增    数据查询 查询选项  用于对查询结果进行简单数据筛选 查询选项时在select关键字之后，有两个互斥值  all：默认，表示保留所有记录 distinct：去重，重复的记录（所有字段都重复）    示例 查看商品表中所有品类的商品信息，重复商品只保留一次（名字、价格、属性都一致）\ncreate table t1( id int primary key auto_increment, goods_name varchar(50) not null, goods_price decimal(10,2) default 0.00, goods_color varchar(20), goods_weight int unsigned comment \u0026#39;重量，单位克\u0026#39; )charset utf8; insert into t1 values(null,\u0026#39;mate10\u0026#39;,5499.00,\u0026#39;blue\u0026#39;,320), (null,\u0026#39;mate10\u0026#39;,5499.00,\u0026#39;gray\u0026#39;,320), (null,\u0026#39;nokia3301\u0026#39;,1299,\u0026#39;black\u0026#39;,420); # 考虑所有字段的去重（不含逻辑主键） select distinct goods_name,goods_price,goods_color,goods_weight from t1; # 不考虑颜色去重 select distinct goods_name,goods_price,goods_weight from t1; 字段选择\u0026amp;别名  字段选择：根据实际需求选择的要获取数据的字段信息 根据实际需求，明确所需要的字段名字，使用英文逗号，分隔 获取所有字段，使用星号*通配所有字段 字段数据可以不一定是来自数据源（select只要有结果即可）  数据常量：select 1 函数或变量：select unix_timestamp(),@@version(@@是系统变量的前缀，后跟变量名)   字段别名：给字段取的临时名字 字段别名使用as语法实现  字段名 as 别名 字段名 别名   字段别名的目的通常为了保护数据  字段冲突：多张表同时操作有同名字段（系统默认覆盖），想保留全部 数据安全：对外提供数据不使用真实字段名字    示例   查询商品信息\n# 全部查询 select * from t1; # 需求为商品名字和商品 select goods_name,goods_price from t1; # 别名使用 select goods_name as gn,goods_price as gp from t1;   不需要数据源的数据获取：select的表达式本身能算出结果\n# 获取当前时间戳和版本号 select unix_timestamp() as now,@@version as version,@@version;   数据源  数据来源 from之后 单表数据源：数据源就是一张表 from 表名 多表数据源：数据来源是多张表（逗号分隔） from 表名1,表名2,... 子查询数据源：数据来源是一个查询结果from (select 字段列表 from 表名) as 别名  数据源要求必须是一个表 如果是查询结果必须给其一个表别名   数据表也可以指定别名  表名 as 别名 表名 别名    示例   单表数据源：最简单的数据源，直接从一个数据表获取\nselect * from t1;   多表数据源：\nselect * from t1,t2; # 利用一张表的一条数据匹配另外一张表的所有记录 # 记录数=表1记录数*表2记录数 # 字段数=表1字段数+表2字段数   子查询数据源：数据来源是一个select对应的查询结果\n 查询语句需要使用括号 查询结果需要指定别名  select * from (select * from t1,t2) t;   如果有时候名字较长或使用不方便，可以利用表别名\nselect * from table1 as t1; select t1.*,t2.stu_name from table1 as t1 table2 as t2;   where子句  跟在from数据源之后，对数据进行条件匹配 where是在磁盘读取后，进入内存之前进行筛选  不符合条件的数据不会进入内存   where筛选的内容因为还没进入内存，所以数据是没有被加工过的  字段别名不能在where中使用    示例   查询t1表中学生名字为Lily的成绩信息\nselect * from t1 where stu_name = \u0026#39;Lily\u0026#39;;   因为where是在磁盘取数据时进行条件筛选，此时数据没有进入内存，所以字段别名是无效的\n# 错误 select stu_name sn,score from t1 where name = \u0026#39;Lily\u0026#39;;   运算符  比较运算符  \u0026gt;、\u0026lt;、=（即是赋值又是等于）、\u0026gt;=、\u0026lt;=、\u0026lt;\u0026gt;(不等于) between A and B ：A和B之间，包括A和B本身，数值比较 in (数据1,数据2,...数据N)：在列举的数据之中 like 'pattern'：上面这样的，用于字符串比较  _：单下划线，匹配对应位置的一个任意字符 %：匹配当前位置往后任意数量任意字符     逻辑运算符  and(逻辑与)、or(逻辑或)、not(逻辑非)   null运算符  is null(为空)、is not null(不为空)    示例   查询成绩不及格的所有学生信息\nselect * from t1 where score \u0026lt; 60;   查询成绩在60-90之间的学生信息\nselect * from t1 where between 60 ans 90; select * from t1 where score \u0026gt;= 60 and score \u0026lt;=90;   查询没有成绩的学生\nselect * from t1 where score is null;   group by 子句  分组统计，根据某个字段所有的结果分类，并进行数据统计分析 分组的目的不是为了显示数据，一定是为了统计数据 group by子句一定是出现在where字句之后（如果同时存在） 分组统计可以进行统计细分：先分大组，然后大组分小组 分组统计需要使用统计函数  group_concat()：将组里的某个字段全部保留 any_value()：不属于分组字段的任意一个组里的值 count()：求对应分组的记录数量  count(字段名)：统计某个字段值的数量（NULL不统计） count(*)：统计整个记录的数量（较多）   sum()：求对应分组中某个字段的和 max()/min()：求对应分组中某个字段的最大/最小值 avg()：求对应分组中某个字段的平均值    示例   创建一张表，存储学生信息\ncreate table t1( id int primary key auto_increment, `name` varchar(10) not null, `gender` enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;保密\u0026#39;), age tinyint unsigned not null, class_name varchar(10) not null comment \u0026#39;班级名称\u0026#39; )charset utf8; insert into t1 values(null,\u0026#39;鸣人\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;佐助\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;小樱\u0026#39;,\u0026#39;女\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;佐井\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;大蛇丸\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;木叶0班\u0026#39;), (null,\u0026#39;卡卡西\u0026#39;,\u0026#39;男\u0026#39;,29,\u0026#39;木叶2班\u0026#39;), (null,\u0026#39;雏田\u0026#39;,\u0026#39;女\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;我爱罗\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;向日葵\u0026#39;,\u0026#39;女\u0026#39;,8,\u0026#39;木叶10班\u0026#39;), (null,\u0026#39;博人\u0026#39;,\u0026#39;男\u0026#39;,8,\u0026#39;木叶10班\u0026#39;), (null,\u0026#39;鼬\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;木叶0班\u0026#39;), (null,\u0026#39;带土\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;木叶2班\u0026#39;), (null,\u0026#39;琳\u0026#39;,\u0026#39;女\u0026#39;,27,\u0026#39;木叶2班\u0026#39;)；   统计每个班的人数\nSELECT COUNT(*),class_name from t1 group by class_name;   多分组：统计每个班的男女学生数量\nSELECT COUNT(*),class_name,gender from t1 group by class_name,gender;   统计每个班里的人数，并记录班级学生的名字\nSELECT COUNT(*),group_concat(`name`) from t1 group by class_name;   回溯统计  在进行分组时（通常是多分组），每一次结果的回溯都进行一次汇总统计 回溯统计语法：在统计之后使用with rollup  示例 统计每个班的男女同学数量，同时要知道班级人数总数\n# 只统计每个班的男女同学数量，没有班级汇总 SELECT COUNT(*),class_name,gender,group_concat(`name`) from t1 group by class_name,gender; # 汇总统计：回溯 SELECT count(*),class_name,gender,group_concat(`name`) from t1 group by class_name,gender with rollup; 分组排序  在分组后统计结果，根据分组字段进行升序或者降序显示数据 默认系统自动升序排序 可以设定分组结果的排序方式  group by 字段名 [ASC]：升序 group by 字段名 DESC：降序    示例 SELECT COUNT(*),class_name,gender,group_concat(`name`),any_value(`name`) from t1 group by class_name,gender desc; having子句  类似于where子句，是用来进行条件筛选数据的 having子句本身是针对分组统计结果进行条件筛选的 having子句必须出现在group by子句之后（如果同时存在） having针对的数据是在内存里已经加载的数据 having几乎能做where能做的所有事，但是where却不一定  字段别名（where针对磁盘数据，在处理时还没有别名） 统计结果（where在group by之前） 分组统计函数（having通常是针对group by存在的）    示例   获取班级人数小于3的班级\nSELECT COUNT(*) as `count`,class_name,group_concat(`name`) from t1 group by class_name having count \u0026lt; 3; SELECT COUNT(*) as `count` ,class_name,group_concat(`name`) from t1 group by class_name having COUNT(*) \u0026lt; 3; # 多用了一次函数（效率降低）  SELECT class_name,group_concat(`name`) from t1 group by class_name having COUNT(*) \u0026lt; 3;   order by子句  排序，根据某个指定的字段进行升序或者降序 排序的参照物是校对集 order by子句在having子句字后（如果同时存在） 排序分为升序和降序：默认升序  order by 字段 [ASC]：升序 order by 字段 DESC：降序   多字段排序：在根据某个字段排序好之后，可以再细分  示例   单字段：按照年龄升序\nselect * from t1 order by age; select * from t1 order by age asc;   多字段：先性别降序，后年龄升序\nselect * from t1 order by gender desc, age; select * from t1 order by gender desc, age asc;   limit子句  限制数据的获取数量 limit子句必须在order by子句之后（如果同时存在） limit限制数量方式有两种  limit 数量 limit 起始位置,数量    示例   获取表中前3条\nselect * from t1 limit 3;   获取表中第三条开始之后的3条数据\nselect * from t1 limit 3,3;   数据更新 限制更新  更新时对更新的记录数进行限制 限制更新通过limit实现 其实是局部更新的一种手段，一般更多情况下依据条件精确更新  示例 对会员选3个发送10元红包\nCREATE table t1( id int primary key auto_increment, `username` varchar(50) not null unique, `password` char(12) not null, account decimal(10,2) default 0.00 )charset utf8; INSERT INTO t1 VALUES(null,\u0026#39;username1\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username2\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username3\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username4\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username5\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username6\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username7\u0026#39;,\u0026#39;password\u0026#39;,default); UPDATE t1 set account = account + 10 LIMIT 3; SELECT * from t1; 数据删除 限制删除  限制要删除的记录数 使用limit限制 一般很少使用，通常使用where条件精确删除  示例 删除没有账户余额的一个用户\ndelete from t1 where account = 0 limit 1; 清空数据  将表中的数据清楚，表的所有状态回到原始状态 本质是先删除，后创建 清空后可以使表的一些变化状态回到原始状态，例如自增长回归初值 清空语法：truncate 表名  示例 清空用户数据表\ntruncate t1; ","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E9%AB%98%E7%BA%A7sql%E6%93%8D%E4%BD%9C/","summary":"\u003cp\u003e常见的SQL高级操作，主要集中在数据操作（增删改查），基于基础操作之上实现一些复杂业务的数据操作\u003c/p\u003e","title":"MySQL高级SQL操作"},{"content":"关系型数据库设计范式  Normal Format，符合某一种级别的关系模式的集合，表示一个关系内部各个属性之间的联系的合理化程度 范式是离散数学的概念 范式目标是在满足组织和存储的前提下使数据结构冗余最小化 范式级别越高，表的级别就越标准 目前数据库应用的范式有以下几层  第一范式：1NF 第二范式：2NF 第三范式：3NF 逆规范化    示例  员工表    工号 姓名 部门 入职时间     0001 张三 人事部 2021-07-26   0002 李四 运营部 2021-07-26      每个员工都与部门挂钩，但是部门不可能有很多，所以上述表中会有很多数据重复，此时应该将部门单独维护出来，减少数据冗余。\n   部门编号 部门名称     1 人事部   2 运营部       工号 姓名 部门 入职时间     0001 张三 1 2021-07-26   0002 李四 2 2021-07-26     范式一共有6层，但是数据库的设计通常只要求满足3层即可。\n 第一范式1NF  1NF，数据字段设计时必须满足原子性 1NF要求字段数据是不需要拆分就可以直接使用 如果数据使用的时候需要进行拆分那么就违背1NF   步骤\n 设计的字段是否在使用的时候还需要再拆分 将数据拆分到最小单位，设计字段 满足1NF   示例    姓名 性别 课程 教室 成绩 学习时间     张三 男 C++ 101 100 2月1日-2月15日   李四 女 C 102 100 2月1日-2月15日   王五 男 JAVA 103 100 2月1日-2月15日    当前表的学习时间在使用的时候肯定是基于开始时间和结束时间的，而这种设计会存在使用时的数据拆分，不满足原子性，同时也不满足1NF。\n   姓名 性别 课程 教室 成绩 开始时间 结束时间     张三 男 C++ 101 100 2月1日 2月15日   李四 女 C 102 100 2月1日 2月15日   王五 男 JAVA 103 100 2月1日 2月15日    第二范式2NF  2NF，字段设计不能存在部分依赖 部份依赖：首先表存在复合主键，其次有的字段不是依赖整个主键，而只是依赖主键中的一部分 部份依赖解决：让所有非主属性都依赖一个候选关键字  最简单方式：取消复合主键（一般选用逻辑主键替代，但是本质依然是复合主键做主），所有非主属性都依赖主属性（逻辑主键） 正确方式：将部分依赖关系独立成表    示例 学生成绩中学生和课程应该是决定性关系，因此属于主属性（主键）\n   姓名(P) 性别 课程(P) 教室 成绩 开始时间 结束时间     张三 男 C++ 101 100 2月1日 2月15日   李四 女 C 102 100 2月1日 2月15日   王五 男 JAVA 103 100 2月1日 2月15日     成绩是由学生和课程决定的，是完全依赖主属性 性别只依赖学生（部份依赖） 教室、开始时间和结束时间依赖课程（部份依赖）  解决方案：将学生信息维护到一张表，课程信息维护到一张表，成绩表取两个表的主属性即可\n学生表\n   Stu_id(P) 姓名 性别     1 张三 男   2 李四 女   3 王五 男     Stu_id是姓名的代指属性（逻辑主键，本质主键是姓名） 性别只依赖主属性  课程表\n   Class_id(P) 课程 教室 开始时间 结束时间     1 C++ 101 2月1日 2月15日   2 C 102 2月1日 2月15日   3 JAVA 103 2月1日 2月15日     Class_id是课程的代指属性（逻辑主键） 教室、开始时间和结束时间都依赖课程  成绩表\n   Stu_id(P) Class_id(P) 成绩     1 1 100   2 2 100   3 3 100     Stu_id和Class_id共同组成主属性（复合主键） 成绩依赖Stu_id和Class_id本身，不存在部份依赖  第三范式3NF  3NF，字段设计不能存在传递依赖 传递依赖：字段某个非主属性不直接依赖主属性，而是通过依赖某个其他非主属性而传递到主属性之上 传递依赖解决：让依赖非主属性的字段与依赖字段独立成表  示例    学号(P) 姓名 专业编号 专业名称     1 张三 0001001 软件工程   2 李四 0001002 土木工程     姓名和专业编号都依赖于学号 专业名称依赖于专业编号 专业名称间接依赖学号：依赖传递 随着学生增加，专业名字会出现大量数据冗余  解决方案：将存储传递依赖部分的字段独立成表，然后在需要使用相关信息的时候，引入即可。\n专业表\n   专业编号(P) 专业名称     0001001 软件工程   0001002 土木工程    学生表\n   学号(P) 姓名 专业编号     1 张三 0001001   2 李四 0001002    逆规范化  为了提升数据查询的效率而刻意违背范式的规则 逆规范化的目标是为了提升数据访问效率 所谓逆规范化就是减少表之间的关联查询（效率降低），刻意增加数据冗余。  表关系  一个表代表一个实体，实体之间都有关联关系 根据范式的要求来设计表关系，减少数据冗余 根据实际需求来设计表关系，提升访问效率  示例 设计一个简单的新闻管理系统的数据库\n 新闻信息表：id、标题、内容、发布时间、作者id（作者主属性）、分类id（分类表主属性）、阅读量、推荐数 作者表：id、作者名字、作者来源id（来源表） 来源表：id、来源名字、来源描述 分类表：id、分类名字、分类级别（父分类id） 评论表：id、评论人id（评论人表）、评论时间、评论内容 评论人表：id、评论人名字  一对一关系  一张表中的一条记录与另外一张表中有且仅有一条记录有关系 一对一关系通常是用来将一张原本就是议题的表拆分成两张表  频繁使用部分：常用字段 不常使用部分：生僻字段 使用相同的主键对应   一对一关系设计较多使用在优化方面  示例    学号(P) 姓名 性别 年龄 身高 体重 籍贯 政治面貌     1 张三 男 20 185 160 山西 农民   2 李四 女 21 168 110 山西 党员     姓名、性别、年龄属于常用字段，频繁查询  一对一关系设计\n 将常用字段取出，与学号组合成一张常用表 将不常用字段取出，与学号组成一张不常用表 表与表数据对应关系：基于学号（唯一）是一对一关系  常用表\n   学号(P) 姓名 性别 年龄     1 张三 男 20   2 李四 女 21    不常用表\n   学号(P) 身高 体重 籍贯 政治面貌     1 185 160 山西 农民   2 168 110 山西 党员    一对多关系   又称多对一关系，一张表中的一条记录与另外一张表的多条记录对应，反过来另外一张表的多条记录只能对应当前表的一条记录\n  一对多关系是实体中非常常见的一种关系，实体设计时也应用非常多\n  一对多关系的核心解决方案是如何让记录能够正确匹配到另外表中的数据\n 一表设计：一表记录在另外一张表中有多条记录，所在无法记录多个字段 多表设计：多表记录在另外一张表中只有一条记录，可以设置字段记录对应的主属性（通常主键）    示例 老师与学科间的关系：一个老师只能教一个学科，但是一个学科可有多个老师来教。\n老师表\n   老师ID(P) 姓名 性别 年龄     1 张三 男 25   2 李四 女 26   3 王五 男 29    学科表\n   学科ID(P) 学科名称 课时长度     1 C++ 600   2 JAVA 800     以上两个实体没有体现彼此之间的关联关系 实际上讲师与学科之间肯定是有关联的  在多表中增加字段维护一表\n   老师ID(P) 姓名 性别 年龄 学科ID     1 张三 男 25 1   2 李四 女 26 2   3 王五 男 29 1    多对多关系  一张表中的一条记录对应另外一个表中多条记录，反过来一样 多对多关系在实体中是最常见的关系 多对多是无法在自身表中维护对应关系（违背1NF），需要通过第三方表来实现多对多关系变成多个多对一关系  设计一个中间表，记录两张表之间的对应关系（主属性） 中间表与其他表都是多对一关系    示例 老师与学生之间的关系：一个老师教多个学生，一个学生也会被多个老师教，实体关系为多对多。\n老师表\n   老师ID(P) 姓名 性别 年龄     1 张老师 男 25   2 李老师 女 26   3 王老师 男 29    学生表\n   学生ID(P) 姓名 性别 年龄     1 张三 男 20   2 李四 女 21   3 王五 男 19     以上实体没有从结构上体现表之间的关系  增加一个中间表\n中间表\n   ID(P) 学生ID 老师ID     1 1 1   2 1 2   3 1 3   4 2 1   5 2 2   6 2 3   7 3 1   8 3 2   9 3 3   ","permalink":"https://www.niuwx.cn/posts/mysql/%E8%8C%83%E5%BC%8F%E5%92%8C%E8%A1%A8%E5%85%B3%E7%B3%BB/","summary":"\u003ch3 id=\"关系型数据库设计范式\"\u003e关系型数据库设计范式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNormal Format\u003c/code\u003e，符合某一种级别的关系模式的集合，表示一个关系内部各个属性之间的联系的合理化程度\u003c/li\u003e\n\u003cli\u003e范式是离散数学的概念\u003c/li\u003e\n\u003cli\u003e范式目标是在满足组织和存储的前提下使数据结构冗余最小化\u003c/li\u003e\n\u003cli\u003e范式级别越高，表的级别就越标准\u003c/li\u003e\n\u003cli\u003e目前数据库应用的范式有以下几层\n\u003cul\u003e\n\u003cli\u003e第一范式：1NF\u003c/li\u003e\n\u003cli\u003e第二范式：2NF\u003c/li\u003e\n\u003cli\u003e第三范式：3NF\u003c/li\u003e\n\u003cli\u003e逆规范化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"范式和表关系"},{"content":"字段类型  字段类型在定义表结构时设定 设定好字段类型后，插入数据时必须与字段类型对应，否则数据错误 MySQL有四大数据类型  整数类型 小数类型 字符串类型 时间日期类型    整数类型  MySQL中为了数据空间的有效使用，设定了五种整数类型  迷你整型：tinyint，使用1个字节存储整数，最多存储256个整数(-128~127) 短整型：smallint，使用2个字节存储整数 中整型：mediumint，使用3个字节存储整数 标准整型：int，使用4个字节存储整数 大整型：bigint，使用8个字节存储整数   数值型存储在MySQL中分为有符号（有负数）和无符号（纯正数）   步骤\n 确定数据的格式是存储整数 预估整数的范围，选择合适的整数类型 确定整数是否需要符号（负数区间）   示例 # 年龄：无负数，正常年龄不会超过256，迷你整型 create table t1( age tinyint unsigned #unsigned修饰整数，表示无符号 )charset utf8; 显示宽度  显示宽度一般是该整数类型能表示的最大值对应的数字个数（通过desc查看字段表显示） 显示宽度包括符号（如果允许为负数，-负号会增加一个宽度） 显示宽度可以主动控制 显示宽度不会影响类型能表示的最大数值 可以通过zerofill让不够宽度的数值补充到对应宽度：在字段类型后使用zerofill  示例   有符号和无符号对应的宽度不一样\ncreate table t1( a tinyint, b tinyint unsigned )charset utf8;   可以主动控制显示宽度\nalter table t1 add c tinyint(2) unsigned;   显示宽度不影响数据的大小\ninsert into t1 values(1,1,1); insert into t1 values(100,100,100);   可以通过zerofill让小于显示宽度的数值前置补充0到显示宽度\nalter table t1 add d tinyint(2) zerofill; # 0填充只能针对正数 insert into t1 values(1,1,1,1);   小数类型（浮点型）   无法保证精度\n  浮点数又称为精度数据，分为两种\n 单精度：float，使用4个字节存储，精度范围为7~8位有效数字 双精度：double，使用8个字节存储，精度范围位15~16位有效数字    浮点数超过精度范围会自动进行四舍五入\n  精度可以指定整数部分和小数部分\n 默认不指定，整数部分不超过最大值，小数部分保留2位 可以指定：float/double（总长度，小数部分长度）    可以使用科学计数法插入数据\n   步骤\n 确定当前设计的字段的数据为不精确型数据（或者小数） 确定数据的大小或者精度的要求范围  6~7位有效数字使用float 14~15位有效数字使用double   确定精度的分布：整数部分和小数部分   示例   记录商品的价格\ncreate table t1( goods_name varchar(20), goods_price float )charset utf8; insert into t1 values(\u0026#34;lala\u0026#34;,19.99); #正常保留 insert into t1 values(\u0026#34;haha\u0026#34;,1999.9999); #四舍五入成2000   小数类型（定点型）  可以保证精度 不固定存储空间存储 每9个数字使用4个字节存储 定点型可以指定整数部分长度和小数部分长度  默认不指定：10位有效整数，0位小数 可以指定：decimal(有效数位，小数部分数位) 有效数位不超过65个   数据规范  整数部分超出报错 小数部分超出四舍五入     步骤\n 确定小数是否需要保证精度 确定有效数位长度   示例 # 资产和负债应该都是精确的，小数部分可以到分 create table t1( money decimal(14,2), bet decimal(10,2) )charset utf8; insert into t1 values(1111111111.12,1111111.99); insert into t1 values(1111111111.12,111111111111111.99)# 整数部分超出报错 insert into t1 values(1111111111.12,1111111.999)# 四舍五入 insert into t1 values(1111111111.12,99999999.999)# 四舍五入导致整数部分超出报错 字符串类型（定长型）  定长型：char(L)，指定固定长度的存储空间存储字符串 定长是指定存储长度 定长的长度是字符数量而不是字节  L的最大值是255 实际存储空间：$L字符数*字符集对应字节数$   定长里存储的数据不能超过指定长度 字符串数据使用单引号或者双引号包裹   步骤\n 确定数据类型为字符串（或不能用整数存储的超长数字符号） 确定数据长度基本一致（定长占用固定空间） 确定具体长度   示例 记录个人信息：身份证信息和手机号码\n# 身份证为固定长度18为 # 手机号码为11位固定长度 create table t1( id_number char(18), phone_number char(11) )charset utf8; insert into t1 values(\u0026#39;142629190001016666\u0026#39;,\u0026#39;12345678910\u0026#39;); 字符串类型（变长型）  变长型：varchar(L)，根据实际存储的数据变化存储空间 变长型的存储空间是由实际存储数据决定的 变长型的L也是指字符而不是字节  L指定的是最大存储的数据长度 L最大值理论是65535 变长需要额外产生1-2个字节，用来记录实际数据的长度  数据长度小于256，多1个字节 数据长度大于256，多2个字节   实际存储空间：$实际字符数*字符集对应字节数+记录长度$   变长数据不能超过定义的最大长度   步骤\n 确定数据类型为字符串 确定数据是不规则的数据 确定最大长度   示例 记录个人信息：用户名、密码、姓名、身份证\n# 用户名不确定长度，最长不超过50个字符 # 密码不确定长度，最长不超过16个字符 # 姓名不确定长度，最长不超过10个字符 # 身份证固定长度，18个字符 create table t1( `username` varchar(50), `password` varchar(16), `name` varchar(10), `id_number` char(18) )charset utf8; # 使用``包括字段名，防止字段名与关键字重名导致报错  insert into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;14262919000101666\u0026#39;); 字符串类型（文本字符串）  test/blob，专门用来存储较长的文本 文本字符串包含两大类  test：普通字符  tinytext：迷你文本，不超过$2^8-1$个字符 text：普通文本，不超过$2^{16}-1$个字符 mediumtext：中型文本，不超过$2^{24}-1$个字符 longtext：长文本，不超过$2^{32}-1$个字符（4G）   blob：二进制字符（与text类似）  tinyblob blob mediumblob longblob     文本字符串会自动根据文本长度选择合适的具体类型 一般在文本超过255个字符时，都会使用text（blob现在极少使用）   步骤\n 确定类型为文本文件 确定数据长度可能超过255个字符 使用text   示例 # 标题一般不会超过50个字符，varchar # 作者一般不会超过10个字符，varchar # 内容通常都很长，使用text create table t1( author varchar(10), title varchar(50), content text )charset utf8; insert into t1 values(\u0026#39;佚名\u0026#39;,\u0026#39;给家长的一封信\u0026#39;,\u0026#39;某某某的爸爸/妈妈...您好...\u0026#39;); 字符串类型（枚举）  一种映射存储方式，以较小的空间存储较多的数据 枚举是在定义时确定可能出现的问题 枚举在定义后数据只能出现定义时其中的一种 枚举类似一种单选框 枚举使用1-2个字节存储，最多可以设计65535个选项 枚举实际存储是使用数值，映射对应的元素数据，从1开始 枚举语法：enum(元素1,元素2....元素N)   步骤\n 确定数据是固定的几种数据之一 使用枚举穷举相应的元素 数据存储只能选择穷举中的元素之一   示例   记录人群类型：小朋友，少年，青年，中年，老年，每个人只属于一种类型题\ncreate table t1( type enum(\u0026#39;小朋友\u0026#39;,\u0026#39;少年\u0026#39;,\u0026#39;青年\u0026#39;,\u0026#39;中年\u0026#39;,\u0026#39;老年\u0026#39;) )charset utf8; insert into t1 values(\u0026#39;少年\u0026#39;); insert into t1 values(\u0026#39;神仙\u0026#39;);# error 不存在的数据不能插入   enum是建立映射关系，然后实际存储是数字，数值是按照元素顺序从1开始\n# 可以使用字段 + 0来判断数据具体的效果（字符串转数值为0） select type,type + 0 from t1; insert into t1 values(5);   字符串类型（集合）  set，一种映射存储方式，以较小的空间存储较多的数据 集合是在定义时确定可能出现的元素进行穷举 集合在定义后数据只能出现定义时其中的元素（可以是多个） 集合类似一种多选框 集合使用1-8个字节存储数据，最多可以设计64个元素 集合实际存储是使用数值（二进制位），映射对应的元素数据，每个元素对应一个比特位 集合语法：set(元素1,元素2,.....元素N)   步骤\n 确定数据是固定的几种数据集合 使用集合穷极相应的元素 数据存储只能选择穷举中的元素组合   示例   记录个人的球类爱好，有篮球，足球，羽毛球，网球，乒乓球，排球，台球，冰球\n# 爱好可以使多种 create table t1( hobby set(\u0026#39;足球\u0026#39;,\u0026#39;篮球\u0026#39;,\u0026#39;羽毛球\u0026#39;,\u0026#39;网球\u0026#39;,\u0026#39;乒乓球\u0026#39;,\u0026#39;排球\u0026#39;,\u0026#39;台球\u0026#39;,\u0026#39;冰球\u0026#39;) )charset utf8; insert into t1 values(\u0026#39;足球\u0026#39;); insert into t1 values(\u0026#39;足球,台球,篮球\u0026#39;);   集合建立的也是映射关系，映射方式是每个元素对应一个字节的比特位， 从左边开始第一个对应字节从右边开始的第一位\n# 可以通过字段 + 0的方式查看存储的具体数值 select hobby,hobby + 0 from t1; # 可以通过插入数值来组合元素，但是需要确定对应的十进制转换成二进制有对应的元素对应 insert into t1 value(8); # 网球   时间如期类型（年）  year，MySQL中用来存储年份的类型 MySQL中使用1个字节存储年份 year能够表示的范围是1901-2155（256年）  year的特殊值是0000   year允许用户是用两种方式设计（效果一样）  year year(4)     步骤\n 确定存储的数据是年份 确定年份的区间在1901-2155之间 使用year类型   示例   记录个人的出生年份\ncreate table t1( y1 year, y2 year(4) )charset utf8; insert into t1 values(1901,2155); insert into t1 values(1800); # error 不在范围内   year类型允许使用2位数来插入，系统自动匹配对应的年份\n 69以前：系统默认加2000 69以后：系统默认加1900  insert into t1 values(69,70); insert into t1 values(68,71);   year类型的特殊值是0000，可以使用00或者0000插入\ninsert into t1(00,0000);   时间日期类型（时间戳）  timestamp，基于格林威治时间的时间记录 MySQL中时间戳表现形式不是秒数，而是年月日时分秒格式  YYYY-MM-DD HH:II::SS YYYYMMDDHHIISS   timestamp使用4个字节存储 timestamp的特点是所对应的记录不论哪个字段被更新，该字段都会更新到当前时间   步骤\n 确定类型需要使用年月日时分秒格式 确定当前字段需要记录数据的最近更新时间 使用timestamp时间戳   示例   记录商品库存的最后更新时间\ncreate table t1( goods_name varchar(10), goods_inventory int unsigned, change_time timestamp )charset utf8; insert into t1 values(\u0026#39;大白菜\u0026#39;,100,\u0026#39;1971-01-01 00:00:00\u0026#39;); insert into t1 values(\u0026#39;小白菜\u0026#39;,100,\u0026#39;19700101000000\u0026#39;);   timestamp会在自己所在的记录任何位置被修改时自动更新时间\nupdate t1 set goods_inventory = 90; 在MySQL8后，取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性：on update current_timestamp\nalter table t1 add c_time timestamp on update current_timestamp update t1 set goods_inventory = 80;   时间日期类型（日期）  date，用来记录年月日信息 使用3 个字节存储数据 存储日期的格式为：YYYY-MM-DD 存储的范围是：1001-01-01到9999-12-31 目前来说，还够用   步骤\n 确定存储的数据格式为日期格式 确定数据格式为YYYY-MM-DD 使用date类型   示例 记录个人生日\ncreate table t1( `name` varchar(10), birth date )charset utf8; insert into t1 values(\u0026#39;张三\u0026#39;,\u0026#39;2000-01-01\u0026#39;); insert into t1 values(\u0026#39;李四\u0026#39;,\u0026#39;2021-07-23\u0026#39;); 时间日期类型（日期时间）  datetime，用来综合存储日期和时间 存储格式为：YYYY-MM-DD HH:II:SS 存储区间为：1000-01-01 00:00:00到9999-12-31 23:59:59   步骤\n 确定存储的时间格式包含日期 确定存储格式为：YYYY-MM-DD HH:II:SS 使用datetime   示例 记录个人具体的出生时间\ncreate table t1( `name` varchar(10), birth datetime )charset utf8; insert into t1 时间日期类型（时间）  time，用来记录时间或者时间段 数据范围是：-838:59:59-838:59:59 数据插入的格式分为两种  时间格式：HH:II:SS 时间段格式：D HH:II:SS     步骤\n 确定要存储的类型是时间格式 确定格式类型为time能表示的格式 使用time存储   示例 记录用户登录的具体时间\n# 具体登录时间可以使用时间戳（包含年月日时分秒信息） # 也可以使用时间datetime格式，或者date+time双字段格式 create table t1( login_time1 int unsigned, login_time2 datetime, login_date date, login_time3 time )charset utf8; insert into t1 values(12345678,\u0026#39;2000-12-12 12:12:12\u0026#39;,\u0026#39;2000-12-12\u0026#39;,\u0026#39;12:12:12\u0026#39;); insert into t1 values(1234567,\u0026#39;2000-12-12 12:12:12\u0026#39;,\u0026#39;2000-12-12\u0026#39;,\u0026#39;3 12:12:12\u0026#39;); 属性 属性作用  建立在字段类型之后，对字段除类型之外的其他约束 属性是在定义表字段的时候针对每个字段进行属性设定 设定好的属性可以通过查看表字段desc进行查看 数据在进行增删改（写）操作时需要在满足字段要求的同时满足属性的要求  示例 desc t1; # Field: 字段名字 # Type: 数据类型 # Null: 是否为空（属性） # Key: 索引类型（属性） # Default: 默认值（属性） # Extra: 额外属性 NULL属性  NULL：数据是否允许为空 不为空设计： Not Null 数据为空一般不具备运算和分析价值，所以通常数据都需要设定Not Null（不区分大小写）   步骤\n 数据类型确定 数据是否为空确定  允许为空：不考虑Null属性 不允许为空：Not Null     示例   用户信息表：用户名、密码、姓名、年龄、注册时间\ncreate table t1( `username` varchar(50) not null, `password` char(32) not null, name varchar(20), age tinyint unsigned, reg_time int unsigned not null )charset utf8;   如果字段不能为空（Not Null），那么数据就必须满足条件：插入时不能为空的字段就需要主动提供值\ninsert into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,\u0026#39;张三\u0026#39;,20,123456789); # 错误操作，reg_time不能为空，而默认为空， insert into t1 (`username`,`password`) values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;);   Defaule属性  defaule，在设计表字段的时候给定默认数据，在后续字段操作（数据新增）的时候系统没有检测到字段有数据的时候自动使用的值 默认值在字段设计的时候使用（默认值需要满足数据类型规范） 默认值通常设计的字段容易出现的数据  一般字段的默认值默认是Null   默认值触发  在系统进行数据插入时自动检测触发 主动使用default关键字触发默认值     步骤\n 确定字段的数据类型 确定字段可能出现的数据会是某个经常出现的值 设定默认值 触发默认值  自动触发：数据插入时不给字段复制 手动触发：数据插入时主动使用default关键字     示例   用户开户：银行卡账号、身份证号码、姓名、账户余额\ncreate table t1( account varchar(19) not null, id_card char(18) not null, `name` varchar(20) not null, money decimal(16,2) default 0.00 not null )charset utf8;   默认值触发\n# 默认触发 insert into t1 (account,id_card,name) values(\u0026#39;123456789101112131\u0026#39;,\u0026#39;142629200001011010\u0026#39;,\u0026#39;张三\u0026#39;); # 主动触发 insert into t1 values(\u0026#39;123456789101112131\u0026#39;,\u0026#39;142629200001010101\u0026#39;,\u0026#39;李四\u0026#39;,default);   主键  primary key，用来保证整张表中对应的字段永远不会出现重复数据 主键在一张表中只能有一个 主键的另外一个特性是能够提升主键字段作为查询条件的效率(索引) 主键不能为空：Not Null(默认) 逻辑主键：数据没有具体业务意义，纯粹是一种数值数据  逻辑主键通常是整数：int 逻辑主键目的是方便检索和数据安全（不暴露数据真实信息）   复合主键：多个字段共同组成不能重复的数据  primary key(字段1,字段2,...) 联合主键使用不多，一般也不会超过2个字段     步骤\n 确定字段数据具有唯一性 确定数据不允许为空 确定数据会经常用于数据检索 使用主键primary key 一般每张表都会使用一个逻辑主键(id)   示例   银行账户信息：账户、姓名、余额\n# 银行账户具有唯一性，不可重复，不可为空 create table t1( account varchar(17) primary key, `name` varchar(20) not null, money decimal(16,2) not null default 0.00 )charset utf8; # 复合主键 create table t2( account varchar(17), `name` varchar(20), money decimal(16,2) not null default 0.00, primary key(account,`name`) )charset utf8; # 一般使用逻辑主键 create table t3( id int unsigned primary key, account varchar(17) not null, `name` varchar(20) not null, money decimal(16,2) not null default 0.00 )charset utf8;   主键数据不允许重复\ninsert into t3 values(1,\u0026#39;123456\u0026#39;,\u0026#39;1\u0026#39;,default); # 错误 主键1已经存在 insert into t3 values(1,\u0026#39;456789\u0026#39;,\u0026#39;2\u0026#39;,default); # 联合主键就是联合字段加起来不重复即可 insert into t2 values(\u0026#39;123456\u0026#39;,\u0026#39;Tom\u0026#39;,default); insert into t2 values(\u0026#39;456789\u0026#39;,\u0026#39;Tom\u0026#39;,default);   主键管理  在创建表并且已经有数据后的维护 删除主键 追加主键 修改主键（先删后增）  示例   删除主键：主键只有一个，所以删除语法也比较特殊\nalter table t1 drop primary key;   后期新增主键：如果是针对业务主键需要保证字段数据没有Null数据且没有数据重复（一般主键都会在表创建时维护好）\nalter table t1 add primary key(account,name);   自增长属性  auto_increment，被修饰的字段在新增时，自动增长的数据 自增长数据可以理解为一种默认值，如果主动给值，那么自动增长不会触发 自增长有两个变量控制  初始值：auto_increment_offset，默认为1 步长：auto_increment_increment，默认为1 查看自增长控制：show variables like 'auto_increment'     步骤\n 确定数据类型为整形 确定数据需要有规则的变化  从1开始 每次增长1 可以调整，但是通常有固定规则   必须有索引字段（索引主键） 使用auto_increment   示例   记录学生信息：学号和姓名\n# 学生信息：学号自动增长 create table t1( id int primary key auto_increment, stu_no int(8) zerofill not null, stu_name varchar(20) not null )charset utf8;   触发自增长\n# 使用自增长 可以使用NULL或者default触发 insert into t1 values(null,1,\u0026#39;Jim\u0026#39;); insert into t1 values(default,2,\u0026#39;Tom\u0026#39;); #主动控制：自增长的值会从当前最大的值开始自动增长 insert into t1 values(5,3,\u0026#39;张三\u0026#39;); insert into t1 (stu_no,stu_name) values(4,\u0026#39;李四\u0026#39;);   自增长管理  修改表中自增长的值：让下次自增长按照指定的值开始 修改自增长的控制：调整自增长的变化  示例   修改表中自增长的值，跳过一些值，直接从下次开始按照新的目标出现\nalter table t1 auto_increment = 50; insert into t1 (stu_no,stu_name) values(1,\u0026#39;测试1\u0026#39;); # 奇数保留原值，偶数自动加一（可能） 由于数据不稳定   修改自增长控制：步长和起始值（修改针对的是整个数据库，而非单张表）\nset auto_increment_increment = 2;# 当前用户当前连接有效（局部） set @@auto_increment_incremtn = 2;# 所有用户一定有效（全局）   唯一键  unique key，用来维护数据的唯一性 一个表中可以有多个唯一键 唯一键与主键的区别在于唯一键允许数据为Null（且数量不限） 唯一键与主键一样，可以提升字段数据当做条件查询的效率（索引） 复合唯一键：多个字段共同组成  unique key(字段1,字段2,字段3,...) 一般不会出现，最多2个字段组成     步骤\n 确定数据列具有唯一性 确定数据列不用作为主键 确定数据会经常用于检索条件 该字段是否允许数据为空 使用唯一键   示例   用户表：用户名唯一，而且经常作为查询条件\ncreate table t1( id int primary key auto_increment, `username` varchar(50) unique, `password` char(32) not null )charset utf8; insert into t1 values(null,\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;); insert into t1 values(null,Null,\u0026#39;password\u0026#39;); insert into t1 values(null,Null,\u0026#39;password\u0026#39;); # 错误 insert into t1 values(null,\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;);   学生成绩表：一个学生只能有一个学科成绩，但是可以有多个学科\n# 学号和学科编号共同组成唯一 create table t1( id int primary key auto_increment, stu_name varchar(20) not null, course varchar(20) not null, score decimal (5,2), unique key(stu_name,course) )charset utf8; insert into t1 values(null,\u0026#39;Jim\u0026#39;,\u0026#39;Math\u0026#39;,60); insert into t1 values(null,\u0026#39;Jim\u0026#39;,\u0026#39;English\u0026#39;,60);   唯一键管理  删除唯一键：一张表中不止一个唯一键，所以删除方式相对麻烦：alter table 表名 drop index 唯一键名字 新增唯一键：alter table 表名 add unique key(字段列表)  示例   删除表中已有的唯一键\nalter table t1 drop index `stu_name`;   追加唯一键\nalter table t1 add unique key `stu_course` (stu_name,course);   comment 属性  comment，是用文字描述字段的作用的 comment代表的内容是对字段的描述  方便以后自己了解字段的作用 方便团队了解字段的作用   描述如果涉及到字符集（中文）一定要在创建表之前设计好客户端字符集（否则会出现乱码）  示例 create table t1( id int primary key auto_increment comment \u0026#39;id逻辑主键自增长\u0026#39; )charset utf8; 数据库记录长度  MySQL中规定一条记录所占用的存储长度最长不超过65535个字节 记录长度是表中所有字段预计占用的长度之和 所有字段只要允许Null存在，系统就会一个字节存储Null 因为MySQL记录长度的存在，varchar永远达不到理论长度 一般数据长度超过255个字符都会使用text/blob进行存储 ","permalink":"https://www.niuwx.cn/posts/mysql/%E5%AD%97%E6%AE%B5/","summary":"\u003ch3 id=\"字段类型\"\u003e字段类型\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e字段类型在定义表结构时设定\u003c/li\u003e\n\u003cli\u003e设定好字段类型后，插入数据时必须与字段类型对应，否则数据错误\u003c/li\u003e\n\u003cli\u003eMySQL有四大数据类型\n\u003cul\u003e\n\u003cli\u003e整数类型\u003c/li\u003e\n\u003cli\u003e小数类型\u003c/li\u003e\n\u003cli\u003e字符串类型\u003c/li\u003e\n\u003cli\u003e时间日期类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"字段"},{"content":"字符集 了解字符集的概念，掌握MySQL数据库存储数据的字符集逻辑以及设置方式\n字符集的概念  字符集根据不同国家的符号不同，有不同的字符集 不同的字符集占用的存储空间不一样，存储的底层也不一样 不同字符集之间可以进行转换 常见字符集  ASCⅡ：美国信息交换标准码，一般英文符号，一个字节存储 latin1：拉丁文字符集，一个字节存储，ISO-8859-1的别名，能够向下兼容ASCIⅡ GB2312：信息交换用汉字编码字符集，是中国1981年的一套国际规范，2个字节存储 GBK：汉字内码拓展规范（1995年），两个字节表示 Unicode：万国码（统一码），使用同一的编码方式来解决传统的局限，1994年出现 UTF-8：针对Unicode的可变长度字符编码，采用1-6个字节编码Unicode字符 （目前通用编码规则）。建议使用UTF-8字符集进行数据存储。（MySQL8中建议使用UTF8MB4）    示例 ASCⅡ码表\nMySQL字符集  MySQL内部对象可以在各个层级设置字符集 MySQL内部对象存在字符集继承：字段-\u0026gt;表-\u0026gt;数据库-\u0026gt;DBMS MySQL内部内嵌几乎所有主流字符集 数据存储的最终字符集由字段控制 客户端与服务器进行交互时，需要明确告知服务器客户端自己的字符集（数据格式）  示例 查看MySQL支持的所有字符集\nshow charset; 乱码问题解决   乱码原因1：数据在存储的时候已经变成乱码\n 客户端字符集与服务端解析字符集不一致 读取时想转成其他字符集均会错误    乱码原因2：数据存储时正确，但是读取时解析成错误字符集\n 客户端能解析的字符集与服务器提供的字符集不一致    乱码解决方案：不论存储还是读取，都提前告知服务器当前客户端的字符集\nset names 客户端字符集;   字符集设置原理  MySQL服务器提供了变量来记录客户端的字符集 MySQL对应的存储字符集的变量可以修改 set names 字符集就是对变量的修改，总共有三个  character_set_client：客户端提供的数据的字符集 character_set_results：客户端需要服务端提供的数据的字符集 character_set_connection：连接使用的字符集，内部数据操作    示例   查看系统内部存储这些记录字符集的信息\nshow variables like \u0026#39;character_set%\u0026#39; # %表示通配符，匹配后续不确定的数据   修改客户端字符变量，保证数据正常存进服务端\nset character_set_client = gbk;   修改客户端解析字符集变量，保证数据正常被客户端查看\nset character_set_results = gbk;   使用set names 字符集批量修改，保证客户端被服务端正确理解，同时客户端也能正常解析\nset names gbk;   校对集 校对集概念  数据比较时对应的规则 校对集依赖字符集 校对集的校对方式分为三种：  大小写不敏感：_ci,case insensitive 大小写敏感：_cs，case sensitive 二进制比较：_bin,binary（大小写敏感）   校对集是在进行数据比较的时候触发  示例   _ci，大小写不敏感\n# A 和 a是相同的，不存在谁大谁小   _cs，大小写敏感\n# A 和 a有大小关系，所以不同   _bin，二进制比较\n# A 的二进制 01000001 # a 的二进制 01100001 # 二进制按位比较，所以不同   校对集设置   校对规则可以在MySQL四层对象设计\n DBMS：系统配置 DB：数据库指定（库选项） Table：标指定（表选项） Filed：字段指定（字段选项，一般不用）    校对集从Field到DBMS继承：优先级Field最高\n  每个校对集都有字符集对应的默认规则\n  校对集设置语法\ncollate 校对集规则;   示例   查看MySQL支持的所有校对集\nshow collation;   在数据库层设置校对集（常用）\ncreate database test_4 charset utf8MB4 collate utf8MB4_bin;   在数据表层设计校对集\ncreate table t_4( id int, name varchar(10) ) charset utf8Mb4 collate utf8MB4_bin;   在字段层设计校对集（一般不常用）\ncreate table t_4( id int, name varchar(50) collate utf8Mb4_bin )charset utf8MB4;   校对集应用  校对集的应用通常是通过数据比较触发：order by 字段 数据表中数据一旦产生，校对集的修改就无效  示例   创建校对规则数据表并插入数据\n# 创建默认校对规则表（不区分大小写） CREATE TABLE t1( name varchar(1) )CHARSET utf8Mb4; INSERT INTO t1 values(\u0026#34;B\u0026#34;); INSERT INTO t1 values(\u0026#34;A\u0026#34;); INSERT INTO t1 values(\u0026#34;b\u0026#34;); INSERT INTO t1 values(\u0026#34;a\u0026#34;); select * from t1 order by name; #执行结果 A a B b # 创建二进制校对规则（区分大小写） CREATE TABLE t2( name varchar(1) )charset utf8MB4 collate utf8MB4_bin; INSERT INTO t2 VALUES(\u0026#34;B\u0026#34;); INSERT INTO t2 VALUES(\u0026#34;A\u0026#34;); INSERT INTO t2 VALUES(\u0026#34;b\u0026#34;); INSERT INTO t2 VALUES(\u0026#34;a\u0026#34;); select * from t2 order by name; #执行结果 A B a b   触发校对：排序order by\nselect * from t1 order by name; select * from t2 order by name;   数据已经存在的表重新修改校对规则\nalter table t1 collate utf8MB4_general_ci; # 不会报错，但是实际校对规则依旧不变   校对集的触发自动的，只要数据在进行比较的时候就会自动触发设定的校对规则。\n","permalink":"https://www.niuwx.cn/posts/mysql/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%9B%86/","summary":"\u003ch3 id=\"字符集\"\u003e字符集\u003c/h3\u003e\n\u003cp\u003e了解字符集的概念，掌握MySQL数据库存储数据的字符集逻辑以及设置方式\u003c/p\u003e","title":"字符集、校对集"},{"content":"SQL语法规则  概念 SQL语法规则：SQL是一种结构化编程语言\n  基础SQL指令通常是以行为单位 SQL指令需要语句结束符，默认是英文分号：;、\\g、\\G  \\G：主要用于查询数据   SQL指令类似自然语言 编写的SQL中如果用到了关键字或者保留字，需要使用反引号``来包括，让系统忽略   示例\n  结构创建  create 数据类型 结构名 结构类型; 显示结构  #显示结构 show 结构类型（复数）; #显示结构创建详细 show create 结构类型 结构名; 数据操作（数据表）  #新增数据 insert into 表名 values #查看数据 select from 表名 #更新数据 update 表名 set #删除数据 delete from 表名 根据数据库的对象层级，可以将基础SQL操作分为三类：\n 库操作：数据库相关操作 表操作：数据表（字段）相关操作 数据操作：数据相关操作  SQL库操作 创建数据库  使用create database 数据库名字 创建  数据库层面可以指定字符集：charset/character set   数据库层面可以指定校对集：collate 创建数据库会在磁盘指定存放处产生一个文件夹 创建语法：  create database 数据库名字 [数据库选项]; 示例   创建一个指定名字的数据库\ncreate database test_1;   创建一个指定字符集的数据库\ncreate database test_2 charset utf8MB4   创建一个指定校对集的数据库\ncreate database test_3 charset utf8MB4 collate utf8mb4_general_ci;   数据库命名规则：与C同\n显示数据库  数据库的查看是根据用户权限限定的 数据库的查看分为两种查看方式：  查看全部数据库 查看数据库创建指令    示例   显示数据库\nshow databases;   显示数据库创建命令\nshow create databases test_1;   使用数据库  数据库的操作通常是针对数据表或数据 通过使用数据库可以让后续指令默认针对具体数据库环境、简化后续命令 使用数据库语法：use 数据库名字;  示例 use test_1; 修改数据库   数据库名字不可修改（老版本可以）\n 先新增 后迁移 再删除    数据库修改分为两个部分\n 字符集 校对集    数据库修改指令（与创建指令差不多）\nalter database 数据库名字 库选项   示例   修改数据库字符集\nalter database test_2 charset dbk;   修改数据库校对集（如果字符集修改必须同时改变字符集）\nalter database test_3 charset gbk collate gbk_chinese_ci;   删除数据库   删除数据库会删除数据库内所有的表和数据\n  删除数据库操作要慎重（删前备份）\n  删除数据库后，对应的存储文件夹就会消失\n  删除语法\ndrop database 数据库名字;   示例 drop database test_1; SQL表（字段）操作 创建数据表 根据业务需求，确定数据表的字段信息，然后创建表结构\n  表与字段不分家，相辅相成\n  表的创建需要指定存储的数据库\n 明确指定数据库 先使用数据库    字段至少需要指定改名字、类型\n  数据库表不限定字段数量\n 每个字段间使用逗号,分隔 最后一个字段不需要逗号    表可以指定表选项（都有默认值）\n 存储引擎：engine[=]具体存储引擎 字符集：[default] charset 具体字符集 （继承数据库） 校对集：collate（继承数据库）    表创建语法\ncreate table [数据库名.]表名( 字段名 字段类型, ... 字段名 字段类型, )表选项;   示例   创建简单数据表\ncreate table t_1( name varchar(50) );   创建数据表\u0026mdash;多字段\ncreate table t_2( name varchar(50), age int, gender varchar(10) );   创建数据表\u0026mdash;表选项\ncreate table t_3( name varchar(50) )engine Innodb charset utf8MB4;    拓展\n存储引擎是指数据存储和管理方式，MySQL中提供了多种存储引擎，一般使用默认存储引擎。\n InnoDB  默认存储引擎 支持事务处理和外键 数据统一管理   MyIsam  不支持事务和外键 数据、表结构、索引独立管理 MySQL5.6以后不在维护    如果想创建一个与已有表一样的数据表，MySQL提供了一个便捷的复制模式\n create table 表名 like 数据库名字.表名   显示数据表  数据表的显示与用户权限有关 显示数据表有两种方式  显示所有数据表 显示具体数据表的创建指令    示例   显示所有数据表\u0026mdash;当前数据库下\nshow tables;   显示所有数据表\u0026mdash;指定数据库\nshow tables from test_1;   显示部分关联数据表\u0026mdash;匹配\nshow tables like \u0026#39;%like\u0026#39;; #_：匹配一个字符(固定位置) #%：匹配N个字符   显示数据表的创建指令\nshow create table t_1;   查看数据表   通常是查看字段信息\n  详细的显示字段的各项信息\n  查看语法有三种\ndesc 表名; describe 表名; show columns from 表名;   更改数据表  更改表名：rename teble 表名 to 新表名 修改表选项：alter table 表名  示例   修改表名\nrename table t_1 to t1; 注意：如果有时候要跨库修改的话，需要使用数据库名.表名\n  修改表选项\nalter table t1 charset gbk;   更改字段  字段操作包含字段名字、类型和属性的操作 字段操作通常是在表已经存在数据后进行  新增字段   字段的新增必须同时存在字段类型\n  新增语法\nalter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]   示例   给已经存在的表增加一个字段\nalter table t1 add age int;   字段位置   字段位置分为两种\n 第一个字段：first 某个字段后：after已经存在字段名    字段位置适用于追加字段、修改字段、更改字段名\n  字段位置语法\nalter table 表名 字段操作 字段位置;   示例   为表增加一个字段，放在最前面\nalter table t1 add id int first;   在表某字段后增加一个字段\nalter table t1 add card varchar(18) after name;   更改字段名   字段名的修改必须跟上字段类型\n  字段名修改语法\nalter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置];   示例 修改字段名card为sfz\nalter table t1 change card sfz varchar(18); 修改字段   修改字段类型、字段属性和位置\n  修改字段语法\nalter table 表名 modify 字段名 字段类型 [字段属性] [位置];   示例 修改sfz类型为char(18)并且把位置放到id后面\nalter table t1 modify sfz char(18) after id; 删除字段   删除字段会将数据也删除\n  删除字段语法\nalter table 表名 drop 字段名;   示例 alter table t1 drop age; SQL数据操作 新增数据  新增数据是根据表的字段顺序和数据类型要求将数据存放到数据表中 数据表中的数据以行(row)为存储单位，实际存储属于字段(field)存储数据 数据插入分两种方式  全字段插入：insert into 表名 values(字段列表顺序对应的所有值) 部分字段插入：insert into 表名(字段列表) values(字段列表对应的值的顺序列表)    示例   插入完整数据\ninsert into t1 values(1,\u0026#34;666\u0026#34;,\u0026#34;张三\u0026#34;,\u0026#34;小张\u0026#34;);   根据字段插入数据\ninsert into t1 (id,name ) values(1,\u0026#34;李四\u0026#34;);   查看数据   查到的数据显示出来是一张二维表\n  数据显示包含字段名和字段本身\n  数据查看分两种方式\n 查看全部字段：使用*代替所有字段 查看部分字段：明确字段名，使用逗号分隔    查看数据很多时候也是根据条件查询部分数据\n  查看语法\nselect */字段列表 from 表名;   示例   查看所有数据\nselect * from t1;   查看部分字段数据\nselect id,name;   查看表中id为1的信息\nselect * from t1 where id = 1;   更新数据   更新数据通常时根据条件更新某些数据，而不是全部记录都更新\n  更新数据语法\nupdate 表名 set 字段 = 新值[,字段 = 新值] [where 条件筛选];   示例   更新所有记录的身份信息\nupdate t1 set sfz = \u0026#34;777\u0026#34;;   更新某个记录的多个字段数据\nupdate t1 set name = \u0026#34;张三\u0026#34;，sfz = \u0026#34;666\u0026#34; where id = 777;   删除数据   删除数据是一种不可逆操作\n  数据删除通常都是有条件删除\n  数据删除语法\ndelete from 表名 [where 条件];   示例 删除数据\ndelete from t1 where id = 777; ","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"\u003ch3 id=\"sql语法规则\"\u003eSQL语法规则\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e概念\n\u003cstrong\u003eSQL语法规则\u003c/strong\u003e：SQL是一种结构化编程语言\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e基础SQL指令通常是以行为单位\u003c/li\u003e\n\u003cli\u003eSQL指令需要语句结束符，默认是英文分号：\u003ccode\u003e;\u003c/code\u003e、\u003ccode\u003e\\g\u003c/code\u003e、\u003ccode\u003e\\G\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\\G\u003c/code\u003e：主要用于查询数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSQL指令类似自然语言\u003c/li\u003e\n\u003cli\u003e编写的SQL中如果用到了关键字或者保留字，需要使用反引号``来包括，让系统忽略\u003c/li\u003e\n\u003c/ul\u003e","title":"MySQL基本操作"},{"content":"数据库的基本知识  概念\n数据库：database，是一种存储数据的仓库。\n  数据库是根据数据结构组织，存储和管理数据的 数据库能够长期、高效的管理和存储数据 数据库的目的就是能够存储（写）和提供（读）数据  数据库分类  概念\n数据库分类：根据数据库的架构和数据组织原理进行分类。\n   早起根据数据库的组织数据的存储模型分类\n 层次数据库：基于层次的数据结构（数据分层） 网状数据库：基于网状的数据结构（数据网络） 关系数据库：基于关系模型的数据结构（二维表）    现在较多根据实际数据管理模型分类（存储介质）\n 关系型数据库：基于关系模型的数据结构（二维表）通常存储在磁盘 非关系型数据库：没有具体模型的数据结构（键值对）通常存储在内存    关系型数据库  概念\n关系型数据库：一种建立在关系模型上的数据库\n  关系模型：  关系数据结构（存储） 关系操作集合（操作） 关系完整约束（约束）   关系型数据库存储在磁盘中（永久性存储） 关系型数据库系统(DBS)模型有四层结构  数据库管理系统(DBMS)：管理系统运行 数据库(DB)：数据存储的管理者 数据表(Table)：数据关系管理者 数据字段(Field)：依赖于数据表、实际数据存储者   关系型数据库产品  大型：Oracle、DB2 中性：MySQL、SqlServer 小型：Sybase、Access    非关系型数据库  概念\n非关系型数据库：NoSQL（Not only SQL），不仅仅是关系型数据库\n  所以不是关系型数据库的统称 数据存储模型不是二维表，而是键值对（KEY-VALUE） 存储的位置通常是内存（效率高） 不能永久性存储（需要定时存到关系型数据库中） 常见的非关系型数据库产品  MongoDB Redis Memcached    对比 NoSQL通常与关系型数据库配合使用，他们彼此是一种互补关系。\n NoSQL运行在内存、解决效率问题  I/O问题 效率问题   MySQL运行在磁盘、解决稳定问题  安全问题（永久存储） 稳定    SQL基本介绍  概念\nSQL：Structured Query Language，结构化查询语言，是一种针对关系型数据库特殊标准化的编程语言。\n  SQL是一种编程语言 能够实现用户数据库查询和程序设计 SQL根据操作不同，分为几类：  DQL：Data Query Language ，数据查询语言，用于查询和检索数据 DML：Data Manipulation Language，数据操作语言，用于数据的写操作（增删改） DDL：Data Definition Language，数据定义语言，用于创建数据结构 DCL：Data Control Language，数据控制语言，用于用户权限管理 TPL：Transaction Process Language，事务处理语言，辅助DML进行事务操作（因此也归属于DML）     SQL虽然是编程语言，但是目前数据库通常只用来进行数据管理（逻辑部分给其他编程语言） SQL虽然是针对关系型数据库的通用语言，但是不同的产品操作指令不完全通用  MySQL基本介绍  概念\nMySQL：瑞典AB公司下的一款关系型数据库\n  MySQL当前属于甲骨文公司（AB-\u0026gt;Sun-\u0026gt;Oracle） MySQL开源免费（部分存储引擎收费） MySQL是一种C/S结构软件，因此需要MySQL的客户端来访问服务端（数据管理）  mysqld.exe：服务端 mysql.exe：客户端   MySQL使用SQL指令对数据库进行操作  访问原理 graph LR\rA[MySQL客户端] --\u0026gt;B[寻找服务端 host寻找]\rB --\u0026gt; C[寻找服务器 Port寻找]\rC --\u0026gt; D[验证身份 username验证 password验证]\rD --\u0026gt; E{服务器}\rMySQL访问  MySQL访问：客户端连接上服务器，然后实现数据操作的过程\n  客户端访问服务端  利用Windows控制台访问（MySQL客户端） 利用数据库管理工具（Navicat）   客户端需要连接认证  -h：主机地址（本机localhost 、可以忽略） -P：端口号（默认3306） -u：用户名 -p：用户密码   客户端连接上服务端就表示占用了一个资源，可以进行对应权限的操作  MySQL数据库连接资源有限：单个服务器最多16384个 连接资源不够了其他访问就需要排队等待 用完尽可能释放资源   ","permalink":"https://www.niuwx.cn/posts/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","summary":"\u003ch3 id=\"数据库的基本知识\"\u003e数据库的基本知识\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e概念\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据库\u003c/strong\u003e：database，是一种存储数据的仓库。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e数据库是根据数据结构组织，存储和管理数据的\u003c/li\u003e\n\u003cli\u003e数据库能够长期、高效的管理和存储数据\u003c/li\u003e\n\u003cli\u003e数据库的目的就是能够存储（写）和提供（读）数据\u003c/li\u003e\n\u003c/ul\u003e","title":"MySQL基本操作"},{"content":"这篇文章将介绍图论中的拓扑排序。\n什么是拓扑排序？ 对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。\n拓扑排序  入度：指向v的边的个数叫做v的入度。 出度：v指向的点的个数叫做v的出度。  如果一个点的入度是0，那么说明这个点是起点（起点不止一个）。如果一个点的出度为0，那么说明这个点排在最后。\n举例说明：\n如图所示，这是一个有向无环图，其指向顺序为a,(b,c),d,e,则abcde和acbde都是这个图的拓扑排序。\n很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。\n拓扑排序的实现 DFS和BFS都可以实现拓扑排序。\nBFS实现拓扑排序 这种算法也叫做Kahn算法\n继续使用上面的例子进行说明\nBFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。\n无前驱的顶点优先就是顺着找，a的入度为0，则其为起点，a入队；\na出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；\n目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；\nb出队，b指向d，d入度减一，d入度为零，入队；\nd出队，d指向e，e入度减一，e入度为零，入队；\ne出队，无后续结点，结束。\n由上述过程可得拓扑排序为acbde。\n时间复杂度 假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。\n代码实现如下：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int T, n, m, u, v; int deg[N]; int vis[N]; int dest[N]; vector\u0026lt;int\u0026gt; g[N]; queue\u0026lt;int\u0026gt; q; bool toposort() { //将入度为零的点放入队列  for (int i = 1; i \u0026lt;= n; i++) { if (!deg[i]) { vis[i] = 1; q.push(i); } } int num = 0; while (!q.empty()) { int now = q.front(); q.pop(); dest[num++] = now; for (auto to : g[now]) { if (vis[to]) //判断该节点是否在队列中  continue; else { deg[to]--; //入度减一  if (!deg[to]) { //判断入度是否为零  q.push(to); //入队  vis[to] = 1; //标记其在队列中  } } } } if (num == n) return true; else return false; } int main(int argc, char const *argv[]) { memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); memset(dest, 0, sizeof(dest)); for (int i = 1; i \u0026lt;= N; i++) g[i].clear(); while (!q.empty()) q.pop(); //以上为初始化  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); //读入  g[u].push_back(v); deg[v]++; //统计入度  } if (toposort()) {//如果可以生成拓扑排序  for (int i = 0; i \u0026lt; n; i++) //输出结果  printf(\u0026#34;%d%c\u0026#34;, dest[i], i == n ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } else printf(\u0026#34;NO\\n\u0026#34;); return 0; } //测试数据 //有向有环图 2 1 1 3 3 4 4 2 //有向无环图 1 2 1 3 3 4 2 4 4 5 DFS实现拓扑排序 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int n, u, v; int c[N]; // 标志数组 vector\u0026lt;int\u0026gt; G[N]; // vector 实现的邻接表 vector\u0026lt;int\u0026gt; topo; // 拓扑排序后的节点  bool dfs(int u) { c[u] = -1; for (int v : G[u]) { if (c[v] \u0026lt; 0) return false; else if (!c[v]) if (!dfs(v)) return false; } c[u] = 1; topo.push_back(u); return true; } bool toposort() { topo.clear(); memset(c, 0, sizeof(c)); for (int u = 0; u \u0026lt; n; u++) if (!c[u]) if (!dfs(u)) return false; reverse(topo.begin(), topo.end()); return true; } int main(int argc, char const *argv[]) { return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","summary":"\u003cp\u003e这篇文章将介绍图论中的拓扑排序。\u003c/p\u003e","title":"拓扑排序"},{"content":"C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\n存储 高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出\n头文件及全局变量 #include \u0026lt;bits/stdc++.h\u0026gt;static const int LEN = 1004; int a[LEN], b[LEN], c[LEN], d[LEN]; int flag; 清空 void clean(int temp[]) { for (int i = 0; i \u0026lt; LEN; ++i) temp[i] = 0; } 存储 void read(int temp[]) { static char s[LEN + 1]; scanf(\u0026#34;%s\u0026#34;, s); clean(temp); int len = strlen(s); for (int i = 0; i \u0026lt; len; ++i) { temp[len - 1 - i] = s[i] - \u0026#39;0\u0026#39;; } } 输出 void print(int a[]) { int i; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (; i \u0026gt;= 0; i--) putchar(a[i] + \u0026#39;0\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } 这样就完成了对于数据的存储与输出\n加法 高精度加法其实就是按照竖式加法法则来计算\n从低位开始相加，满十则向高一位进一，本位取余\n{% note info, 这里使用十进制，也可以使用其他更大的进制，如1000进制 %}\n//高精度加法 void add(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] = a[i] + b[i]; if (c[i] \u0026gt; 9) {//判断是否满十  c[i] -= 10; c[i + 1] += 1; } } } 减法 高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。\n因为要考虑到小数减大数的情况，所以用此函数来判断\nbool compare(int a[], int b[]) { int i, j; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (j = LEN - 1; j \u0026gt;= 1; --j) if (b[j] != 0) break; if (i \u0026gt; j) { return 0; } else if (i \u0026lt; j) { return 1; } else { for (int p = i; p \u0026gt;= 0; --p) { if (a[p] == b[p]) continue; if (a[p] \u0026gt; b[p]) return 0; else return 1; } } return 0; } //高精度减法 void sub(int* a, int* b, int* c) { flag = compare(a, b);//判断是否是小数减大数  if (flag) {//如果是  putchar(\u0026#39;-\u0026#39;);//则输出负号  sub(b, a, c);//按照大数减小数计算  flag = 0; return; } clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] += a[i] - b[i]; if (c[i] \u0026lt; 0) { c[i] += 10; c[i + 1] -= 1; } } } 乘法 高精度*低精度 如果是高精度与低精度相乘的话，就没必要使用高精度乘法\nvoid mul(int a[], int b, int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; ++i) { c[i] += a[i] * b;//每位都乘低精度  if (c[i] \u0026gt; 9) { c[i + 1] += c[i] / 10; c[i] %= 10; } } } 高精度*高精度 高精度与高精度相乘也是模拟了手写计算乘法的方式\n//高精度乘法 void mul(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和  for (int j = 0; j \u0026lt;= i; j++) { c[i] += a[j] * b[i - j]; } if (c[i] \u0026gt; 9) { c[i + 1] = c[i] / 10; c[i] %= 10; } } } 除法 //判断长度 inline bool greater_eq(int a[], int b[], int last_dg, int len) { if (a[last_dg + len] != 0) return true; for (int i = len - 1; i \u0026gt;= 0; --i) { if (a[last_dg + i] \u0026gt; b[i]) return true; if (a[last_dg + i] \u0026lt; b[i]) return false; } return true; } //高精度除法 void div(int a[], int b[], int c[], int d[]) { clean(c); clean(d); int la, lb; for (la = LEN - 1; la \u0026gt; 0; --la) if (a[la - 1] != 0) break; for (lb = LEN - 1; lb \u0026gt; 0; --lb) if (b[lb - 1] != 0) break; if (lb == 0) { puts(\u0026#34;除数为零，错误\u0026#34;); return; } for (int i = 0; i \u0026lt; la; ++i) d[i] = a[i]; for (int i = la - lb; i \u0026gt;= 0; --i) { while (greater_eq(d, b, i, lb)) { for (int j = 0; j \u0026lt; lb; ++j) { d[i + j] -= b[j]; if (d[i + j] \u0026lt; 0) { d[i + j + 1] -= 1; d[i + j] += 10; } } c[i] += 1; } } } 测试 int main() { flag = 0; read(a); read(b); add(a, b, c); print(c); sub(a, b, c); print(c); mul(a, b, c); print(c); div(a, b, c, d); print(c); print(d); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/","summary":"\u003cp\u003eC/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\u003c/p\u003e","title":"高精度计算"},{"content":"引入 例题hdu1097\n这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\n{% folding green, 点击展开 %}\nlong long fastPower(long long base, long long power){ long long ans = 1; for(int i = 0; i \u0026lt; power; i++){ ans *=base; } return ans % 10; } {%endfolding%}\n那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？\nint fastPower(long long base, long long power){ int ans = 1; base %= 10; for(int i = 0; i \u0026lt; power; i++){ ans *= base; if(ans \u0026gt; 9) ans %= 10; } return ans; } 结果同样，如果数据过大，还是会超时。\n快速幂 {% folding green, 取模的运算法则 %}\n$(a+b) mod M = (amodM + bmodM)modM$\n$(a-b)modM = (amodM - bmodM)modM$\n$(a*b)modM = (amodM * bmodM)modM$\n{% endfolding %}\n 入门 快速幂算法可以高效快速的算出$a^n$。\n下面举一个例子\n如果计算$2^{10}$\n$2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\n尽量将指数变小，如下\n$2^{10} = (2*2)^5 = 4^5$\n此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。\n那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样\n$2^{10} = 4^4*4^1$\n将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作：\n$2^{10} = 16^2*4^1$\n将指数再次缩小一半\n$2^{10} = 256^1*4^1$\n此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，得到的结果是变化过程中所有指数为奇数时的底数的乘积\n初步实现 用代码实现上面的算法：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) { power -= 1; result = result * base % 10; power /= 2; base = base * base % 10; } else { power /= 2; base = base * base % 10; } } return result % 10; } 优化 1.由于if、else中有重复语句\npower /= 2; base = base * base % 10; 2.且在整形运算中\npower -=1; power /=2; 可以压缩成下面一句\npower /=2;  于是代码就可以压缩成以下这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) result = result * base % 10; power /= 2; base = base * base % 10; } return result % 10; } 再次优化 在C/C++中可以利用更快位运算来代替一些计算，例如\npower % 2 == 1; power \u0026amp; 1 == 1;//位运算 power /=2; power \u0026gt;\u0026gt;= 1;//位运算 于是代码就变成了这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power \u0026amp; 1) result = result * base % 10; power \u0026gt;\u0026gt;= 1; base = base * base % 10; } return result % 10; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/","summary":"\u003ch2 id=\"引入\"\u003e引入\u003c/h2\u003e\n\u003cp\u003e例题\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1097\"\u003ehdu1097\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\u003c/p\u003e\n\u003cp\u003e{% folding green, 点击展开 %}\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efastPower\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e base, \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e power){\n    \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e power; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n        ans \u003cspan style=\"color:#f92672\"\u003e*=\u003c/span\u003ebase;\n    }\n    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e{%endfolding%}\u003c/p\u003e","title":"快速幂"},{"content":"STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\n容器 使用容器时要在头文件中引入\n序列式容器 序列的元素的位置是由进入容器的时间和地点决定的\nvector vector简单点说就是一个动态数组，vector实现动态增长，当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间。\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; void PrintVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //初始化 void test01() { vector\u0026lt;int\u0026gt; v1; //默认构造  int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v2(arr, arr + sizeof(arr) / sizeof(int)); vector\u0026lt;int\u0026gt; v3(v2.begin(), v2.end()); vector\u0026lt;int\u0026gt; v4(v3); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //常用赋值操作 void test02() { int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); //成员方法  vector\u0026lt;int\u0026gt; v2; v2.assign(v1.begin(), v1.end()); //重载=  vector\u0026lt;int\u0026gt; v3; v3 = v2; int arr1[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v4(arr1, arr1 + sizeof(arr1) / sizeof(int)); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); cout \u0026lt;\u0026lt; \u0026#34;---------------\u0026#34; \u0026lt;\u0026lt; endl; //交换  v4.swap(v1); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //大小操作 void test03() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; if (v1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } PrintVector(v1); v1.resize(2); PrintVector(v1); v1.resize(6, 1); //不写默认零  PrintVector(v1); for (int i = 0; i \u0026lt; 10000; i++) { v1.push_back(i); } cout \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; //长度、大小  cout \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; //容量 } //vector存取数据 void test04() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;front: \u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; //第一个元素  cout \u0026lt;\u0026lt; \u0026#34;back: \u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; //最后一个元素 } //插入和删除 void test05() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(20); //头插法  v.insert(v.begin(), 30); //尾插法  v.insert(v.end(), 40); PrintVector(v); v.insert(v.begin() + 2, 100); //插到第二个位置  //vector支持随机访问  //支持数组下标，一般都支持随机访问  //迭代器可以直接+-操作  PrintVector(v); //删除  v.erase(v.begin()); PrintVector(v); v.erase(v.begin() + 1, v.end()); PrintVector(v); v.clear(); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } //巧用swap缩减空间 void test06() { //vector添加元素 自动增长 那么，删除元素的时候，会自动减少吗  vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; //收缩空间  vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; PrintVector(v); } void test07() { //reserve预留空间 resize区别  int num = 0; int* address = NULL; vector\u0026lt;int\u0026gt; v; v.reserve(100000); //预先分配  for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (address != \u0026amp;v[0]) { num++; } } cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; //如果你知道容器大概需要的空间，预先分配空间，可以减少时间浪费吗，提高程序运行效率 } int main() { //test01();  //test02();  //test03();  //test04();  //test05();  //test06();  test07(); return 0; } deque deque表示双端队列，即可以从前端或者后端这两端进行数据的插入和删除\n 分段连续的内存空间 支持随机访问 指定位置插入，会引起数据移动  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;deque\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; void PrintDeque(deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } //初始化 void test01() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2(10, 5); deque\u0026lt;int\u0026gt; d3(d2.begin(), d2.end()); deque\u0026lt;int\u0026gt; d4(d3); //打印  PrintDeque(d4); cout \u0026lt;\u0026lt; endl; } //赋值、大小操作 void test02() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2; deque\u0026lt;int\u0026gt; d3; d1.assign(10, 5); d2.assign(d1.begin(), d1.end()); //迭代器指定区间赋值  d3 = d2; //等号赋值  d1.swap(d2); //交换两个空间的元素  if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } d1.resize(5); //有十个，后五个扔掉 } //插入和删除 void test03() { deque\u0026lt;int\u0026gt; d1; d1.push_back(100); d1.push_front(200); d1.push_back(300); d1.push_back(400); d1.push_front(500); //500 200 100 300 400  PrintDeque(d1); int val = d1.front(); //拿到第一个数据  d1.pop_front(); //删除第一个，无返回值  val = d1.back(); d1.pop_back(); //删除最后一个元素 } int main() { //test01();  //test02();  test03(); return 0; } list  双向链表 链表是由一系列节点组成的，节点包括两个域，一个数据域，一个指针域。 链表内存是非连续的，添加删除元素 时间复杂度是常数项 不需要移动元素 链表需要额外空间保留节点关系 不支持随机访问，故不能使用算法提供的sort()来进行排序，但可以调用其成员方法  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;using namespace std; //初始化 void test01() { list\u0026lt;int\u0026gt; l1; list\u0026lt;int\u0026gt; l2(10, 10); list\u0026lt;int\u0026gt; l3(l2); list\u0026lt;int\u0026gt; l4(l3.begin(), l3.end()); //打印  for (list\u0026lt;int\u0026gt;::iterator it = l4.begin(); it != l4.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test02() { list\u0026lt;int\u0026gt; l; l.push_back(100); l.push_front(200); l.insert(l.begin(), 300); l.insert(l.end(), 200); list\u0026lt;int\u0026gt;::iterator it = l.begin(); it++; l.insert(it, 500); //删除  //l.pop_back();  //l.pop_front();  //l.erase(l.begin(), l.end());  l.remove(200); //删除匹配的所有值  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test03() { list\u0026lt;int\u0026gt; l; l.assign(10, 10); list\u0026lt;int\u0026gt; l2; l2 = l; list\u0026lt;int\u0026gt; l3; l3.swap(l); } //反转 void test04() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(i); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.reverse(); //容器元素反转  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } bool Mycompare(int val1, int val2) { return val1 \u0026gt; val2; } //排序 void test05() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(rand() % 10); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.sort(); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小  l.sort(Mycompare); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //算法sort 只支持可随机访问的容器 链表没有  //list的sort是自己的成员函数不是算法 } int main() { //test01();  //test02();  //test04();  test05(); return 0; } queue  先进先出 不提供迭代器，不能遍历，不支持随机访问 push 入队（队尾） pop 出队（队头）  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;queue\u0026gt;using namespace std; void test01() { queue\u0026lt;int\u0026gt; q;//创建队列  q.push(10); q.push(20); q.push(30); q.push(40); cout \u0026lt;\u0026lt; \u0026#34;队尾元素: \u0026#34; \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; //输出顺序 10,20,30,40 \twhile (q.size() \u0026gt; 0){ cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//输出队头 \tq.pop();//删除队头 \t} } int main() { test01(); return 0; } stack  先进后出 push 压栈 pop 出栈 栈不提供迭代器，不能遍历，不支持随机访问，只能通过top从栈顶获取和删除元素  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;stack\u0026gt;using namespace std; void test01(){ //初始化 \tstack\u0026lt;int\u0026gt; s1; stack\u0026lt;int\u0026gt; s2(s1); //stack操作 \ts1.push(10); s1.push(20); s1.push(30); s1.push(100); cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; s1.pop();//删除栈顶元素  cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; //打印栈容器数据 \twhile (!s1.empty()) { cout \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; s1.pop(); } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size:\u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } 关联式容器 容器的规则是固定的，与元素进入容器的时间和地点无关\nset/multiset set表示集合，集合是存储排序键的关联式容器，且每个键值都是唯一的，可以插入或删除但是不能更改\n 以红黑树为底层机制，查找效率非常好 set中不允许重复元素，multiset中允许重复元素 不可通过迭代器改变set元素的值，会破坏set组织  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt;using namespace std; //仿函数 类 class Mycompare { public: bool operator()(int v1, int v2) const { //此处注意，要加const限定符  return v1 \u0026gt; v2; } }; //set容器初始化 void test01() { set\u0026lt;int, Mycompare\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); //自动进行排序，默认从小到大  for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小排序怎么办？ #if 0//赋值 set\u0026lt;int\u0026gt; s2; s2 = s1; //删除 s1.erase(s1.begin()); s1.erase(6); for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; s2.clear(); cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; #endif } //set查找 void test02() { //实值  set\u0026lt;int\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); set\u0026lt;int\u0026gt;::iterator ret = s1.find(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于等于的元素  ret = s1.lower_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于的元素  ret = s1.upper_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //equal_range 返回lower_bound和upper_bound的值  pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, set\u0026lt;int\u0026gt;::iterator\u0026gt; pret = s1.equal_range(4); if (pret.first == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.first \u0026lt;\u0026lt; endl; } if (pret.second == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.second \u0026lt;\u0026lt; endl; } } class Person { public: Person(int id, int age) : id(id), age(age){}; int id; int age; }; class PersonCompare { public: bool operator()(const Person\u0026amp; p1, const Person\u0026amp; p2) const { return p1.age \u0026gt; p2.age; } }; void test03() { set\u0026lt;Person, PersonCompare\u0026gt; sp; Person p1(10, 20), p2(30, 40), p3(50, 60); sp.insert(p1); sp.insert(p2); sp.insert(p3); for (set\u0026lt;Person, PersonCompare\u0026gt;::iterator it = sp.begin(); it != sp.end(); it++) { cout \u0026lt;\u0026lt; (*it).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).age \u0026lt;\u0026lt; endl; } //查找  Person p4(90, 20); set\u0026lt;Person, PersonCompare\u0026gt;::iterator ret = sp.find(p4); //可找到，对应p1，按照age排序就按照age查找  if (ret == sp.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (*ret).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*ret).age \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对组 将两个值合并成一个值\n#define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;using namespace std; void test01() { pair\u0026lt;int, int\u0026gt; pair1(10, 20); cout \u0026lt;\u0026lt; pair1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair1.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair2 = make_pair(10, \u0026#34;aaa\u0026#34;); cout \u0026lt;\u0026lt; pair2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair2.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair3 = pair2; cout \u0026lt;\u0026lt; pair3.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair3.second \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } map/multimap  map与set区别，map具有键值和实值 所有元素根据键值自动排序 pair的第一个元素成为键值，第二个元素成为实值 map也是以红黑树为底层实现机制 不可以通过map的迭代器修改map键值，键值关系到容器内元素的排列顺序，任意改变键值会破坏容器的排列规则，但是可以改变实值 multimap允许相同键值存在，map不允许  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; //map初始化 void test01() { //map容器模板参数：第一个参数key的类型，第二个参数value的类型  map\u0026lt;int, int\u0026gt; m; //插入数据 pair.first 对应key，pair.second 对应value  //第一种  pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, bool\u0026gt; ret = m.insert(pair\u0026lt;int, int\u0026gt;(10, 10)); //放入匿名对象  if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第二种  ret = m.insert(make_pair(10, 20)); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第三种  m.insert(map\u0026lt;int, int\u0026gt;::value_type(30, 30)); //第四种  m[40] = 40; m[10] = 20; //如果key不存在，创建pair并插入  //如果key存在，修改value实值  //打印  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;m[60] = \u0026#34; \u0026lt;\u0026lt; m[60] \u0026lt;\u0026lt; endl; //访问一个不存再的key，那么map会将这个key插入到map中，对应的value默认为零  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } } class MyKey { public: MyKey(int index, int id) : index(index), id(id) {} int index; int id; }; struct mycompare { bool operator()(MyKey key1, MyKey key2) const { return key1.index \u0026gt; key2.index; } }; void test02() { map\u0026lt;MyKey, int, mycompare\u0026gt; m; //需要排序，自定义类型，给定一个排序方法  m.insert(make_pair(MyKey(1, 2), 2)); m.insert(make_pair(MyKey(3, 4), 2)); for (map\u0026lt;MyKey, int, mycompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; it-\u0026gt;first.index \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first.id \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } //equal_range void test03() { map\u0026lt;int, int\u0026gt; m; m.insert(make_pair(1, 4)); m.insert(make_pair(2, 5)); m.insert(make_pair(3, 6)); pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, map\u0026lt;int, int\u0026gt;::iterator\u0026gt; ret = m.equal_range(2); if (ret.first-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到lower_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } if (ret.second-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到upper_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对比    容器 vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言：是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快   元素安插移除 尾端 头尾两端 任何位置 - - - -    迭代器 可以理解为指针，对指针的操作基本可以对迭代器操作，但实际上，迭代器是一个类，这个类封装了一个指针\n算法 通过有限的步骤解决问题的方法\n","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/stl/","summary":"\u003cp\u003eSTL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\u003c/p\u003e","title":"STL"},{"content":"“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\n并查集可以总结为三句话：\n “并”的意思是把两个有某些关系的结点并到一起 “查”的意思是查找一个结点的根节点 “并”的时候需要用到“查”  初始化 int father[len];//此数组定义在全局  void Init(int n){ for (int i = 0; i \u0026lt; len; ++i) {//len为结点总数 \tfather[i] = i; } } 查 初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点）\n假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.\n如图即是对应关系\n//查（非递归算法） int FindRoot(int x){ r = x; while(r != father[r]){//自己是自己的爹即是找到了根结点  r = father[r]; } return r; } //递归算法 int FindRoot(int x){ return x == father[x] ? x : FindRoot(father[x]); } 并 如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作；\n相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作\n//并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(x != y){ parent[y] = x; } } 例题 hdu1213\n问题描述 今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。 此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。\n例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上 所以伊格纳修斯至少需要 2 张桌子。\n输入 输入以表示测试用例数的整数 T（1\u0026lt;=T\u0026lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1\u0026lt;=N，M\u0026lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。\n输出 对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。\n示例输入 2 5 3 1 2 2 3 4 5 5 1 2 5 示例输出 2 4 这道题用一句话概括就是在一张桌子上，每个人都要有认识的人\n代码 #include\u0026lt;stdio.h\u0026gt; int father[1001]; int find(int x) { return father[x] == x ? x : find(father[x]); } void merge (int x, int y) { x = find(x); y = find(y); if (x != y) { a[x] = y; } } int main(int argc, char const *argv[]) { int t, m, n, x, y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } for (int i = 0; i \u0026lt; m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); merge(x, y); } for (int i = 1; i \u0026lt;= n; ++i) { if (father[i] == i) { cnt++; } } printf(\u0026#34;%d\\n\u0026#34;, cnt); } return 0; } 优化 合并的优化 如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免\n不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度\n初始化代码如下\nint father[len]; int height[len]; for(int i = 0; i \u0026lt; len; i++){ father[i] = i; height[i] = 1;//初始深度为1 } //并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(height[x] == height[y]){//此处无需判断x，y根结点是否一致 \theight[x] = height[x] + 1; father[y] = x; } else if(height[x] \u0026gt; height [y]){ father[y] = x; } else { father[x] = y; } } 查询的优化 //对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。 //这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果 int find (int x){ if(x != parent[x]){ father[x] = find(father[x]); } return father[x]; } 此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并\n但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下：\nint Find(int x){ int r = x; while(father[r] != r){//找到根结点 \tr = father[r]; } int i = x; int j; while(i != r){//循环修改这条路径上的根结点 \tj = father[i];//j记录元素i此时的父亲 \tfather[i] = r;//将i的父亲改为根结点 \ti = j;//i记录为要“查询”的结点  } return r; } 经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$\n总结  并查集的思想很精妙，用一个数组表示了整片森林 优化的关键在于记录每棵树的结点数量，根据结点关系合并 ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6%e6%9f%a5%e9%9b%86.jpg\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\u003c/p\u003e","title":"并查集"},{"content":"树的遍历 上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。\n以下是树的非递归遍历方法：\n偷个懒用一下C++写，头文件要加上\n#include\u0026lt;stack\u0026gt;先序遍历 //先序遍历 void PreorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;先序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; while(t || !s.empty()){ while(t){ cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//拿到这个结点就直接打印 \ts.push(t); t = t-\u0026gt;left; } if(!s.empty()){ t = s.top(); s.pop();\tt = t-\u0026gt;right; } } cout \u0026lt;\u0026lt; endl; } 中序遍历 //中序非递归遍历 void InorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;中序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; while(t || !s.empty()){ while(t){ s.push(t); t = t-\u0026gt;left; } if(!s.empty()){ t = s.top(); s.pop(); cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//遍历完左子树后再打印 \tt = t-\u0026gt;right; } } cout \u0026lt;\u0026lt; endl; } 后序遍历 //后序非递归遍历 void PostorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;后序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; stack\u0026lt;PTree\u0026gt; s2; while(t || !s.empty()){ while(t){ s.push(t); s2.push(t); t = t-\u0026gt;right; } if(!s.empty()){ t = s.top(); s.pop(); t = t-\u0026gt;left; } } while(!s2.empty()){ t = s2.top(); s2.pop(); cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 后序遍历与先序遍历的顺序相反，那么可以先遍历右子树，也就是说将先序遍历的顺序逆过来压入s2中，，然后再根据栈的后进先出的特点，一一出栈。\n","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/","summary":"\u003ch3 id=\"树的遍历\"\u003e树的遍历\u003c/h3\u003e\n\u003cp\u003e上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。\u003c/p\u003e\n\u003cp\u003e以下是树的非递归遍历方法：\u003c/p\u003e","title":"树（二）"},{"content":"树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。\n对于非空树：\n1.有且仅有一个称之为根的结点。\n2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。\n基本术语  结点的度（Degree）：结点的子树个数 树的度：树的所有结点最大的度 叶结点（Leaf）：度为0的结点 父结点（Parent）：有子树的结点是其子树的根结点的父结点 子结点（Child）：若A结点是B结点的父结点，则称B结点为A结点的子结点；子结点也称孩子结点 兄弟结点（Sibling）：具有同一父结点的个节点彼此是兄弟结点 路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，n3\u0026hellip;nk。路径所包含边的个数为路径的长度 祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点 子孙节点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙 结点的层次（Level）：规定根结点在第一层，其它任意节点层数是父结点层数加一 树的深度（Depth）：树中所有结点中的最大层次  二叉树 二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。\n性质 1.二叉树的第i层的最大节点数为2.深度为k的二叉树最大结点数为3.二叉树的终端节点数为n0，度数为2 的结点数为n2，则n0 = n2 +1\n特殊的,\n如果一个深度为 k 的二叉树，正好有 个结点，那么这棵树就被称为满二叉树。\n如图所示：\n如果一个二叉树，只有当第 i 层已经达到了的最大值以后，才能往第 i + 1 层自左向右地添加结点，这棵树就被称为完全二叉树。\n那么，根据二叉树的性质二可得，具有n个结点的完全二叉树的深度为 $$ [log_2(n)]+1 $$\n如图所示：\n二叉树的建立 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt; typedef struct Tree { int data; struct Tree *left; struct Tree *right; } BiTree, *PTree;  //创造一个结点 PTree CreatNode(int value) { PTree p = (PTree)malloc(sizeof(BiTree)); p-\u0026gt;data = value; p-\u0026gt;left = p-\u0026gt;right = NULL; return p; } //插入结点且排序，不存在有相同值的结点 PTree AddNode(int value, PTree p) { if (p == NULL) { return CreatNode(value); } if (value == p-\u0026gt;data) { return p; } if (value \u0026lt; p-\u0026gt;data) { if (p-\u0026gt;left == NULL) { p-\u0026gt;left = CreatNode(value); return p-\u0026gt;left; } else { return AddNode(value, p-\u0026gt;left); } } else { if (p-\u0026gt;right == NULL) { p-\u0026gt;right = CreatNode(value); return p-\u0026gt;right; } else { return AddNode(value, p-\u0026gt;right); } } } 遍历二叉树 递归遍历左子树、根节点、递归遍历右子树\n先序遍历 输出根节点，递归遍历左子树，在递归遍历右子树\nvoid Preorder(PTree p) { if (p != NULL) { printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); Preorder(p-\u0026gt;left); Preorder(p-\u0026gt;right); } } 中序遍历 递归遍历左子树，输出根节点，在递归遍历右子树\nvoid Midorder(PTree p) { if (p != NULL) { Midorder(p-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); Midorder(p-\u0026gt;right); } } 后序遍历 递归遍历左子树，再递归遍历右子树，输出根节点\nvoid Postorder(PTree p) { if (p != NULL) { Postorder(p-\u0026gt;left); Postorder(p-\u0026gt;right); printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); } } 求二叉树的深度 int TreeHeight(PTree p) { int l, r; if (p == NULL) { return 0; } else { l = TreeHeight(p-\u0026gt;left); r = TreeHeight(p-\u0026gt;right); return (l \u0026gt; r ? l : r) + 1; } }  int main(int argc, char const *argv[]) {//测试 \tint value; PTree p = NULL; printf(\u0026#34;Please enter 10 numbers:\u0026#34;); for (int i = 0; i \u0026lt; 10; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;value); if (p == NULL) { p = CreatNode(value); } else { AddNode(value, p); } } Preorder(p); printf(\u0026#34;\\n\u0026#34;); Midorder(p); printf(\u0026#34;\\n\u0026#34;); Postorder(p); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;The depth of the binary tree is：%d\\n\u0026#34;, TreeHeight(p)); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/","summary":"\u003cp\u003e树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。\u003c/p\u003e\n\u003cp\u003e对于非空树：\u003c/p\u003e\n\u003cp\u003e1.有且仅有一个称之为根的结点。\u003c/p\u003e\n\u003cp\u003e2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。\u003c/p\u003e","title":"树（一）"},{"content":"引入 栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。\n顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。\n栈 定义 栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图\n线性表有两种存储形式，顺序表储存和链表储存。\n顺序栈 #include\u0026lt;stdlib.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Stack{ elem* base;//栈基 \telem* top;//栈顶 \tint stacksize; //栈的容量 }Stack; 创建一个栈 Status CreatStack(Stack* s){ s-\u0026gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base; s-\u0026gt;stacksize = MAXSIZE; return OK; } 入栈 Status PushStack(Stack* s, elem e){ if(s-\u0026gt;top - s-\u0026gt;base \u0026gt;= s-\u0026gt;stacksize){ s-\u0026gt;base = (elem*)realloc(s-\u0026gt;base, sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base + s-\u0026gt;stacksize; s-\u0026gt;stacksize +=MAXSIZE;\t} *(s-\u0026gt;top) = e; s-\u0026gt;top++; return OK; } 出栈 Status PopStack(Stack*s,elem *e){ if(s-\u0026gt;top == s-\u0026gt;base) return ERROR; *e = *--(s-\u0026gt;top); return OK; } 清空 Status CleanStack(Stack* s){ s-\u0026gt;top = s-\u0026gt;base; return OK; } 销毁 Status DestroyStack(Stack* s){ free(s-\u0026gt;base); s-\u0026gt;top = s-\u0026gt;base = NULL; s-\u0026gt;stacksize = 0; return OK; } 获取当前容量 int GetSize(Stack* s){ return s-\u0026gt;stacksize; } 链表栈 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Node//定义链表结构 { elem data;//数据域 \tstruct Node* next;//指针域 }Node, * LNode; typedef struct Stack { LNode top; LNode base; }Stack,*Pstack; 创建一个栈 Pstack CreatStack(){ Pstack stack = (Pstack)malloc(sizeof(Stack)); if(stack == NULL){ return NULL; } stack-\u0026gt;top = stack-\u0026gt;base = NULL; return stack; } 入栈 Status PushStack(Pstack *stack, elem e){ Node* p = (LNode)malloc(sizeof(Node)); if(p == NULL){ return ERROR; } p-\u0026gt;data = e; p-\u0026gt;next = (*stack)-\u0026gt;top; (*stack)-\u0026gt;top = p; return OK; } 出栈 Status PopStack(Pstack *stack){ Node* p = (*stack)-\u0026gt;top; if(p == (*stack)-\u0026gt;base){ printf(\u0026#34;栈已空\u0026#34;); return ERROR; } (*stack)-\u0026gt;top = p-\u0026gt;next; printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); free(p); return OK; } 判断是否为空 Status IsEmptyStack(Pstack stack){ return (stack-\u0026gt;top == stack-\u0026gt;base); } 清空 Status CleanStack(Pstack *stack){ Node*p = (*stack)-\u0026gt;top; while(p){ (*stack)-\u0026gt;top = p-\u0026gt;next; free(p); p = (*stack)-\u0026gt;top; } return OK; } 销毁 Status DestroyStack(Pstack *stack){ CleanStack(stack); free(*stack); return OK; } void test(){//测试 \tPstack stack = CreatStack(); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); for (int i = 0; i \u0026lt; 10; ++i){ PushStack(\u0026amp;stack, i); } printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); /*出栈*/ // for (int i = 0; i \u0026lt; 10; ++i){ \t// PopStack(\u0026amp;stack); \t// } \t// printf(\u0026#34;%\\n\u0026#34;); \t// printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); \t/*清空*/ CleanStack(\u0026amp;stack); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); printf(\u0026#34;%p\\n\u0026#34;,stack); DestroyStack(\u0026amp;stack); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); printf(\u0026#34;%p\\n\u0026#34;,stack); } 栈与递归 递归：函数自己调用自己\n 函数定义是递归的——斐波那契数列 数据结构是递归的——单链表、树 问题解法是递归的——汉诺塔、  函数的调用 函数被调用之前，\n 系统需要将实参以及返回地址传递给被调用的函数进行保存 将被调用的函数的局部变量分配到储存区 将控制转移到被调用的函数的入口  从被调用函数返回到调用函数之前，\n 保存被调用函数的计算结果 释放被调用函数中的数据区 依照被调用函数的保存的返回地址将控制转移至此  队列 定义 队列也是一种重要的线性结构。与栈相同，实现一个队列也需要顺序表或者链表作为基础。但是与栈不同的是，队列是一种先进先出（FIFO）的线性表。其要求所有的数据从队列的一段进入，从队列的另一端离开。在队列中，允许插入数据的一端叫做队尾（rear），允许数据离开的一端叫做队头（front）。如图所示\n链队列 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct QNode { elem data;\t//数据域 \tstruct QNode*next;\t//指针域 } QNode, *PNode; typedef struct { PNode front;\t//队头指针 \tPNode rear;\t//队尾指针 } LinkQueue; 创建一个队列 Status CreatQueue(LinkQueue *q) { q-\u0026gt;front = q-\u0026gt;rear = (PNode)malloc(sizeof(QNode)); if (q-\u0026gt;front == NULL) { return ERROR; } q-\u0026gt;front-\u0026gt;next = NULL; return OK; } 入队 Status PushQueue(LinkQueue *q, elem e) { QNode *p = (PNode)malloc(sizeof(QNode)); if (p == NULL) { return ERROR; } p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return OK; } 出队 Status PopQueue(LinkQueue *q) { if (q-\u0026gt;front == q-\u0026gt;rear) { return ERROR; } QNode* p = q-\u0026gt;front-\u0026gt;next; printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if (q-\u0026gt;rear == p) q-\u0026gt;rear = q-\u0026gt;front; return OK; } 销毁 Status DestroyQueue(LinkQueue *q) { while (q-\u0026gt;front) { q-\u0026gt;rear = q-\u0026gt;front-\u0026gt;next; free(q-\u0026gt;front); q-\u0026gt;front = q-\u0026gt;rear; } return OK; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"引入 栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。\n顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。\n栈 定义 栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图\n线性表有两种存储形式，顺序表储存和链表储存。\n顺序栈 #include\u0026lt;stdlib.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Stack{ elem* base;//栈基 \telem* top;//栈顶 \tint stacksize; //栈的容量 }Stack; 创建一个栈 Status CreatStack(Stack* s){ s-\u0026gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base; s-\u0026gt;stacksize = MAXSIZE; return OK; } 入栈 Status PushStack(Stack* s, elem e){ if(s-\u0026gt;top - s-\u0026gt;base \u0026gt;= s-\u0026gt;stacksize){ s-\u0026gt;base = (elem*)realloc(s-\u0026gt;base, sizeof(elem) * MAXSIZE); if(!","title":"栈和队列"},{"content":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。\n每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。\n在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。\n头指针和头节点 基本概念 头指针 通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。\n头节点 在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。\n[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。\n空链表 单链表 引入头结点的优势 链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。\n优势1：第一个位置的插入删除特别方便 若使用头结点，则第1个位置的插入和删除都是对p—\u0026gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：\n插入操作如下  p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s;  删除操作如下  p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q);   若没有头结点，在第1个位置插入或删除时，需要动头指针。\n插入操作如下  判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。  删除操作如下  判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—\u0026gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q); return PtrL  优势2：统一空表和非空表的处理 若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。\n若不使用头结点，当表非空时，头指针指向第1个结点的地址，即LNode类型，但是对于空表，头指针指向的是NULL*，此时空表和非空表的操作是不一致的。\n链表的建立 有头结点链表的建立 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct LNode{ elem data; //数据域  struct LNode* next; //指针域 }Node, *List;  List HeadCreatList(int n){//带头结点_头插法  Node *s; List head = (List)malloc(sizeof(Node));//生成头结点  head-\u0026gt;next = NULL; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; s-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = s;//头结点的指针域next指向s结点，使得s成为结点  } return head; } List TailCreatList(int n){//带头结点_尾插法  Node *s, *r; List head = (List)malloc(sizeof(Node)); head-\u0026gt;next = NULL; r = head; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; r-\u0026gt;next = s; r = s; } if(r-\u0026gt;next != NULL){ r-\u0026gt;next = NULL; } return head; }  下面这个是建立头结点与建立链表分离\nList CreatHNode(){//建立头结点  Node *s, *r; List head = (List)malloc(sizeof(Node)); head-\u0026gt;next = NULL; return head; } Status HeadList(List head, int n){//头插法  Node *s; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; s-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = s;//头结点的指针域next指向s结点，使得s成为结点  } return OK; } Status TailList(List head, int n){//尾插法  Node *s, *r; r = head; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; r-\u0026gt;next = s; r = s; } if(r-\u0026gt;next != NULL){ r-\u0026gt;next = NULL; } return OK; } 为了方便测试，先写出遍历并打印链表的函数\nStatus PrintList(List head){//打印链表数据  Node *t = head-\u0026gt;next; while (t != NULL){ printf(\u0026#34;%d \u0026#34;,t-\u0026gt;data); t = t-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); return OK; } void test(){//测试  List head; //head = HeadCreatList(10);  head = TailCreatList(10); //head = CreatHNode();  //HeadList(head, 10);  //TailList(head, 10);  PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 无头结点链表的建立 List HeadCreatList(int n){//头插法 \tList head = NULL; Node *p; while(n--){ p = (List)malloc(sizeof(Node)); p-\u0026gt;data = n; if(head == NULL){ p-\u0026gt;next = NULL; head = p; } else{ p-\u0026gt;next = head; head = p; } } return head; } List TailCreatList(int n){//尾插法 \tList head = NULL; Node *p, *q; while(n--){ p = (List)malloc(sizeof(Node)); p-\u0026gt;data = n; if(head == NULL){ head = p; } else{ q-\u0026gt;next = p; } p-\u0026gt;next = NULL; q = p; } return head; } 为了测试，先写出打印链表的函数\nStatus PrintList(List head){//打印链表元素 \tif(head == NULL){ return ERROR; } Node *t = head; while(t != NULL){ printf(\u0026#34;%d\u0026#34;, t-\u0026gt;data);\tt = t-\u0026gt;next; } printf(\u0026#34;%d\u0026#34;); return OK; } void test(){//测试 \tList head; //head = HeadCreatList(10); \thead = TailCreatList(10); PrintList(head); return ; } 链表的各个功能的实现（有头结点） 上面介绍了有无头结点对于功能实现的影响，接下来先使用有头结点的链表进行\n链表元素的添加 //链表添加元素（插头） Status HeadInsertList(List head,Node a){ Node *p = (List)malloc(sizeof(Node)); p-\u0026gt;data = a.data; p-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = p; return OK; } //链表添加元素（插尾） Status TailInsertList(List head,Node a){ Node *p, *t, *s; t = head-\u0026gt;next; p = (List)malloc(sizeof(Node)); p-\u0026gt;data = a.data; while(t!= NULL){ s = t; t = t-\u0026gt;next; } s-\u0026gt;next = p; p-\u0026gt;next = NULL; return OK; } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); //HeadInsertList(head, a);  TailInsertList(head, a); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的插入 //链表的插入（插在之前） Status InsertIndexFront(List head,int i){ Node *p, *q, *r; int j = 0; p = head; while(p \u0026amp;\u0026amp; j \u0026lt; i){ r = p; p = p-\u0026gt;next; j++; } if(!p || j\u0026gt;i){ return ERROR; } q = (List)malloc(sizeof(Node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q-\u0026gt;data); q-\u0026gt;next = p; r-\u0026gt;next = q; return OK; } //链表的插入（插在之后） Status InsertIndexBack(List head,int i){ Node *p,*q; int j = 0; p = head; while(p \u0026amp;\u0026amp; j \u0026lt; i){ p = p-\u0026gt;next; j++; } if(!p || j \u0026gt; i){ return ERROR; } q = (List)malloc(sizeof(Node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q-\u0026gt;data); q-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = q; return OK; } oid test(){//测试  List head; head = HeadCreatList(10); PrintList(head); InsertIndexFront(head,2); //InsertIndexBack(head,2);  PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的查找 //链表元素的查找 elem GetElem(List head, int index){//按序号查找  int j; Node* p; p = head-\u0026gt;next; //p指向第一个数据结点  j = 1; //j为计数器  while (p \u0026amp;\u0026amp; j \u0026lt; index ){ //顺着链表向后扫描，直到p指向第i个元素或p为空  p=p-\u0026gt;next; //p指向下一个结点  j++; //计数器j相应加1  } if (!p || j \u0026gt; index) return -1; //i值不合法i＞n或i\u0026lt;=0  return p-\u0026gt;data;//返回第i个结点的数据域  } elem GetIndex(List head, int e) {//按值查找  //在带头结点的单链表L中查找值为e的元素  Node* p; int index = 0; p = head-\u0026gt;next; while (p \u0026amp;\u0026amp; p-\u0026gt;data!=e){ //顺链域向后扫描，直到p为空或p所指结点的数据域等于e  p=p-\u0026gt;next; //p指向下一个结点  ++index; } if(!p) return -1; //查找失败p为NULL  return index; } void test(){ List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); printf(\u0026#34;%d\\n\u0026#34;,GetElem(head,6)); printf(\u0026#34;%d\\n\u0026#34;,GetIndex(head,6)); system(\u0026#34;pause\u0026#34;); return; } 链表元素的删除 Status DeleteList(List head, int index) {//单链表的删除  //在带头结点的单链表L中，删除第i个位置  Node *p, *q; int j; p = head; j = 0; while((p-\u0026gt;next)\u0026amp;\u0026amp;(j \u0026lt; index - 1)) {//查找第i-1个结点，p指向该结点  p=p-\u0026gt;next; j++; } if (!(p-\u0026gt;next)||(j \u0026gt; index - 1))//当i\u0026gt;n或i\u0026lt;1时，删除位置不合理  return ERROR; q = p-\u0026gt;next; //临时保存被删结点的地址以备释放空间  p-\u0026gt;next = q-\u0026gt;next; //改变删除结点前驱结点的指针域  free(q); //释放被删除结点的空间  return OK; } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); DeleteList(head,4); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的修改 //链表元素的修改 Status ReverseElem(List head, int index,int e){ int j; Node* p; p = head-\u0026gt;next; //p指向第一个数据结点  j = 1; //j为计数器  while (p \u0026amp;\u0026amp; j \u0026lt; index ){ //顺着链表向后扫描，直到p指向第i个元素或p为空  p=p-\u0026gt;next; //p指向下一个结点  j++; //计数器j相应加1  } if (!p || j \u0026gt; index) return ERROR; //i值不合法i＞n或i\u0026lt;=0  p-\u0026gt;data = e; return OK;//返回第i个结点的数据域 } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); ReverseElem(head,4,999); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的清空 //清空链表 Status ClearList(List head) { Node*p,*q; if(head == NULL) return ERROR; p = head-\u0026gt;next; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } head-\u0026gt;next=NULL; return OK; } 链表元素的排序 Status SwapElem(int *i, int *j){//交换数据  int temp = *i; *i = *j; *j = temp; return OK; } void SortList(List head){//冒泡排序  Node* p = NULL; Node* q = NULL; Node* t = NULL; if(head-\u0026gt;next == NULL){ return ; } for ( p = head-\u0026gt;next; p != NULL; p = p-\u0026gt;next){ for ( q = head-\u0026gt;next; q-\u0026gt;next != NULL; q = q-\u0026gt;next){ if(q-\u0026gt;data \u0026gt; q-\u0026gt;next-\u0026gt;data){ SwapElem(\u0026amp;q-\u0026gt;data, \u0026amp;q-\u0026gt;next-\u0026gt;data); } } } } 无头结点链表的功能实现就不在此赘述，所有源码都在Github ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/","summary":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。\n每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。\n在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。\n头指针和头节点 基本概念 头指针 通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。\n头节点 在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。\n[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。\n空链表 单链表 引入头结点的优势 链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。\n优势1：第一个位置的插入删除特别方便 若使用头结点，则第1个位置的插入和删除都是对p—\u0026gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：\n插入操作如下  p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s;  删除操作如下  p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q);   若没有头结点，在第1个位置插入或删除时，需要动头指针。\n插入操作如下  判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。  删除操作如下  判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—\u0026gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q); return PtrL  优势2：统一空表和非空表的处理 若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。","title":"单链表"},{"content":"概念 具有 一对一 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）\n#include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;time.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int Status; typedef int elem; typedef struct Sqlist{ elem *e;//存储空间的及地址  int length;//长度 }Sqlist; 功能的实现 顺序表的初始化 //数组的初始化 Status InitArray(Sqlist *L){ if(L-\u0026gt;e) {//判断指针是否为空  free(L-\u0026gt;e); L-\u0026gt;e = NULL; } L-\u0026gt;e = (elem*)malloc(sizeof(int) * MAXSIZE);//申请capacity大小的空间  if(L-\u0026gt;e == NULL){ printf(\u0026#34;内存分配失败!\\n\u0026#34;);//判断内存分配是否成功  exit(0); } L-\u0026gt;length = 0; return OK; } 元素的添加 //添加元素 Status PushBackArray(Sqlist *L,elem value){ if(L-\u0026gt;e == NULL){ printf(\u0026#34;请初始化顺序表\\n\u0026#34;); return ERROR; } if(L-\u0026gt;length == MAXSIZE) { return ERROR; } L-\u0026gt;e[L-\u0026gt;length] = value; ++L-\u0026gt;length; return OK; } 元素的插入 //插入 Status InsertArray(Sqlist *L,int index,elem value){ if(index \u0026gt; L-\u0026gt;length +1 || index \u0026lt; 1){ return ERROR; } for (int i = L-\u0026gt;length; i \u0026gt;= index; i--) { L-\u0026gt;e[i] = L-\u0026gt;e[i - 1]; } L-\u0026gt;e[index] = value; ++L-\u0026gt;length; return OK; } 元素的查找 //根据位置查找 elem FindByIndex(Sqlist* L,int index){ return L-\u0026gt;e[index]; } //根据值查找 Status FindByValue(Sqlist* L,elem value){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ if(L-\u0026gt;e[i] == value){ return i; } } return -1; } 元素的删除 //根据值删除 Status RemoveByValue(Sqlist* L,elem value){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ if(L-\u0026gt;e[i] == value){ for (; i \u0026lt; L-\u0026gt;length; i++) { L-\u0026gt;e[i - 1] = L-\u0026gt;e[i]; } --L-\u0026gt;length; return OK; } } } //根据位置删除 Status RemoveByIndex(Sqlist* L,int index){ if (index \u0026gt; L-\u0026gt;length + 1 || index \u0026lt; 1) { return ERROR; } for (int i = index; i \u0026lt; L-\u0026gt;length; i++) { L-\u0026gt;e[i - 1] = L-\u0026gt;e[i]; } --L-\u0026gt;length; return OK; } 元素的清空 //清空 Status CleanArray(Sqlist *L){ if(L-\u0026gt;e == NULL) { printf(\u0026#34;未初始化\\n\u0026#34;); return ERROR; } L-\u0026gt;length = 0; return OK; } 线性表的销毁 //销毁 Status FreeArray(Sqlist* L){ if(L-\u0026gt;e != NULL){ free(L-\u0026gt;e); L-\u0026gt;e = NULL; } L-\u0026gt;length = 0; return OK; } 获取当前长度 //长度 int GetLength(Sqlist* L){ if(L-\u0026gt;e == NULL) return -1; return L-\u0026gt;length; } 判断是否为空 //判断是否为空 Status IsEmptyArray(Sqlist *L){ return L-\u0026gt;length = 0; } 顺序表的合并 //合并 Status CombineArray(Sqlist *L1,Sqlist *L2){ if (L1-\u0026gt;length + L2-\u0026gt;length \u0026gt; MAXSIZE) { printf(\u0026#34;空间不足，合并失败\\n\u0026#34;); return ERROR; } for (int i = 0; i \u0026lt; L2-\u0026gt;length; i++) { L1-\u0026gt;e[L1-\u0026gt;length + i] = L2-\u0026gt;e[i]; } L1-\u0026gt;length +=L2-\u0026gt;length; free(L2-\u0026gt;e); L2-\u0026gt;length = 0; return OK; } 顺序表的打印 //打印 void PrintArray(Sqlist* L){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ printf(\u0026#34;%d \u0026#34;,L-\u0026gt;e[i]); } printf(\u0026#34;\\n\u0026#34;); } void test(){//测试  Sqlist L,L2; /******************************/ /********初始化及添加元素********/ /******************************/ InitArray(\u0026amp;L);//初始化顺序表  InitArray(\u0026amp;L2); //srand(time(NULL));  for(int i = 0; i \u0026lt; 10; i++){//赋值  PushBackArray(\u0026amp;L,i); PushBackArray(\u0026amp;L2,i); } printf(\u0026#34;初始化...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /************插入元素***********/ /******************************/ InsertArray(\u0026amp;L,5,100);//插入元素  printf(\u0026#34;插入元素...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /************查找元素***********/ /******************************/ printf(\u0026#34;查找元素...\\n\u0026#34;); printf(\u0026#34;%d \u0026#34;,FindByIndex(\u0026amp;L,10));//根据位置查找  printf(\u0026#34;%d \u0026#34;,FindByValue(\u0026amp;L,4));//根据值查找  /******************************/ /************删除元素***********/ /******************************/ RemoveByIndex(\u0026amp;L,3);//根据位置删除  RemoveByValue(\u0026amp;L,9);//根据值删除  printf(\u0026#34;删除元素...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********合并顺序表**********/ /******************************/ CombineArray(\u0026amp;L,\u0026amp;L2);//合并  printf(\u0026#34;合并顺序表...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********清空顺序表**********/ /******************************/ CleanArray(\u0026amp;L);//清空  printf(\u0026#34;清空顺序表...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********销毁顺序表**********/ /******************************/ FreeArray(\u0026amp;L);//销毁  printf(\u0026#34;销毁顺序表...\\n\u0026#34;); printf(\u0026#34;%d\u0026#34;,PushBackArray(\u0026amp;L,1)); } int main(){ test(); system(\u0026#34;pause\u0026#34;); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","summary":"\u003ch3 id=\"概念\"\u003e概念\u003c/h3\u003e\n\u003cp\u003e具有 \u003cem\u003e一对一\u003c/em\u003e 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define MAXSIZE 100\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define OK 1\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define ERROR 0\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Status;\n\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e elem;\n\n\n\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e Sqlist{\n    elem \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ee;\u003cspan style=\"color:#75715e\"\u003e//存储空间的及地址\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e length;\u003cspan style=\"color:#75715e\"\u003e//长度\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}Sqlist;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"顺序表"},{"content":"数据 所有能够输入到计算机中的去的描述客观事物的符号\n数据元素 数据的基本单位，也称结点或记录\n数据结构 相互之间存在一种或多种特定关系的数据元素的集合\n逻辑结构和存储结构 逻辑结构 数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。\n1.集合 数据元素间除同属于一个集合外，无其他关系 集合中的元素是离散的、无序的、相互之间没有关系的\n2.线性结构 一个对一个  线性表 栈 队列 线性结构像是珠子穿在一根线上，不会分叉，有且只有唯一的开始和结束  3.树形结构 一个对多个 树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支。树枝和树枝之间是不相交的。\n 树  4.图形结构 图形结构就像我们经常见到的地图，任何一个结点都可能和其它结点有关系，就像一张错综复杂的网。\n存储结构 存储结构是数据元素及其关系在计算机中的存储方式。\n1.顺序结构 顺序存储在计算机内的存储位置是连续的，可以快速定位第几个元素的问题。中间不允许有空，所以插入、删除时需要移动大量元素。\n2.链式结构 链式存储就像一个铁链子，一环扣一环才能连在一起。每个结点除了数据域，还有一个指针域，记录下一个元素的存储地址。\n3.散列机构 4.索引结构 算法复杂性 时间复杂度 程序运行所需的时间\n 常数阶 O(1) O(n) O(n²) O(log(n))-二分查找 O(nlogn)-快排  递归时间复杂度 O(T * depth) T是每一次递归的时间复杂度\n最好最坏情况时间复杂度 平均时间复杂度 空间复杂度 程序运行所需的空间\n主要分为两部分：\n 固定部分：指令空间、数据空间（静态空间） 可变空间：动态分配的空间  S(n) = O(f(n))\n","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003ch3 id=\"数据\"\u003e数据\u003c/h3\u003e\n\u003cp\u003e所有能够输入到计算机中的去的描述客观事物的符号\u003c/p\u003e\n\u003ch3 id=\"数据元素\"\u003e数据元素\u003c/h3\u003e\n\u003cp\u003e数据的基本单位，也称结点或记录\u003c/p\u003e\n\u003ch3 id=\"数据结构\"\u003e数据结构\u003c/h3\u003e\n\u003cp\u003e相互之间存在一种或多种特定关系的数据元素的集合\u003c/p\u003e","title":"数据结构概括"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]