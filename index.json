[{"content":"这里将记录Golang学习的笔记。\nGo基础 Go语言基础之变量与常量\nGo语言基础之基本数据类型\nGo语言基础之运算符\nGo语言基础之流程控制\nGo语言基础之数组\nGo语言基础之切片\nGo语言基础之map\nGo语言基础之函数\nGo语言基础之指针\nGo语言基础之结构体（一）\nGo语言基础之结构体（二）\nGo语言基础之接口\nGo语言基础之并发\n","permalink":"https://www.niuwx.cn/posts/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e这里将记录Golang学习的笔记。\u003c/p\u003e","title":"Golang学习笔记"},{"content":"Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。\nmap map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。\nmap定义 Go语言中 map的定义语法如下：\nmap[KeyType]ValueType 其中，\n KeyType:表示键的类型。 ValueType:表示键对应的值的类型。  map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：\nmake(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。\nmap基本使用 map中的数据都是成对出现的，map的基本使用示例代码如下：\nfunc main() { scoreMap := make(map[string]int, 8) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[\u0026#34;小明\u0026#34;]) fmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, scoreMap) } 输出：\nmap[小明:100 张三:90] 100 type of a:map[string]int map也支持在声明的时候填充元素，例如：\nfunc main() { userInfo := map[string]string{ \u0026#34;username\u0026#34;: \u0026#34;沙河小王子\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;, } fmt.Println(userInfo) // } 判断某个键是否存在 Go语言中有个判断map中键是否存在的特殊写法，格式如下:\nvalue, ok := map[key] 举个例子：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值 \tv, ok := scoreMap[\u0026#34;张三\u0026#34;] if ok { fmt.Println(v) } else { fmt.Println(\u0026#34;查无此人\u0026#34;) } } map的遍历 Go语言中使用for range遍历map。\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 for k, v := range scoreMap { fmt.Println(k, v) } } 但我们只想遍历key的时候，可以按下面的写法：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 for k := range scoreMap { fmt.Println(k) } } 注意： 遍历map时的元素顺序与添加键值对的顺序无关。\n使用delete()函数删除键值对 使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：\ndelete(map, key) 其中，\n map:表示要删除键值对的map key:表示要删除的键值对的键  示例代码如下：\nfunc main(){ scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 delete(scoreMap, \u0026#34;小明\u0026#34;)//将小明:100从map中删除 \tfor k,v := range scoreMap{ fmt.Println(k, v) } } 按照指定顺序遍历map func main() { rand.Seed(time.Now().UnixNano()) //初始化随机数种子  var scoreMap = make(map[string]int, 200) for i := 0; i \u0026lt; 100; i++ { key := fmt.Sprintf(\u0026#34;stu%02d\u0026#34;, i) //生成stu开头的字符串 \tvalue := rand.Intn(100) //生成0~99的随机整数 \tscoreMap[key] = value } //取出map中的所有key存入切片keys \tvar keys = make([]string, 0, 200) for key := range scoreMap { keys = append(keys, key) } //对切片进行排序 \tsort.Strings(keys) //按照排序后的key遍历map \tfor _, key := range keys { fmt.Println(key, scoreMap[key]) } } 元素为map类型的切片 下面的代码演示了切片中的元素为map类型时的操作：\nfunc main() { var mapSlice = make([]map[string]string, 3) for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%v\\n\u0026#34;, index, value) } fmt.Println(\u0026#34;after init\u0026#34;) // 对切片中的map元素进行初始化 \tmapSlice[0] = make(map[string]string, 10) mapSlice[0][\u0026#34;name\u0026#34;] = \u0026#34;小王子\u0026#34; mapSlice[0][\u0026#34;password\u0026#34;] = \u0026#34;123456\u0026#34; mapSlice[0][\u0026#34;address\u0026#34;] = \u0026#34;沙河\u0026#34; for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%v\\n\u0026#34;, index, value) } } 值为切片类型的map 下面的代码演示了map中值为切片类型的操作：\nfunc main() { var sliceMap = make(map[string][]string, 3) fmt.Println(sliceMap) fmt.Println(\u0026#34;after init\u0026#34;) key := \u0026#34;中国\u0026#34; value, ok := sliceMap[key] if !ok { value = make([]string, 0, 2) } value = append(value, \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;) sliceMap[key] = value fmt.Println(sliceMap) } ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/","summary":"\u003cp\u003eGo语言中提供的映射关系容器为\u003ccode\u003emap\u003c/code\u003e，其内部使用\u003ccode\u003e散列表（hash）\u003c/code\u003e实现。\u003c/p\u003e","title":"Go语言基础之map"},{"content":"函数是基本的代码块，用于执行一个任务。\nGo 语言至少要有个 main() 函数。\n本文将介绍Go语言中函数的相关内容。\n函数 Go语言中支持函数、匿名函数、闭包。\n函数定义 Go语言中定义函数使用关键字func，如下：\nfunc 函数名(参数1,参数2)(返回值1,返回值2){ 函数体 }  函数名：命名规则与变量相同 参数：参数由参数变量和参数变量类型组成 返回值：返回值由返回值变量和返回值类型组成，也可以只写返回值的类型。Go语言支持多个返回值，须用()包裹。  具体用以下例子说明：\n{% tabs tab-1 %}\nfunc mysum(x int, y int) int { return x + y } func myhello(){ fmt.Println(\u0026#34;Hello Boy!\u0026#34;) } {% endtabs %}\n函数调用 在定义了函数之后，可以通过函数名()的方式对函数进行调用。\n例如调用上述定义的两个函数，代码如下：\nfunc main(){ myhello(); ret := mysum(1, 2) fmt.Println(ret) } 参数 {% tabs tab-2 %}\n函数中的参数如果相邻变量的类型相同，则可以省略类型，只留一个，例如：\nfunc mysum(x, y int) int { return x + y } 可变参数是指函数的参数数量不固定，Go语言中的可变参数通过在参数名后加...来表示。\n{% note warning, 可变参数通常要作为函数的最后一个参数 %}\n例如：\nfunc mysum2(x ...int) int { fmt.Println(x) //x是一个切片  sum :=0 for _, v := range x{ sum = sum + v } return sum } func main(){ ret1 := mysum2() ret2 := mysum2(10) ret3 := mysum3(10, 20, 30) fmt.Println(ret1,ret2,ret3) } {% endtabs %}\n返回值 Go语言中通过关键字return返回\n{% tabs tab-3 %}\nGo语言中函数支持多个返回值，函数如果有多个返回值时，必须用()将返回值括起来\nfunc myfunc(x, y int)(int, int){ sum := x + y sub := x - y return sum,sub } 函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。\n例如：\nfunc myfunc(x, y int) (sum, sub int) { sum = x + y sub = x - y return } 当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。\nfunc myfunc(x string) []int { if x == \u0026#34;\u0026#34; { return nil // 没必要返回[]int{} \t} ... } {% endtabs %}\n函数进阶 函数类型和变量 使用type关键字来定义一个函数类型，格式如下：\ntype mytype func(int, int) int 上面的语句定义了一个mytype类型，一种函数类型，且这种函数接受两个int类型的参数并且返回一个int类型的返回值。简单点来说，凡是满足这个条件的函数都是mytype类型的函数，例如：\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } func main() { type mytype func(int, int) int var c mytype c = add //将函数add赋值给变量c \tfmt.Println(c(1, 2)) // 可以像add一样调用c } 高阶函数 函数作为参数 Go语言中，函数可以作为参数。例如：\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } func myfunc(x, y int, canshu func(int, int) int) int { return canshu(x, y) } func main() { ret1 := myfunc(1, 2, add) fmt.Println(ret1) } 也可以使用定义函数类型\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } type mytype func(x, y int) int func myfunc(x, y int, canshu mytype) int { return canshu(x, y) } func main() { ret1 := myfunc(1, 2, add) fmt.Println(ret1) } 函数作为返回值 Go语言中，函数可以作为返回值\n//待补充 匿名函数和闭包 匿名函数 Go语言中函数内部定义函数与之前有所不同，只能定义匿名函数。匿名函数就是没有函数名的函数，格式如下：\nfunc(参数)(返回值){ 函数体 } 匿名函数因为没有函数名，没办法想普通函数一样被调用，所以匿名函数需要保存到某个变量或者立即执行该函数：\nfunc main(){ add :=func(x, y int){//将匿名函数保存到变量中  fmt.Println(x + y) } add(10,20)//通过变量调用匿名函数  //自执行函数，匿名函数定义完加()直接执行  func(x, y int){ fmt.Println(x + y) }(10, 20) } 闭包 闭包指的是一个函数和其相关的引用环境组合而成的实体。简单点说，闭包 = 函数 + 引用环境。例如：\npackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { var x int return func(y int) int { x += y return x } } func main() { var f = adder() fmt.Println(f(10)) //10 \tfmt.Println(f(20)) //30 \tfmt.Println(f(30)) //60  f1 := adder() fmt.Println(f1(40)) //40 \tfmt.Println(f1(50)) //90 } 变量f是一个函数并且它引用了其外部作用域中x变量，此时f是一个闭包。在f的生命周期内，变量x也一直有效。\n闭包进阶示例 {% tabs tab-4 %}\npackage main import \u0026#34;fmt\u0026#34; func adder2(x int) func(int) int { return func(y int) int { x += y return x } } func main() { var f = adder2(10) fmt.Println(f(10)) //20 \tfmt.Println(f(20)) //40 \tfmt.Println(f(30)) //70  f1 := adder2(20) fmt.Println(f1(40)) //60 \tfmt.Println(f1(50)) //110 } package main import \u0026#34;fmt\u0026#34; func myfunc(base int) (func(int) int, func(int) int) { add := func(i int) int { base += i return base } sub := func(i int) int { base -= i return base } return add, sub } func main() { f1, f2 := myfunc(10) fmt.Println(f1(1), f2(2)) //11 9 \tfmt.Println(f1(3), f2(4)) //12 8 \tfmt.Println(f1(5), f2(6)) //13 7 } {% endtabs %}\ndefer语句 Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句最先被执行，和C语言中栈的顺序一样\n例如：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;start\u0026#34;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(\u0026#34;end\u0026#34;) } 运行结果：\nstart end 3 2 1 利用defer语句延迟调用的特性，可以很方便的处理资源释放的问题\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/","summary":"\u003cp\u003e函数是基本的代码块，用于执行一个任务。\u003c/p\u003e\n\u003cp\u003eGo 语言至少要有个 main() 函数。\u003c/p\u003e\n\u003cp\u003e本文将介绍Go语言中函数的相关内容。\u003c/p\u003e","title":"Go语言基础之函数"},{"content":"本文主要介绍Go语言中切片（slice）及它的基本使用。\n引入 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：\nfunc arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum + v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，\na := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了，这样就难受的一批。而切片可以很好的解决这个问题\n切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。\n切片的定义 声明切片类型的基本语法如下：\nvar name []T  name:表示变量名 T:表示切片中的元素类型  例如：\nfunc main() { // 声明切片类型 \tvar a []string //声明一个字符串切片 \tvar b = []int{} //声明一个整型切片并初始化 \tvar c = []bool{false, true} //声明一个布尔切片并初始化 \tvar d = []bool{false, true} //声明一个布尔切片并初始化 \tfmt.Println(a) //[] \tfmt.Println(b) //[] \tfmt.Println(c) //[false true] \tfmt.Println(a == nil) //true \tfmt.Println(b == nil) //false \tfmt.Println(c == nil) //false \t// fmt.Println(c == d) //切片是引用类型，不支持直接比较，只能和nil比较 } 切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。\n切片表达式 简单切片表达式 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1\u0026lt;=索引值\u0026lt;4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] \tfmt.Printf(\u0026#34;s:%v len(s):%v cap(s):%v\\n\u0026#34;, s, len(s), cap(s)) } 输入结果如下：\ns:[2 3] len(s):2 cap(s):4 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:\na[2:] // 等同于 a[2:len(a)] a[:3] // 等同于 a[0:3] a[:] // 等同于 a[0:len(a)] {% span red, 注意： %}\n对于数组或字符串，如果0 \u0026lt;= low \u0026lt;= high \u0026lt;= len(a)，则索引合法，否则就会索引越界（out of range）。\n对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low \u0026lt;= high。如果索引在运行时超出范围，就会发生运行时panic。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] \tfmt.Printf(\u0026#34;s:%v len(s):%v cap(s):%v\\n\u0026#34;, s, len(s), cap(s)) s2 := s[3:4] // 索引的上限是cap(s)而不是len(s) \tfmt.Printf(\u0026#34;s2:%v len(s2):%v cap(s2):%v\\n\u0026#34;, s2, len(s2), cap(s2)) } 输出结果如下：\ns:[2 3] len(s):2 cap(s):4 s2:[5] len(s2):1 cap(s2):1 完整切片表达式 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：\na[low : high : max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} t := a[1:3:5] fmt.Printf(\u0026#34;t:%v len(t):%v cap(t):%v\\n\u0026#34;, t, len(t), cap(t)) } 输出结果如下：\nt:[2 3] len(t):2 cap(t):4 完整切片表达式需要满足的条件是0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a)，其他条件和简单切片表达式相同。\n使用make()函数构造切片 我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下：\nmake([]T, size, cap) 其中：\n T:切片的元素类型 size:切片中元素的数量 cap:切片的容量  举个例子：\nfunc main() { a := make([]int, 2, 10) fmt.Println(a) //[0 0] \tfmt.Println(len(a)) //2 \tfmt.Println(cap(a)) //10 } 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。\n切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。\n 多个切片指向同一数组时，对任一切片进行操作时，都有可能对其他切片造成影响  切片不能直接比较 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：\nvar s1 []int //len(s1)=0;cap(s1)=0;s1==nil s2 := []int{} //len(s2)=0;cap(s2)=0;s2!=nil s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil 所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。\n切片的赋值拷贝 下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。\nfunc main() { s1 := make([]int, 3) //[0 0 0] \ts2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 \ts2[0] = 100 fmt.Println(s1) //[100 0 0] \tfmt.Println(s2) //[100 0 0] } 切片遍历 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。\nfunc main() { s := []int{1, 3, 5} for i := 0; i \u0026lt; len(s); i++ { fmt.Println(i, s[i]) } for index, value := range s { fmt.Println(index, value) } } append()方法为切片添加元素 Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。\nfunc main(){ var s []int s = append(s, 1) // [1] \ts = append(s, 2, 3, 4) // [1 2 3 4] \ts2 := []int{5, 6, 7} s = append(s, s2...) // [1 2 3 4 5 6 7] } **注意：**通过var声明的零值切片可以在append()函数直接使用，无需初始化。\nvar s []int s = append(s, 1, 2, 3) 没有必要像下面的代码一样初始化一个切片再传入append()函数使用，\ns := []int{} // 没有必要初始化 s = append(s, 1, 2, 3) var s = make([]int) // 没有必要初始化 s = append(s, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。\n举个例子：\nfunc main() { //append()添加元素和切片扩容 \tvar numSlice []int for i := 0; i \u0026lt; 10; i++ { numSlice = append(numSlice, i) fmt.Printf(\u0026#34;%v len:%d cap:%d ptr:%p\\n\u0026#34;, numSlice, len(numSlice), cap(numSlice), numSlice) } } 输出：\n[0] len:1 cap:1 ptr:0xc0000a8000 [0 1] len:2 cap:2 ptr:0xc0000a8040 [0 1 2] len:3 cap:4 ptr:0xc0000b2020 [0 1 2 3] len:4 cap:4 ptr:0xc0000b2020 [0 1 2 3 4] len:5 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc0000b8000 [0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc0000b8000 从上面的结果可以看出：\n append()函数将元素追加到切片的最后并返回该切片。 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。  append()函数还支持一次性追加多个元素。 例如：\nvar citySlice []string // 追加一个元素 citySlice = append(citySlice, \u0026#34;北京\u0026#34;) // 追加多个元素 citySlice = append(citySlice, \u0026#34;上海\u0026#34;, \u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;) // 追加切片 a := []string{\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;} citySlice = append(citySlice, a...) fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆] 使用copy()函数复制切片 首先我们来看一个问题：\nfunc main() { a := []int{1, 2, 3, 4, 5} b := a fmt.Println(a) //[1 2 3 4 5] \tfmt.Println(b) //[1 2 3 4 5] \tb[0] = 1000 fmt.Println(a) //[1000 2 3 4 5] \tfmt.Println(b) //[1000 2 3 4 5] } 由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。\nGo语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：\ncopy(destSlice, srcSlice []T) 其中：\n srcSlice: 数据来源切片 destSlice: 目标切片  举个例子：\nfunc main() { // copy()复制切片 \ta := []int{1, 2, 3, 4, 5} c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c \tfmt.Println(a) //[1 2 3 4 5] \tfmt.Println(c) //[1 2 3 4 5] \tc[0] = 1000 fmt.Println(a) //[1 2 3 4 5] \tfmt.Println(c) //[1000 2 3 4 5] } 从切片中删除元素 Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：\nfunc main() { // 从切片中删除元素 \ta := []int{30, 31, 32, 33, 34, 35, 36, 37} // 要删除索引为2的元素 \ta = append(a[:2], a[3:]...) fmt.Println(a) //[30 31 33 34 35 36 37] } 总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/","summary":"\u003cp\u003e本文主要介绍Go语言中切片（slice）及它的基本使用。\u003c/p\u003e","title":"Go语言基础之切片"},{"content":"变量和常量是编程中必不可少的部分，也是很好理解的一部分。\n标识符与关键字 标识符 关于Go语言中的命名规则，与C类似。Go语言中标识符由字母、数字和_(下划线)组成，并且只能以字母和_开头。 例如aaa,_ ,_123,a123\n关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。且不能将关键字和保留字作为变量名\n//25个关键字 break default func interface select case defer go map struct chan const continue else fallthrough if for goto package range import return switch type var //37个保留字 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 变量 变量类型 变量的功能是存储数据，不同类型的变量存储不同类型的数据。\n常见变量的数据类型有：整型、浮点型、布尔型等。\nGo语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。\n变量声明 Go语言声明变量的格式为:\nvar 变量名 变量类型 例如：\nvar name string var age int var isOK bool 当然，在Go语言中，可以批量声明变量\nvar( a string b int c bool d float32 ) 变量初始化 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。\n当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：\nvar 变量名 类型 = 值 例如：\nvar name string = \u0026#34;Q1mi\u0026#34; var age int = 18 同样，也支持多个变量初始化\nvar name, age = \u0026#34;Q1mi\u0026#34;, 20 {% note info, 类型推导 %}\n有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。\nvar name = \u0026#34;Q1mi\u0026#34; var age = 18 {% note info, 短变量声明 %}\n在函数内部，可以使用更简略的:=方式声明并初始化变量。\npackage main import \u0026#34;fmt\u0026#34; // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m \tfmt.Println(m, n) } {% note info, 匿名变量 %} 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量。 匿名变量用一个下划线_表示。\n例如：\nfunc test() (int, string) { return 10, \u0026#34;hahaha\u0026#34; } func main() { x, _ := test() _, y := test() fmt.Println(\u0026#34;x=\u0026#34;, x) fmt.Println(\u0026#34;y=\u0026#34;, y) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。\n注意事项：\n 函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。  常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把ar换成了const，常量在定义的时候必须赋值。\nconst pi = 3.1415 const e = 2.7182 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。\n多个常量也可以一起声明：\nconst ( pi = 3.1415 e = 2.7182 ) const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。\n例如：\nconst ( n1 = 100 n2 n3 ) ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","summary":"\u003cp\u003e变量和常量是编程中必不可少的部分，也是很好理解的一部分。\u003c/p\u003e","title":"Go语言基础之变量与常量"},{"content":"Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。\n基本数据类型 整型 整数分为以下两个大类：\n按长度分为：int8，int16，int64\n对应的无符号整型：uint16，uint32，uint64\n其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。\n特殊整型    类型 描述     uint 32位操作系统上就是uint32，64位操作系统上就是uint64   int 32位操作系统上就是int32，64位操作系统上就是int64   uintptr 无符号整型，用于存放一个指针    浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。\n打印浮点数时，可以使用fmt包配合动词%f，代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Printf(\u0026#34;%f\\n\u0026#34;, math.Pi) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, math.Pi) } 复数 complex64和complex128\n具体用法如下：\nvar c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。\n注意：\n 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。  字符串 Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(\u0026quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：\ns1 := \u0026#34;hello\u0026#34; s2 := \u0026#34;你好\u0026#34; 转义字符    \\r 回车符（返回行首）     \\n 换行符（直接跳到下一行的同列位置）   \\t 制表符   \\' 单引号   \\\u0026quot; 双引号   \\\\ 反斜杠    例如，我们要打印Windows平台的文件路径\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;str := \\\u0026#34;c:\\\\Code\\\\lesson1\\\\go.exe\\\u0026#34;\u0026#34;) } 多行字符串 Go语言中要定义一个多行字符串时，就必须使用反引号字符：\ns1 := `第一行 第二行 第三行 ` fmt.Println(s1) 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。\n字符串的常用操作    len(str) 求长度     + 或 fmt.Sprintf 拼接字符串   strings.Split 分割   strings.contains 判断是否包含   strings.HasPrefix,strings.HasSuffix 前缀/后缀判断   strings.Index(),strings.LastIndex() 子串出现的位置    byte和rune类型 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（'）包裹起来，如：\nvar a := \u0026#39;中\u0026#39; var b := \u0026#39;x\u0026#39; Go 语言的字符有以下两种：\n uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。  当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。\n如下，可以知道rune和byte的区别：\n// 遍历字符串 func traversalString() { s := \u0026#34;GO你好\u0026#34; for i := 0; i \u0026lt; len(s); i++ { //byte \tfmt.Printf(\u0026#34;%v(%c) \u0026#34;, s[i], s[i]) } fmt.Println() for _, r := range s { //rune \tfmt.Printf(\u0026#34;%v(%c) \u0026#34;, r, r) } fmt.Println() } 这是我们的输出结果\n71(G) 79(O) 228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½) 71(G) 79(O) 20320(你) 22909(好) 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。\n字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。\n修改字符串 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。\nfunc changeString() { s1 := \u0026#34;big\u0026#34; // 强制类型转换 \tbyteS1 := []byte(s1) byteS1[0] = \u0026#39;p\u0026#39; fmt.Println(string(byteS1)) s2 := \u0026#34;白萝卜\u0026#34; runeS2 := []rune(s2) runeS2[0] = \u0026#39;红\u0026#39; fmt.Println(string(runeS2)) } 类型转化 强制类型转换的基本语法如下：\nT(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等\n比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型\nfunc sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 \tc = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"\u003cp\u003eGo语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。\u003c/p\u003e","title":"Go语言基础之基本数据类型"},{"content":"并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。\n并发和并行 并发：同一时间段内执行多个任务。\n并行：同一时刻执行多个任务。\nGo语言的并发通过goroutine实现。goroutine类似于进程，属于用户态的进程。可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时调度完成，而线程是由操作系统调度完成。\nGo语言还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言并成的CSP并发模式的重要实现基础。\ngoroutine Go语言中goroutine的概念类似于线程但 goroutine是由Go的运行时（runtime）调度和管理的。\ngoroutine的使用 Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加go关键字，就可以为一个函数创建一个goroutine。\n一个gotoutine必定对应一个函数，可以创建的多个goroutine去执行相同的函数。\n启动单个goroutine 例如：\npackage main import \u0026#34;fmt\u0026#34; func hello() { fmt.Println(\u0026#34;Hello goroutine!\u0026#34;) } func main() { hello() fmt.Println(\u0026#34;main goroutine done!\u0026#34;) } 这个例子的输出结果是Hello goroutine! 和main goroutine done!。\npackage main import \u0026#34;fmt\u0026#34; func hello() { fmt.Println(\u0026#34;Hello goroutine!\u0026#34;) } func main() { go hello() fmt.Println(\u0026#34;main goroutine done!\u0026#34;) } 这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了main goroutine done!，这是为什么呢？\n在程序启动时，Go程序为main()函数创建一个默认的goroutine，当main()函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，hello()还没来得及进行，程序就结束了。\n如何才能将hello()进行呢？最简单粗暴的方式就是time.Sleep。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello() { fmt.Println(\u0026#34;Hello goroutine!\u0026#34;) } func main() { go hello() fmt.Println(\u0026#34;main goroutine done!\u0026#34;) time.Sleep(1000) } 执行上面的代码会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。\n启动多个goroutine 例子：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func hello(i int) { defer wg.Done() //goroutine结束也要登记,-1 \tfmt.Println(\u0026#34;Hello goroutine\u0026#34;, i) } func main() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1) //启动一个goroutine就登记一次,+1 \tgo hello(i) } wg.Wait() //等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。\ngoroutine与线程 goroutine调度 GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。\nGOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。\nGo语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。\nGo1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。\n我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func a() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026#34;A:\u0026#34;, i) } } func b() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026#34;B:\u0026#34;, i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second) } 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。\nGo语言中的操作系统线程和goroutine的关系：\n 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。  channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\nchannel类型 channel是一种类型，一种引用类型。声明格式如下：\nvar 变量 chan 元素类型 例如：\nvar ch1 chan int var ch2 chan bool var ch3 chan []int 创建channel 通道是引用类型，通道类型的空值是nil。\nvar ch chan int fmt.Println(ch) //nil 声明的通道在make初始化后才能使用。\n格式如下：\nmake(chan 元素类型, [大小]) 例如：\nch1 := make(chan int) ch2 := make(chan bool) ch3 := make(chan []int) channel操作 通道有发送（send）、接收(receive）和关闭（close）三种操作。\n发送和接收都使用\u0026lt;-符号。\n现在我们先使用以下语句定义一个通道：\nch := make(chan int) 发送 将一个值发送到通道中。\nch \u0026lt;- 10 // 把10发送到ch中 接收 从一个通道中接收值。\nx := \u0026lt;- ch // 从ch中接收值并赋值给变量x \u0026lt;-ch // 从ch中接收值，忽略结果 关闭 我们通过调用内置的close函数来关闭通道。\nclose(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n关闭后的通道有以下特点：\n 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。  无缓冲的通道 无缓冲的通道又称为阻塞的通道。例如：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { ch := make(chan int) ch \u0026lt;- 10 fmt.Println(\u0026#34;成功\u0026#34;) } 这段代码在执行时会出现错误\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5f exit status 2 因为ch := make(chan int)创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。\n上面的代码会阻塞在ch \u0026lt;- 10这一行代码形成死锁。\n解决方法：\n一种方法就是启用一个goroutine去接受，例如：\npackage main import ( \u0026#34;fmt\u0026#34; ) func rec(c chan int) { ret := \u0026lt;-c fmt.Println(\u0026#34;成功\u0026#34;, ret) } func main() { ch := make(chan int) go rec(ch) ch \u0026lt;- 10 fmt.Println(\u0026#34;成功\u0026#34;) } 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。\n使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。\n有缓冲的通道 解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：\nfunc main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 \tch \u0026lt;- 10 fmt.Println(\u0026#34;发送成功\u0026#34;) } 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量。\nfor range 从通道循环取值 当向通道中发送完数据时，我们可以通过close函数来关闭通道。\n当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？\n看这个例子：\npackage main import \u0026#34;fmt\u0026#34; func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 \tgo func() { for i := 0; i \u0026lt; 100; i++ { ch1 \u0026lt;- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 \tgo func() { for { i, ok := \u0026lt;-ch1 // 通道关闭后再取值ok=false \tif !ok { break } ch2 \u0026lt;- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 \tfor i := range ch2 { // 通道关闭后会退出for range循环 \tfmt.Println(i) } } 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range。\n单向通道 有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。\nGo语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：\nfunc counter(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 100; i++ { out \u0026lt;- i } close(out) } func squarer(out chan\u0026lt;- int, in \u0026lt;-chan int) { for i := range in { out \u0026lt;- i * i } close(out) } func printer(in \u0026lt;-chan int) { for i := range in { fmt.Println(i) } } func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) } 其中，\n chan\u0026lt;- int是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作； \u0026lt;-chan int是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。  在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。\nworker pool （goroutine池） 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。\n例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for i := range jobs { fmt.Printf(\u0026#34;worker:%d start job:%d\\n\u0026#34;, id, i) time.Sleep(time.Second) fmt.Printf(\u0026#34;worker:%d end job:%d\\n\u0026#34;, id, i) results \u0026lt;- i * 2 } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) //只开启3个goroutine \tfor w := 1; w \u0026lt;= 3; w++ { go worker(w, jobs, results) } //5个任务 \tfor j := 1; j \u0026lt;= 5; j++ { jobs \u0026lt;- j } close(jobs) for a := 1; a \u0026lt;= 5; a++ { \u0026lt;-results } } select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：\nfor{ // 尝试从ch1接收值  data, ok := \u0026lt;-ch1 // 尝试从ch2接收值  data, ok := \u0026lt;-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。\nselect的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：\nselect{ case \u0026lt;-ch1: ... case data := \u0026lt;-ch2: ... case ch3\u0026lt;-data: ... default: 默认操作 } 举个例子来演示下select的使用：\nfunc main() { ch := make(chan int, 1) for i := 0; i \u0026lt; 10; i++ { select { case x := \u0026lt;-ch: fmt.Println(x) case ch \u0026lt;- i: } } } 使用select语句能提高代码的可读性。\n 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select{}会一直等待，可用于阻塞main函数。  并发安全和锁 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。\n举个例子：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x int64 var wg sync.WaitGroup func add() { for i := 0; i \u0026lt; 50000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。\n互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i \u0026lt; 50000; i++ { lock.Lock() //上锁 \tx = x + 1 lock.Unlock() //解锁 \t} wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。\n读写互斥锁 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。\n读写锁示例：\nvar ( x int64 wg sync.WaitGroup //lock sync.Mutex \trwlock sync.RWMutex ) func write() { // lock.Lock() // 加互斥锁 \trwlock.Lock() // 加写锁 \tx = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 \trwlock.Unlock() // 解写锁 \t// lock.Unlock() // 解互斥锁 \twg.Done() } func read() { // lock.Lock() // 加互斥锁 \trwlock.RLock() // 加读锁 \ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 \trwlock.RUnlock() // 解读锁 \t// lock.Unlock() // 解互斥锁 \twg.Done() } func main() { start := time.Now() for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go write() } for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go read() } wg.Wait() end := time.Now() fmt.Println(end.Sub(start)) } 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。\nsync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：\n   方法名 功能     (wg * WaitGroup) Add(delta int) 计数器+delta   (wg *WaitGroup) Done() 计数器-1   (wg *WaitGroup) Wait() 阻塞直到计数器变为0    sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。\n我们利用sync.WaitGroup将上面的代码优化一下：\nvar wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\u0026#34;Hello Goroutine!\u0026#34;) } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 \tfmt.Println(\u0026#34;main goroutine done!\u0026#34;) wg.Wait() } 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。\nsync.Once 说在前面的话：这是一个进阶知识点。\n在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。\nsync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) {} 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用。\n加载配置文件示例 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\nvar icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \u0026#34;left\u0026#34;: loadIcon(\u0026#34;left.png\u0026#34;), \u0026#34;up\u0026#34;: loadIcon(\u0026#34;up.png\u0026#34;), \u0026#34;right\u0026#34;: loadIcon(\u0026#34;right.png\u0026#34;), \u0026#34;down\u0026#34;: loadIcon(\u0026#34;down.png\u0026#34;), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\nfunc loadIcons() { icons = make(map[string]image.Image) icons[\u0026#34;left\u0026#34;] = loadIcon(\u0026#34;left.png\u0026#34;) icons[\u0026#34;up\u0026#34;] = loadIcon(\u0026#34;up.png\u0026#34;) icons[\u0026#34;right\u0026#34;] = loadIcon(\u0026#34;right.png\u0026#34;) icons[\u0026#34;down\u0026#34;] = loadIcon(\u0026#34;down.png\u0026#34;) } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。\n使用sync.Once改造的示例代码如下：\nvar icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \u0026#34;left\u0026#34;: loadIcon(\u0026#34;left.png\u0026#34;), \u0026#34;up\u0026#34;: loadIcon(\u0026#34;up.png\u0026#34;), \u0026#34;right\u0026#34;: loadIcon(\u0026#34;right.png\u0026#34;), \u0026#34;down\u0026#34;: loadIcon(\u0026#34;down.png\u0026#34;), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 并发安全的单例模式 下面是借助sync.Once实现的并发安全的单例模式：\npackage singleton import ( \u0026#34;sync\u0026#34; ) type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\nsync.Map Go语言中内置的map不是并发安全的。请看下面的示例：\nvar m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\u0026#34;k=:%v,v:=%v\\n\u0026#34;, key, get(key)) wg.Done() }(i) } wg.Wait() } 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。\n像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。\nvar m = sync.Map{} func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(\u0026#34;k=:%v,v:=%v\\n\u0026#34;, key, value) wg.Done() }(i) } wg.Wait() } 原子操作 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。\n示例 我们填写一个示例来比较下互斥锁和原子操作的性能。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(\u0026amp;a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(\u0026amp;a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { c.Inc() wg.Done() }() } wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start)) } func main() { c1 := CommonCounter{} // 非并发安全 \ttest(c1) c2 := MutexCounter{} // 使用互斥锁实现并发安全 \ttest(\u0026amp;c2) c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高 \ttest(\u0026amp;c3) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/","summary":"\u003cp\u003e并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。\u003c/p\u003e","title":"Go语言基础之并发"},{"content":"任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\nGo语言中的指针 Go语言中的指针与C/C++中指针有一定的区别，Go语言中的指针不能进行偏移和运算，是安全指针。因此，Go语言中的指针操作比较简单，只需要记住两个符号\u0026amp;（取址）和*（取值）\n指针地址和指针类型 每个变量在运行都有一个地址，这个地址也就代表变量在内存中的位置。Go语言中使用\u0026amp;对变量进行取地址。例如：\na := 10 //定义整型变量a p := \u0026amp;10//p为整型类型的指针类型，其中保存的是变量a的地址 在Go语言中，每个值类型都有对应的指针类型。\n指针取值 在对变量使用\u0026amp;取地址后，可以使用*对接收了地址的指针变量进行取值，有一个很简单的例子：\npackage main import \u0026#34;fmt\u0026#34; func main() { a := 10 b := \u0026amp;a fmt.Println(*b) } {% folding green, 输出结果 %}\n10 {% endfolding %}\n指针传值示例 package main import \u0026#34;fmt\u0026#34; func myfunc(x *int) { *x = 20 } func main() { a := 10 myfunc(\u0026amp;a) fmt.Println(a) } {% folding blue, 输出结果 %}\n20\r{% endfolding %}\nnew \u0026amp; make 先分析一个经典的例子\nfunc main() { var a *int *a = 100 fmt.Println(*a) var b map[string]int b[\u0026#34;哈哈哈\u0026#34;] = 100 fmt.Println(b) } 执行这段代码，其实是会报错的。\n 在声明了整型的指针类型a之后，系统并没有给变量分配内存空间 在声明了map类型的b之后，同样，系统并没有给其分配内存空间  Go语言中对于值类型的声明，在声明的时候就默认分配了内存空间。然而对于引用类型，在使用的时候不仅要声明它，还要给它分配内存空间，否则无法储存。\n所以就要使用Go语言中new和make来分配内存\nnew new是一个内置的函数，语法如下：\nname := new(Type) //name 变量名 //Type 指针变量指向的变量的类型 举例说明：\npackage main import \u0026#34;fmt\u0026#34; func main() { a := new(int) b := new(bool) //使用new函数后得到的是一个指针变量，且该指针对应的值为该类型的零值 \tfmt.Println(*a) fmt.Println(*b) } 在上述开始的经典例子中，var a *int只是声明了指针变量a，但是并未初始化，指针作为引用类型需要初始化才会有内存空间，才可对其进行赋值。\nfunc main(){ var a *int a = new(int) *a = 100 fmt.Println(*a) } make make也用于内存分配，区别于new，只用于slice(切片)，map以及chan(通道)的内存创建，而不是他们的指针类型，因为这三种类型本来就是引用类型。\n语法如下：\nb := make(map[Type1]Type2, Size) make函数是无可替代的，在使用slice，map以及chan时，都需要使用make初始化。\n在上述开始的经典例子中，var b map[string]int只是声明了b是一个map类型的变量，并未初始化。\nfunc main(){ var b map[string]int b = make(map[string]int, 10) b[\u0026#34;哈哈哈\u0026#34;] = 10 fmt.Println(b) } new和make的异同  new和make都是用来做内存分配的 make只用于slice，map，channel的初始化 new用于指针类型的分配，而且内存对应的值为类型零值 ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/","summary":"\u003cp\u003e任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\u003c/p\u003e","title":"Go语言基础之指针"},{"content":"接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\n接口类型 在Go语言中接口（interface）是一种类型，一种抽象的类型。\ninterface是一组method的集合，不关心属性（数据），只关心行为（方法）。\n引入 package main import \u0026#34;fmt\u0026#34; type Cat struct{} //猫 func (c Cat) Say() string { return \u0026#34;喵喵喵\u0026#34; } type Dog struct{} //狗 func (d Dog) Say() string { return \u0026#34;汪汪汪\u0026#34; } func main() { c := Cat{} fmt.Println(c.Say()) d := Dog{} fmt.Println(d.Say()) } 上述代码定义了猫和狗，以及他们叫声的方法，可以发现，main中会有重复的代码，如果再加上其他动物，代码还会重复，那如果把他们都归类成“会叫的动物”来处理呢？\n像这样类似的例子还有很多，例如：\n支付宝、微信、银联等在线支付的方式，可以把它们当成支付方式来处理。\n计算三角形、正方形、圆形等的周长和面积，可以把他们当成图形来处理\n等等……\n而在Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于所有的具体类型，接口是一种抽象的类型。当看到一个接口类型的值时，你不知道它是什么，只知道通过它的方法能做什么。\n接口的定义 Go语言提倡面向接口编程\n每个接口由数个方法组成，格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … }  接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。  例如：\ntype writer interface{ Write([]byte) error } 当你看到这个接口类型的值时，并不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。\n接口实现的条件 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个{% emp 需要实现的方法列表 %}\n例如：\ntype Sayer interface { Say() } type Cat struct{} func (c Cat) Say() { //Cat实现了Sayer接口  fmt.Println(\u0026#34;喵喵喵\u0026#34;) } type Dog struct{} func (d Dog) Say() { //Dog实现了Sayer接口  fmt.Println(\u0026#34;汪汪汪\u0026#34;) } 接口类型的变量 实现了接口有什么作用呢？\n接口类型变量能够储存所有实现了该接口的实例。\n例如：\nfunc main() { var x Sayer c := Cat{} d := Dog{} x = c x.Say() x = d x.Say() } 值接收者和指针接收者实现接口的区别 定义一个Mover接口和一个Dog结构体\ntype Mover interface{ move() } type Dog struct{} {% tabs tab-1 %}\nfunc (d Dog) move() { fmt.Println(\u0026#34;狗跑了\u0026#34;) } func main() { var x Mover var wangcai = Dog{} x = wangcai x.move() var fugui = \u0026amp;Dog{} x = fugui x.move() } 从上面这段代码不难发现，使用值接收者实现接口之后，不管是Dog结构体还是*Dog结构体指针类型的变量都可以赋值给该接口变量。\n同样的代码，如果使用指针接受实现接口呢？\nfunc (d *Dog) move() { fmt.Println(\u0026#34;狗跑了\u0026#34;) } func main() { var x Mover var wangcai = Dog{} x = wangcai //x不可以接收Dog类型 \tx.move() var fugui = \u0026amp;Dog{} x = fugui x.move() } 此时实现Mover接口的是*Dog类型，所以不能给x传入Dog类型。\n{% endtabs %}\n类型与接口的关系 一个类型实现多个接口 一个类型可以同时实现多个接口，而接口之间批次独立。例如，狗可以叫，也可以跑。就可以分别定义Sayer接口和Mover接口：\npackage main import \u0026#34;fmt\u0026#34; type Sayer interface { say() } type Mover interface { move() } type Dog struct { name string } func (d Dog) say() { fmt.Printf(\u0026#34;%s说\\n\u0026#34;, d.name) } func (d Dog) move() { fmt.Printf(\u0026#34;%s跑了\\n\u0026#34;, d.name) } func main() { var x Mover var y Sayer var a = Dog{\u0026#34;旺财\u0026#34;} x = a y = a x.move() y.say() } 多个类型实现同一接口 Go语言中不同的类型还可以实现同一接口，例如：\npackage main import \u0026#34;fmt\u0026#34; type Mover interface { move() } type Dog struct { name string } func (d Dog) move() { fmt.Printf(\u0026#34;%s跑了\\n\u0026#34;, d.name) } type Car struct { name string } func (c Car) move() { fmt.Printf(\u0026#34;%s跑了\\n\u0026#34;, c.name) } func main() { var x Mover var d = Dog{\u0026#34;旺财\u0026#34;} var c = Car{\u0026#34;保时捷\u0026#34;} x = d x.move() x = c c.move() //不关心具体是什么，只需调用方法即可 } 接口嵌套 接口与接口之间可以通过嵌套创造出新的接口\n//Sayer接口 type Sayer interface{ say() } //Mover接口 type Mover interface{ move() } //接口嵌套 type animal interface{ Sayer Mover } 嵌套得到的接口的使用与普通接口一样：\ntype Cat struct { name string } func (c Cat) say() { fmt.Println(\u0026#34;喵喵喵\u0026#34;) } func (c Cat) move() { fmt.Println(\u0026#34;猫跑了\u0026#34;) } func main() { var x animal x = Cat{name: \u0026#34;臭宝\u0026#34;} x.move() x.say() } 空接口 空接口的定义 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。\n空接口类型的变量可以存储任意类型的变量。\npackage main import \u0026#34;fmt\u0026#34; func main() { var x interface{} s := \u0026#34;Hello\u0026#34; x = s fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, x, x) i := 100 x = i fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, x, x) b := true x = b fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, x, x) } 空接口的应用 {% tabs tab-2 %}\n使用空接口实现可以接受任意类型的函数参数\nfunc show(a interface{}) { fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, a, a) } 使用空接口实现可以保存任意值的字典。\npackage main import \u0026#34;fmt\u0026#34; func main() { var studentInfo = make(map[string]interface{}) studentInfo[\u0026#34;name\u0026#34;] = \u0026#34;臭宝\u0026#34; studentInfo[\u0026#34;age\u0026#34;] = 18 studentInfo[\u0026#34;married\u0026#34;] = false fmt.Println(studentInfo) //map[age:18 married:false name:臭宝] } {% endtabs %}\n类型断言","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/","summary":"\u003cp\u003e接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\u003c/p\u003e","title":"Go语言基础之接口"},{"content":"本文主要介绍Go语言中数组（array）及它的基本使用。\nArray(数组) 数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：\n// 定义一个长度为3元素类型为int的数组a var a [3]int 数组定义： var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。\nvar a [3]int var b [4]int a = b //不可以这样做，因为此时a和b是不同的类型 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。\n数组的初始化 数组的初始化也有很多方式。\n方法一 初始化数组时可以使用初始化列表来设置数组元素的值。\nfunc main() { var testArray [3]int //数组会初始化为int类型的零值 \tvar numArray = [3]int{1, 2} //使用指定的初始值完成初始化 \tvar cityArray = [3]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} //使用指定的初始值完成初始化 \tfmt.Println(testArray) //[0 0 0] \tfmt.Println(numArray) //[1 2 0] \tfmt.Println(cityArray) //[北京 上海 深圳] } 方法二 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：\nfunc main() { var testArray [3]int var numArray = [...]int{1, 2} var cityArray = [...]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} fmt.Println(testArray) //[0 0 0] \tfmt.Println(numArray) //[1 2] \tfmt.Printf(\u0026#34;type of numArray:%T\\n\u0026#34;, numArray) //type of numArray:[2]int \tfmt.Println(cityArray) //[北京 上海 深圳] \tfmt.Printf(\u0026#34;type of cityArray:%T\\n\u0026#34;, cityArray) //type of cityArray:[3]string } 方法三 我们还可以使用指定索引值的方式来初始化数组，例如:\nfunc main() { a := [...]int{1: 1, 3: 5} fmt.Println(a) // [0 1 0 5] \tfmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, a) //type of a:[4]int } 数组的遍历 遍历数组a有以下两种方法：\nfunc main() { var a = [...]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} // 方法1：for循环遍历 \tfor i := 0; i \u0026lt; len(a); i++ { fmt.Println(a[i]) } // 方法2：for range遍历 \tfor index, value := range a { fmt.Println(index, value) } } 多维数组 Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。\n二维数组的定义 func main() { a := [3][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]] \tfmt.Println(a[2][1]) //支持索引取值:重庆 } 二维数组的遍历 func main() { a := [3][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } for _, v1 := range a { for _, v2 := range v1 { fmt.Printf(\u0026#34;%s\\t\u0026#34;, v2) } fmt.Println() } } 输出：\n北京\t上海\t广州\t深圳\t成都\t重庆\t注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：\n//支持的写法 a := [...][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } //不支持多维数组的内层使用... b := [3][...]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } 数组是值类型 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。\nfunc modifyArray(x [3]int) { x[0] = 100 } func modifyArray2(x [3][2]int) { x[2][0] = 100 } func main() { a := [3]int{10, 20, 30} modifyArray(a) //在modify中修改的是a的副本x \tfmt.Println(a) //[10 20 30] \tb := [3][2]int{ {1, 1}, {1, 1}, {1, 1}, } modifyArray2(b) //在modify中修改的是b的副本x \tfmt.Println(b) //[[1 1] [1 1] [1 1]] } 注意：\n 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T表示指针数组，*[n]T表示数组指针 。 ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/","summary":"\u003cp\u003e本文主要介绍Go语言中数组（array）及它的基本使用。\u003c/p\u003e","title":"Go语言基础之数组"},{"content":"流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。\nGo语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。\nif else (分支结构) if条件判断基本写法 Go语言中if条件判断的格式如下：\nif 表达式1 { 分支1 } else if 表达式2 { 分支2 } else{ 分支3 } Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 同理，与else匹配的{也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。\n例如：\nfunc myfunc() { score := 65 if score \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt;= 85 { fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } } if条件判断特殊写法 if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：\nfunc myfunc() { if score := 65; score \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt;= 85 { fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } } 两种写法有什么不同呢？\nfor (循环结构) Go 语言中的所有循环类型均可以使用for关键字来完成。\nfor循环的基本格式如下：\nfor 初始语句;条件表达式;结束语句{ 循环体语句 } 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。\nfunc myfunc1() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：\nfunc myfunc2() { i := 0 for ; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句和结束语句都可以省略，例如：\nfunc myfunc3() { i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } } 这种写法类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。\n{% noteblock, 无限循环 %}\n{% folding yellow, Folding 点击打开 %}\nfor { 循环体语句 } {% endfolding %}\nfor循环可以通过break、goto、return、panic语句强制退出循环。\n{% endnoteblock %}\nfor range(键值循环) Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：\n 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。  switch case 使用switch语句可方便地对大量的值进行条件判断。\nfunc switch1() { finger := 3 switch finger { case 1: fmt.Println(\u0026#34;大拇指\u0026#34;) case 2: fmt.Println(\u0026#34;食指\u0026#34;) case 3: fmt.Println(\u0026#34;中指\u0026#34;) case 4: fmt.Println(\u0026#34;无名指\u0026#34;) case 5: fmt.Println(\u0026#34;小拇指\u0026#34;) default: fmt.Println(\u0026#34;无效的输入！\u0026#34;) } } Go语言规定每个switch只能有一个default分支。\n一个分支可以有多个值，多个case值中间使用英文逗号分隔。\nfunc Switch2() { switch n := 7; n { case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;奇数\u0026#34;) case 2, 4, 6, 8: fmt.Println(\u0026#34;偶数\u0026#34;) default: fmt.Println(n) } } 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：\nfunc switch3() { age := 30 switch { case age \u0026lt; 25: fmt.Println(\u0026#34;好好学习！\u0026#34;) case age \u0026gt; 25 \u0026amp;\u0026amp; age \u0026lt; 35: fmt.Println(\u0026#34;好好工作！\u0026#34;) case age \u0026gt; 60: fmt.Println(\u0026#34;好好享受！\u0026#34;) default: fmt.Println(\u0026#34;长命百岁！\u0026#34;) } } fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。\nfunc switch4() { s := \u0026#34;a\u0026#34; switch { case s == \u0026#34;a\u0026#34;: fmt.Println(\u0026#34;a\u0026#34;) fallthrough case s == \u0026#34;b\u0026#34;: fmt.Println(\u0026#34;b\u0026#34;) case s == \u0026#34;c\u0026#34;: fmt.Println(\u0026#34;c\u0026#34;) default: fmt.Println(\u0026#34;...\u0026#34;) } } 输出：\na b {% note warning, 注意Go与C中switch的区别 %}\ngoto(跳转到指定标签) goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：\nfunc goto1() { var breakFlag bool for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 \tbreakFlag = true break } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } // 外层for循环判断 \tif breakFlag { break } } } 使用goto语句能简化代码：\nfunc goto2() { for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 \tgoto breakTag } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } return // 标签 breakTag: fmt.Println(\u0026#34;结束for循环\u0026#34;) } break(跳出循环) break语句可以结束for、switch和select的代码块。\nbreak语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子：\nfunc break1() { BREAKDEMO1: for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { break BREAKDEMO1 } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } fmt.Println(\u0026#34;...\u0026#34;) } continue(继续下次循环) continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。\n在 continue语句后添加标签时，表示开始标签对应的循环。例如：\nfunc continue1() { forloop1: for i := 0; i \u0026lt; 5; i++ { // forloop2: \tfor j := 0; j \u0026lt; 5; j++ { if i == 2 \u0026amp;\u0026amp; j == 2 { continue forloop1 } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } } ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"\u003cp\u003e流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。\u003c/p\u003e\n\u003cp\u003eGo语言中最常用的流程控制有\u003ccode\u003eif\u003c/code\u003e和\u003ccode\u003efor\u003c/code\u003e，而\u003ccode\u003eswitch\u003c/code\u003e和\u003ccode\u003egoto\u003c/code\u003e主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。\u003c/p\u003e","title":"Go语言基础之流程控制"},{"content":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\n自定义类型和类型别名 {% tabs tab-1 %}\n在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以像C/C++一样使用type关键字来定义自定义类型。\n自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：\n//将MyInt定义为int类型 type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性\n类型别名规定：MyType只是Type的别名，本质上MyType与Type是同一个类型。\ntype MyType = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下：\ntype byte = uint8 type rune = int32 自定义类型和类型别名在语法上看似只有一个等号的差别，但其实不然，例如：\n//自定义类型 type NewInt int //类型别名 type MyInt = int func main(){ var a NewInt var b MyInt fmt.Printf(\u0026#34;%T\\n\u0026#34;, a) //main.NewInt  fmt.Printf(\u0026#34;%T\u0026#34;, b) //int } 输出结果显示a的类型是main.NewInt，表示main包下定义的``NewInt类型；b的类型是int`。\nMyInt类型在编译完成时，会被替换成int\n{% endtabs %}\n结构体 Go语言中结构体的定义与C/C++中类似。\n我们想表达一个事物的全部或部分属性时，这时用单一的基本数据类型无法满足需求，Go语言提供了自定义数据类型，可以封装多个基本数据类型，这就是结构体。\n通过struct来定义，同时在Go语言中，也通过struct实现面向对象\n结构体的定义 使用type和struct关键字来定义结构体，如下：\ntype MyType struct { Name1 Type1 Name2 Type2 ... }  MyType：自定义类型的名称，同一个包中不可重复 Name1和Name2：结构体中成员名称，同一结构体中不可重复 Type1和Type2：成员的具体类型  例如，定义一个学生的结构体：\ntype student struct { name string age int id string score int } 这样，使用student结构体就可以很方便在代码中表示和储存信息了\nGo语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型\n结构体实例化 只有结构体实例化后，才会对相应的变量分配内存。结构体实例化与声明内置类型一样，使用var关键字声明变量\nvar student1 student {% tabs tab-2 %}\n通过.访问结构体的成员\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { var stu student //声明结构体变量  //赋值 \tstu.name = \u0026#34;小学生\u0026#34; stu.age = 7 stu.id = \u0026#34;666\u0026#34; stu.score = 60 fmt.Println(stu) } 输出结果：\n{小学生 7 666 60} 在定义一些临时数据结构等场景下，可以使命匿名结构体\npackage main import \u0026#34;fmt\u0026#34; func main() { var user struct { Name string Age int } user.Name = \u0026#34;小学生\u0026#34; user.Age = 7 fmt.Println(user) } 输出结果：\n{小学生 7} Go语言中还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址：\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { var s = new(student) fmt.Printf(\u0026#34;%T\\n\u0026#34;, s) fmt.Println(s) s.name = \u0026#34;小学生\u0026#34; //Go语言中支持对结构体指针直接使用.来访问结构体成员 \ts.age = 7 s.id = \u0026#34;666\u0026#34; s.score = 60 fmt.Println(s) } 输出结果：\n*main.student \u0026amp;{ 0 0} \u0026amp;{小学生 7 666 60} 使用\u0026amp;对结构体进行取址操作相当于对该结构体进行了依次new实例化操作\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { s := \u0026amp;student{} fmt.Printf(\u0026#34;%T\\n\u0026#34;, s) fmt.Println(s) s.name = \u0026#34;小学生\u0026#34; s.age = 7 s.id = \u0026#34;666\u0026#34; s.score = 60 fmt.Println(s) } 输出结果：\n*main.student \u0026amp;{ 0 0} \u0026amp;{小学生 7 666 60} {% endtabs %}\n结构体初始化 没有初始化的结构体，其成员变量都是对应类型的零值\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { var stu student fmt.Printf(\u0026#34;%#v\\n\u0026#34;, stu) } 输出结果：\nmain.student{name:\u0026#34;\u0026#34;, age:0, id:\u0026#34;\u0026#34;, score:0} {% tabs tab-3 %}\n使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值\nstu := student{ name: \u0026#34;小学生\u0026#34;, age: 7, id: \u0026#34;666\u0026#34;, score: 60, } fmt.Println(stu)//{小学生 7 666 60} 也可以对结构体指针进行键值对初始化：\nstu := student{ name: \u0026#34;小学生\u0026#34;, age: 7, id: \u0026#34;666\u0026#34;, score: 60, } fmt.Println(stu)//\u0026amp;{小学生 7 666 60} 当某些字段没有初始值时，该字段可以不写。此时，没有指定初始值的字段的值时该字段类型的零值\nstu := student{ name: \u0026#34;小学生\u0026#34;, score: 60, } fmt.Printf(\u0026#34;%#v\u0026#34;, stu)//main.student{name:\u0026#34;小学生\u0026#34;, age:0, id:\u0026#34;\u0026#34;, score:60} 初始话结构体时可以简写，也就是初始化时不写键，直接写值即可：\nstu := student{ \u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60, } fmt.Println(stu)//{小学生 7 666 60} 使用这种格式要注意：\n 必须初始化结构体的所有字段 顺序必须一致 不可与简直初始化混用  {% endtabs %}\n结构体内存布局 结构体占用一块连续的内存\npackage main import \u0026#34;fmt\u0026#34; type test struct { a int8 b int8 c int8 d int8 } func main() { n := test{ 1, 2, 3, 4, } fmt.Printf(\u0026#34;n.a %p\\n\u0026#34;, \u0026amp;n.a) fmt.Printf(\u0026#34;n.b %p\\n\u0026#34;, \u0026amp;n.b) fmt.Printf(\u0026#34;n.c %p\\n\u0026#34;, \u0026amp;n.c) fmt.Printf(\u0026#34;n.d %p\\n\u0026#34;, \u0026amp;n.d) } 输出结果：\nn.a 0xc000012090 n.b 0xc000012091 n.c 0xc000012092 n.d 0xc000012093 空结构体 空结构体不占用空间\nvar t struct{} fmt.Println(unsafe.Sizeof(t)) // 0 ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80/","summary":"\u003cp\u003eGo语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\u003c/p\u003e","title":"Go语言基础之结构体（一）"},{"content":"在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。\n构造函数 在C++面向对象中，声明一个对象后，可以写一些针对该对象的一些方法，例如构造函数等。Go语言中的结构体没有构造函数，可以自己实现。\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } //构造函数 func Student(name string, age int, id string, score int) *student { return \u0026amp;student{ //struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型 \tname, age, id, score, } } func main() { s := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) //\u0026amp;main.student{name:\u0026#34;小学生\u0026#34;, age:7, id:\u0026#34;666\u0026#34;, score:60} } 方法和接收者 Go语言中的方法(Method)是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者(Receiver)。接收者的概念类似于C++中的this。\n定义格式如下：\nfunc (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 }  接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是this之类的命名。例如，student类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。  例如：\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } //构造函数 func Student(name string, age int, id string, score int) *student { return \u0026amp;student{ //struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型 \tname, age, id, score, } } func (s student) study() { fmt.Printf(\u0026#34;我要好好学习！\\n\u0026#34;) } func main() { p := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) p.study() } 方法和函数的区别就是函数不属于任何类型，方法只属于特定的类型\n{% tabs tab-1 %}\n指针类型的接收者由一个结构的指针组成，由于指针的特性，调用方法时可以修改接收者指针的任何成员变量，在方法结束后，修改依然有效。这种方法类似于C++中使用this。\n例如：\nfunc (s *student) setAge(age int) { s.age = age } 这是一个修改student的age 的方法\n调用：\nfunc main() { p := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) fmt.Println(p.age) //7 \tp.setAge(18) fmt.Println(p.age) //18 } 与指针类型的接收者对比，调用方法时，拿到的是值类型接收者的值的拷贝份。在值类型接收者的方法中可以获取接收者的成员值，但修改成员变量指针对这个副本，无法修改接收者变量本身。\n例如：\nfunc (s student) setAge(age int) { s.age = age } func main() { p := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) fmt.Println(p.age) //7 \tp.setAge(18) fmt.Println(p.age) //7 }  需要修改接收者的成员值 接收者是比较复杂的结构体，拷贝开销大  {% endtabs %}\n任意类型添加方法 Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。例如，基于内置的int类型使用type关键字可以定义新的自定义类型，然后为这个自定义类型添加方法。\npackage main import \u0026#34;fmt\u0026#34; type MyInt int func (m MyInt) SayHello() { fmt.Println(\u0026#34;Hello, I\u0026#39;m SatHello\u0026#34;) //Hello, I\u0026#39;m SatHello } func main() { var m MyInt m.SayHello() m = 100 fmt.Printf(\u0026#34;%#v %T\\n\u0026#34;, m, m) //100 main.MyInt } 注意：只可以给本包的类型定义方法\n结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段称为匿名字段。\npackage main import \u0026#34;fmt\u0026#34; type student struct { string int } func main() { s := \u0026amp;student{ \u0026#34;小学生\u0026#34;, 7, } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) //\u0026amp;main.student{string:\u0026#34;小学生\u0026#34;, int:7} } 匿名字段的说法并不代表没有字段名，而是默认采用类型名作为字段名。从其定义中不难发现，\n由于结构体要求字段名必须唯一，因此一个结构体中一种类型的匿名字段只能有一个。\n嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针，例如：\npackage main import \u0026#34;fmt\u0026#34; //成绩信息 type grade struct { math int chinese int english int } //学生信息 type student struct { name string age int mygrade grade //grade  //↑可采用匿名字段的方式嵌套 } func main() { s := \u0026amp;student{ name: \u0026#34;小学生\u0026#34;, age: 7, mygrade: grade{ math: 60, chinese: 60, english: 60, }, } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) //\u0026amp;main.student{name:\u0026#34;小学生\u0026#34;, age:7, mygrade:main.grade{math:60, chinese:60, english:60}} } 结构体的“继承” Go语言中使用结构体也可以实现C++中面向对象的继承。\npackage main import \u0026#34;fmt\u0026#34; type Animal struct { name string } func (a Animal) move() { fmt.Printf(\u0026#34;%s会动\\n\u0026#34;, a.name) } type Dog struct { age int *Animal //通过嵌套匿名结构体实现继承 } func (d *Dog) wang() { fmt.Printf(\u0026#34;%s汪汪汪的叫\\n\u0026#34;, d.name) } func main() { d := \u0026amp;Dog{ age: 4, Animal: \u0026amp;Animal{ name: \u0026#34;小明\u0026#34;, }, } d.move() d.wang() } 结构体字段的可见性 结构体中字段大写开头表示可公开访问，小写代表私有（仅在定义当前结构体的包中可访问）\n{% note warning, 区别私有概念 %}\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/","summary":"\u003cp\u003e在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。\u003c/p\u003e","title":"Go语言基础之结构体（二）"},{"content":"运算符用于在程序运行时执行数学或逻辑运算。\nGo 语言内置的运算符有五类：\n 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符  算数运算符    运算符 描述     + 相加   - 相减   * 相乘   / 相除   % 求余    注意： ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符。\n关系运算符    运算符 描述     == 检查两个值是否相等，如果相等返回 True 否则返回 False。   != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   \u0026gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   \u0026gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。   \u0026lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   \u0026lt;= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。    逻辑运算符    运算符 描述     \u0026amp;\u0026amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。   || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。   ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。    位运算符 位运算符对整数在内存中的二进制位进行操作。\n   运算符 描述     \u0026amp; 参与运算的两数各对应的二进位相与。 （两位均为1才为1）   | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）   ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）   \u0026laquo; 左移n位就是乘以2的n次方。 “a\u0026laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。   \u0026raquo; 右移n位就是除以2的n次方。 “a\u0026raquo;b”是把a的各二进位全部右移b位。    赋值运算符    运算符 描述     = 简单的赋值运算符，将一个表达式的值赋给一个左值   += 相加后再赋值   -= 相减后再赋值   *= 相乘后再赋值   /= 相除后再赋值   %= 求余后再赋值   \u0026laquo;= 左移后赋值   \u0026raquo;= 右移后赋值   \u0026amp;= 按位与后赋值   |= 按位或后赋值   ^= 按位异或后赋值   ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"\u003cp\u003e运算符用于在程序运行时执行数学或逻辑运算。\u003c/p\u003e","title":"Go语言基础之运算符"}]