[{"content":"保障系统安全和多应用支持是操作系统的两个核心目标，本章从这两个目标出发，思考如何设计应用程序，并进一步展现操作系统的一系列新功能:\n构造包含操作系统内核和多个应用程序的单一执行程序 通过批处理支持多个程序的自动加载和运行 操作系统利用硬件特权级机制，实现对操作系统自身的保护 实现特权级的跨越 支持跨特权级的系统调用功能 批处理系统(Batch System)，它可以用来管理无需或仅需少量用户交互即可运行的程序，在资源允许的情况下它可以自动安排程序的执行，这被称为批处理作业，此名词源自二十世纪60年代的大型机时代。批处理系统的核心思想是：将多个程序打包到一起输入计算机，当一个程序运行结束后，计算机自动加载下一个程序到内存并执行。\n本片代码:\n代码地址 特权级机制 为了保护我们的批处理系统不受到出错应用程序的影响并全程稳定工作，单凭软件实现是很难做到的，而是需要CPU提供一种特权级隔离机制，使CPU在执行应用程序和操作系统内核的指令时处于不同的特权级。\n特权级的软硬件协同设计 实现特权级机制的根本原因是应用程序运行的安全性不可充分信任。由于操作系统和应用程序两者通过编译器形成一个单一执行程序来执行，导致即使是应用本身的问题，也会牵连操作系统，导致整个计算机系统出现问题。\n所以，计算机科学家和工程师想出了一个办法：让相对安全可靠的操作系统运行在一个硬件保护的安全执行环境中，不受应用程序的破坏；而让应用程序运行在另外一个无法破坏操作系统的受限执行环境中。\n为了确保操作系统的安全，对应用程序而言，需要限制的主要有两个方面：\n应用程序不能访问任意的地址空间 应用程序不能执行某些可能破坏计算机系统的指令 除此之外，还需要确保应用程序能够得到操作系统的服务，即应用程序和操作系统还需要有交互的手段。使得低特权级机制只能做高特权级软件允许它做的，且超出低特权级能力的功能必须寻求高特权级软件的帮助。\n为了实现这样的特权级机制，需要进行软硬件协同设计。一个比较简洁的方法就是，处理器设置两个不同安全等级的执行环境：\n用户态特权级的执行环境 内核态特权级的执行环境 且明确指出可能破坏计算机系统的内核态特权级指令子集，内核态特权级指令子集只能在内核态特权级的执行环境中执行。处理器在执行指令前会进行特权级安全检查，如果在用户态执行环境中执行内核态特权级指令，会产生异常。\n为了让应用程序获得操作系统的函数服务，采用传统的函数调用方(即通常的call和ret指令或指令组合)将会绕过硬件的特权级保护检查。所以可以设计新的机器指令：执行环境调用(Execution Environment Call 简称 ecall)和执行环境返回(Excution Environment Return 简称 eret)\necall：具有用户态到内核态到执行环境切换能力的函数调用指令 eret：具有内核态到用户态的执行环境切换能力的函数返回指令 硬件具有了这样的机制后，还需要操作系统的配合才能最终完成对操作系统自身的保护。\n首先，操作系统需要提供相应的功能代码，能在执行eret前准备和恢复用户态执行应用程序的上下文。 其次，在应用程序调用ecall指令后，能够检查应用程序的系统调用参数，确保参数不会破坏操作系统。 RISC-V特权级架构 RISC-V架构一共定义了4种特权级：\n级别 编码 名称 0 00 用户/应用模式(U, User/Application) 1 01 监督模式(S, Supervistor) 2 10 虚拟监督模式(H, Hypervistor) 3 11 机器模式(M, Machine) 级别数值越大，特权级越高，掌控硬件的能力越强。\n在CPU硬件层面，除了M模式必须存在外，其他模式可以不存在。RISC-V架构中，只有M模式是必须实现的，剩下的特权级则可以根据跑在CPU上应用的实际需求进行调整：\n简单的嵌入式应用只需要实现M模式 带有一定保护能力的嵌入式系统需要实现M/U模式 复杂的多任务系统则需要实现M/S/U模式 到目前为止，H模式特权规范还没有完全制定好 从特权级架构的角度看待执行环境栈：\n其中，白色块表示一层执行环境，黑色块表示相邻两层执行环境之间的接口。其中操作系统内核代码运行在S模式上；应用程序运行在U模式上。\n运行在M模式上的软件被称为监督模式执行环境(SEE, Supervistor Execution Environment)，比如在操作系统运行前负责加载操作系统的Bootloader-RustSBI。站在运行在S模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为SEE，它需要在相比S模式更高的特权级下运行，一般情况下SEE在M模式上执行。\n执行环境的功能之一是在它支持的上层软件执行之前进行一些初始化工作。之前提到的引导加载程序会在加电之后对整个系统进行初始化，它实际上就是SEE功能的一部分。也就是说在RISC-V架构上的引导加载程序一般运行在M模式上。\n在上一节中，实现了简单的操作系统，它和应用程序全程运行在S模式下，应用程序很容易破坏没有任何保护的执行环境-操作系统。在之后，我们会涉及RISC-V的M/S/U三种特权级：\n应用程序和用户态支持库运行在U模式的最低特权级 操作系统内核运行在S模式特权级，形成支撑应用程序和用户态支持的执行环境 在之前提到的bootloader-RurstSBI实际上是运行在更底层的M模式特权级下的软件，是操作系统内核的执行环境。 执行环境的另一种功能是对上层软件的执行进行监控管理。可以理解为，当上层软件执行出现了一些异常或者特殊情况时，导致需要用到执行环境中提供的功能，因此需要暂停上层软件的执行，转而运行执行环境的代码。\n由于上层软件和执行环境被设计为运行在不同的特权级，这个过程也往往**（不一定）伴随着CPU的特权级切换**。当执行环境的代码运行结束后，我们需要回到上层软件暂停的位置继续执行。在RISC-V架构中，这种与常规控制流不同的异常控制流(ECF, Exception Control Flow)被称为异常(Exception)，在RISC-V语境下的Trap种类之一。\n用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：\n用户态软件为获得内核态操作系统的服务功能而执行特殊指令 在执行某条指令期间发生了错误并被CPU检测到，例如执行了用户态不允许执行的指令或者其他错误 下表是RISC-V特权级规范定义的可能会导致从低特权级到高特权级到各种异常：\nInterrupt Exception Code Description 0 0 Instruction address misaligned 0 1 Instruction access fault 0 2 Illegal instruction 0 3 Breakpoint 0 4 Load address misaligned 0 5 Load access fault 0 6 Stroe/AMO address misaligned 0 7 Store/AMO access fault 0 8 Environment call from U-mode 0 9 Environment call from S-mode 0 11 Environment call from M-mode 0 12 Instruction page fault 0 13 Load page fault 0 15 Stroe/AMO page fault 其中，断点(Breakpoint)和执行环境调用(Enviroment call)两种异常（这种有意而为之的指令称为陷入或trap类指令）是通常在上层软件中执行一条特定的指令触发的：执行ebreak这条指令之后就会触发断点陷入异常；而执行ecall这条指令之后则会随着CPU当前所处特权级而触发不同的异常。\n执行环境调用ecall，这是一种很特殊的陷入类的指令，在之前从特权级架构看待执行环境栈这张图中，相邻两特权级软件之间的接口正是基于这种陷入机制实现的。M模式软件SEE和S模式的内核之间的接口被称为监督模式二进制接口(Supervistor Binary Interface, SBI)，而内核和U模式的应用程序之间的接口被称为应用程序二进制接口(Application Binary Interface, ABI)，它还有一个更加通俗的名字：系统调用(syscall ,System Cal)。而之所以叫做二进制接口，是因为它与高级编程语言的内部调用接口不同，是机器/汇编指令级的一种接口。\n事实上M/S/U三个特权级的软件可分别由不同的编程语言实现。即使是用同一种汇编语言实现，其调用也不是普通的函数调用，而是陷入异常控制流，在该过程中切换CPU特权级。因此只有将接口下降到机器/汇编指令级才能满足其跨高级语言的通用性和灵活性。\n可以看到，在这样的架构之下，每层特权级的软件都只能做高特权级软件允许它做的，并且不会产生什么撼动高特权级软件的情况，一旦低特权级软件的要求超出了其能力范围，就必须寻求高特权级软件的帮助，否则就是一种异常行为了。因此，在软件执行过程中，我们经常可以看到特权级切换：\n其他的异常则一般是在执行某一条指令的时候发生了某种错误，例如除零、无效地址访问、无效指令等；或处理器认为处于当前特权级下执行等当前指令是高特权级指令或会访问不应该访问的高特权级的资源（可能危害系统）。碰到这种情况，就需要将控制权转交给高特权级的软件来处理：\n当错误/异常恢复后，则重新回到低优先级软件去执行 如不能恢复错误/异常，那高特权级软件可以杀死和清除低特权级软件，避免破坏整个执行环境 RISC-V的特权指令 与特权级无关的一般的指令和通用寄存器x0~x31在任何特权级都可以执行。而每个特权级都对应一些特殊指令和控制状态寄存器(Control and Status Register, CSR)，来控制该特权级的某些行为并描述其状态。当然特权指令不仅具有读写CSR的指令，还有其他功能的特权指令。\n如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常。这样，位于高特权级的执行环境能够得知低特权级的软件出现了错误，这个错误一般是不可恢复的，此时执行环境将低特权级的软件终止，这在某种程度上体现了特权级保护机制的作用。\n在RISC-V中，会有两类属于高特权级S模式的特权指令：\n指令本身属于高特权级的指令，例如sret，表示从S模式返回到U模式 指令访问了S模式特权级下才能访问的寄存器或内存，例如表示S模式系统状态的控制状态寄存器sstatus等 RISC-V S模式特权指令：\n指令 含义 sret 从S模式返回U模式：在U模式下执行会产生非法指令异常 wfi 处理器在空闲时进入低功耗状态等待中断：在U模式下执行会产生非法指令异常 sfence.vma 刷新TLB缓存：在U模式下执行会产生非法指令异常 访问S模式CSR的指令 通过访问sepc/stvec/scause/sscartch/stval/sstatus/satp等CSR来改变系统状态：在U模式下执行会产生非法指令异常 实现应用程序 接下来将设计实现被批处理系统逐个加载并运行的应用程序。应用程序的设计实现要点是：\n应用程序的内存布局 应用程序发出的系统调用 从某种程度上讲，这里设计的应用程序与第一章中的最小用户态执行环境有很多相同的地方。即设计一个应用程序和基本的支持的功能库，这样应用程序在用户态通过操作系统提供的服务完成自身的任务。\n应用程序设计 应用程序、用户库（由入口函数、初始化函数、I/O函数和系统调用接口等多个rust文件组成）放在根目录的user目录下，它和上一篇的裸机应用不同之处主要在项目的目录文件结构和内存布局上：\nuser/src/bin/*.rs：应用程序 user/src/*.rs：用户库 user/src/linker.ld：应用程序的内存布局说明 项目结构 user/src/bin目录下有多个文件，每个文件是一个应用程序，分别是：\n00hello_wordl：在屏幕上打印一行Hello, world! 01store_fault：访问一个非法的物理地址，测试批处理系统是否会被该错误影响 02power：不断在计算操作和打印字符串操作之间进行特权级切换 03priv_inst：尝试在用户态执行内核态的特权级指令sret 04priv_csr：尝试在用户态修改内核态CSR sstatus 1 2 3 4 5 6 7 8 9 10 11 12 // user/src/bin/00hello_world.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; #[no_mangle] fn main() -\u0026gt; i32 { println!(\u0026#34;Hello, world!\u0026#34;); 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // user/src/bin/01store_fault.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; #[no_mangle] fn main() -\u0026gt; i32 { println!(\u0026#34;Into Test store_fault, we will insert an invalid store operation...\u0026#34;); println!(\u0026#34;Kernel should kill this application!\u0026#34;); unsafe { core::ptr::null_mut::\u0026lt;u8\u0026gt;().write_volatile(0); } 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // user/src/bin/02power.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; const SIZE: usize = 10; const P: u32 = 3; const STEP: usize = 100000; const MOD: u32 = 10007; #[no_mangle] fn main() -\u0026gt; i32 { let mut pow = [0u32; SIZE]; let mut index: usize = 0; pow[index] = 1; for i in 1..=STEP { let last = pow[index]; index = (index + 1) % SIZE; pow[index] = last * P % MOD; if i % 10000 == 0 { println!(\u0026#34;{}^{}={}(MOD {})\u0026#34;, P, i, pow[index], MOD); } } println!(\u0026#34;Test power OK!\u0026#34;); 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // user/src/bin/03priv_inst.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use core::arch::asm; #[no_mangle] fn main() -\u0026gt; i32 { println!(\u0026#34;Try to execute privileged instruction in U Mode\u0026#34;); println!(\u0026#34;Kernel should kill this application!\u0026#34;); unsafe { asm!(\u0026#34;sret\u0026#34;); } 0 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // user/src/bin/04priv_csr.rs #![no_std] #![no_main] #[macro_use] extern crate user_lib; use riscv::register::sstatus::{self, SPP}; #[no_mangle] fn main() -\u0026gt; i32 { println!(\u0026#34;Try to access privileged CSR in U Mode\u0026#34;); println!(\u0026#34;Kernel should kill this application!\u0026#34;); unsafe { sstatus::set_spp(SPP::User); } 0 } 批处理系统会按照文件名开头的数字编号从小到大的顺序加载并运行它们。\n每个应用程序的实现都在对应的单个文件中。打开其中一个文件，会看到只有一个main函数和若干相关函数所形成的整个应用程序逻辑。\n在user/src/lib.rs中定义了用户库的入口点_start：\n1 2 3 4 5 6 7 8 // user/src/lib.rs #[no_mangle] #[link_section = \u0026#34;.text.entry\u0026#34;] pub extern \u0026#34;C\u0026#34; fn _start() -\u0026gt; ! { clear_bss(); exit(main()); panic!(\u0026#34;unreachable after sys_exit!\u0026#34;); } 第3行使用Rust宏，将_start这段代码编译后的汇编代码放在一个名为.text.entry的代码段中，方便我们在后续链接的时候调整它的位置使得它能够作为用户库的入口。\n从第4行开始，进入用户库入口之后，与上一篇一样，手动清空需要零初始化的.bss段；然后调用main函数得到一个类型为i32的返回值，最后调用用户库提供的exit接口退出应用程序，并将main函数的返回值告知批处理系统。\n在lib.rs中可以看到另一个main：\n1 2 3 4 5 6 // user/src/lib.rs #[linkage = \u0026#34;weak\u0026#34;] #[no_mangle] fn main() -\u0026gt; i32 { panic!(\u0026#34;Cannot find main!\u0026#34;); } 第2行，我们使用Rust的宏将其函数main标志为弱链接。这样最后链接的时候，虽然在lib.rs和应用程序的文件中都会有main符号，但由于lib.rs中的main符号是弱链接，链接器会使用应用程序的main。这里主要是进行某种程度上的保护，如果应用程序的文件中找不到任何main，那么编译也能够通过，但在运行时会报错。\n为了支持上述的链接操作，需要引入:\n1 2 // user/src/lib.rs #![feature(linkage)] 内存布局 在user/.cargo/config中，我们和第一章一样设置链接时使用链接脚本user/src/linker.ld。\n在linker.ld中，我们做的重要的事情是：\n将程序起始物理地址调整为0x80400000，上述五个应用程序都会被加载到这个物理地址上运行 将_start所在的.text.entry放在整个程序的开头，也就是说批处理系统只要在加载之后跳转到0x80400000就已经进入了用户库的入口点，并会在初始化之后跳转到应用程序主逻辑 提供了最终生成可执行文件的.bss段的起始和终止地址，方便clear_bss函数调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // user/src/linker.ld OUTPUT_ARCH(riscv) ENTRY(_start) BASE_ADDRESS = 0x80400000; SECTIONS { . = BASE_ADDRESS; .text : { *(.text.entry) *(.text .text.*) } .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } .data : { *(.data .data.*) *(.sdata .sdata.*) } .bss : { start_bss = .; *(.bss .bss.*) *(.sbss .sbss.*) end_bss = .; } /DISCARD/ : { *(.eh_frame) *(.debug*) } } 系统调用 在子模块syscall中，应用通过ecall调用批处理系统提供的接口，由于应用程序运行在用户态，ecall指令会触发执行环境调用异常，并Trap进入S模式执行批处理系统针对这个异常特别提供的服务代码。由于这个接口处于S模式的批处理系统和U模式的应用程序之间，这个接口可以被称为ABI或者系统调用。\n在本篇中，应用程序和批处理系统之间按照API的结构，约定如下两个系统调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 功能：将内存中缓冲区中的数据写入文件 // 参数： fd表示待写入文件的文件描述符 //\tbuf表示内存中缓冲区的起始地址 //\tlen表示内存中缓冲区的长度 // 返回值：返回成功写入的长度 // syscall ID：64 pub fn sys_write(fd: usize, buffer: \u0026amp;[u8]) -\u0026gt; isize; // 功能：退出应用程序并返回值告知批处理系统 // 参数： xstate表示应用程序的返回值 // 返回值：该系统调用无需返回 // syscall ID：93 pub fn sys_exit(exit_code: i32) -\u0026gt; isize; 系统调用实际上是汇编指令级的二进制接口，在实际调用的时候，我们需要按照RISC-V调用规范(即ABI格式)在合适的寄存器中放置系统调用的参数，然后执行ecall指令出发Trap。在Trap回到U模式的应用程序代码之后，会从ecall的下一条指令继续执行，同时我们能够按照调用规范在合适的寄存器中读取返回值。\nRISC-V寄存器编号从0~31，表示为x0~x31。其中\nx10~x17：对应a0~a7 x1：对应ra 在RISC-V调用规范中，和函数调用的ABI情形类似，约定寄存器a0~a6保存系统调用的参数，a0保存系统调用的返回值。有些许不同的是寄存器a7用来传递syscall ID，这是因为所有的syscall都是通过ecall指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求那个系统调用。由于这超出了Rust语言的表达能力，我们需要在代码中使用内嵌汇编来完成参数/返回值绑定和ecall指令的插入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // user/src/syscall.rs use core::arch::asm; fn syscall(id: usize, args: [usize; 3]) -\u0026gt; isize { let mut ret: isize; unsafe { asm!( \u0026#34;ecall\u0026#34;, inlateout(\u0026#34;x10\u0026#34;) args[0] =\u0026gt; ret, in(\u0026#34;x11\u0026#34;) args[1], in(\u0026#34;x12\u0026#34;) args[2], in(\u0026#34;x17\u0026#34;) id ); } ret } 我们将所有的系统调用都封装成了syscall函数，可以看到它支持传入syscall ID和3个参数。在 syscall中，从第6行开始的asm!宏嵌入ecall指令来触发系统调用。\n从RISC-V调用规范来看，就像函数有着输入参数和返回值一样，ecall指令同样有着输入和输出寄存器：a0~a2和a7作为输入寄存器分别表示系统调用参数和系统调用ID，而当系统调用返回后，a0作为输出寄存器保存系统调用的返回值。在函数上下文中，输入参数数组args和变量id保存系统输调用参数和系统调用ID，而变量ret保存系统调用返回值，它也是函数syscall的输出/返回值。\n那么如何将变量绑定到寄存器则成了一个难题：比如，在ecall指令被执行之前，我们需要将寄存器a7的值设置为变量id的值，那么我们首先需要知道目前变量id的值保存在哪里，它可能在栈上也有可能在某个寄存器中。作为程序员我们并不知道这些只有编译器才知道的信息，因此我们只能在编译器的帮助下完成变量到寄存器的绑定。\n现在来看asm!宏的格式：首先在第8行是我们要插入的汇编代码段本身，这里我们只插入一行ecall指令，不过它可以支持同时插入多条指令。从第9行开始我们在编译器的帮助下将输入/输出变量绑定到寄存器。例如第10行的in(\u0026quot;x11\u0026quot;) args[1]表示将输入参数args[1]绑定到ecall的输入寄存器x11即a1中，编译器自动插入相关指令并保证在ecall指令被执行之前寄存器a1的值与args[1]的值相同。输入参数arg[2]与id到输入寄存器的绑定也是同样的方式，但是这里比较特殊的是a0寄存器，它同时作为输入和输出，因此我们将in改成inlateout，并在行末到变量部分使用{in_var} =\u0026gt; {out_var}的格式，其中{in_var}和{out_var}分别表示上下文中的输入变量和输出变量。\n有些时候不必将变量绑定到固定的寄存器，此时asm!宏可以自动完成寄存器分配。某些汇编代码段还会带来一些编译器无法预知的副作用，这种情况下需要asm!中通过options告知寄存器这些可能的副作用，这样可以帮助编译器在避免出错的情况下更高效的分配寄存器。\n对于sys_write和sys_exit只需将syscall进行封装：\n1 2 3 4 5 6 7 8 9 10 11 // user/src/syscall.rs const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; pub fn sys_write(fd: usize, buffer: \u0026amp;[u8]) -\u0026gt; isize { syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()]) } pub fn sys_exit(exit_code: i32) -\u0026gt; isize { syscall(SYSCALL_EXIT, [exit_code as usize, 0, 0]) } 注意sys_write使用一个\u0026amp;[u8]切片类型来描述缓冲区，这是一个胖指针(Fat Pointer)，里面既包含缓冲区的起始地址，还包含缓冲区的长度。\n我们将上述两个系统调用在用户库user_lib中进一步封装，从而更加接近在Linux等平台下的实际系统调用接口：\n1 2 3 4 5 6 7 8 9 // user/src/lib.rs use syscall::*; pub fn write(fd: usize, buf: \u0026amp;[u8]) -\u0026gt; isize { sys_write(fd, buf) } pub fn exit(exit_code: i32) -\u0026gt; isize { sys_exit(exit_code) } 我们将console子模块中的Stdout::write_str改成基于write的实现，且传入的fd参数设置为1，它代表标准输出，也就是输出到屏幕。目前不需要考虑其他的fd选取情况。这样，应用程序的println!宏借助系统调用变得可以用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // user/src/console.rs use super::write; use core::fmt::{self, Write}; struct Stdout; const STDOUT: usize = 1; impl Write for Stdout { fn write_str(\u0026amp;mut self, s: \u0026amp;str) -\u0026gt; fmt::Result { write(STDOUT, s.as_bytes()); Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) =\u0026gt; { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) =\u0026gt; { $crate::console::print(format_args!(concat!($fmt, \u0026#34;\\n\u0026#34;) $(, $($arg)+)?)); } } exit接口则在用户库中的_start内使用，当应用程序主逻辑main返回之后，使用它退出应用并将返回值告知底层的批处理系统。\n编译生成应用程序二进制码 简单介绍一下user/Makefile：\n对于src/bin下的每个应用程序，在target/riscv64gc-unknown-none-elf/release目录下生成一个同名的ELF可执行文件 使用objcopy二进制工具，将上一步生成的ELF文件删除所有ELF header和符号得到.bin后缀的纯二进制镜像文件。它们将被链接进内核并由内核在合适的时机加载到内存 实现批处理操作系统 在批处理操作系统中，每当一个应用执行完毕，我们需要将下一个要执行的应用的代码和数据加载到内存。\n将应用程序链接到内核 我们需要将应用程序的二进制镜像文件作为内核的数据段链接到内核里面，因此内核需要知道包含的应用程序的数量和他们的位置，这样才能够在运行时对他们进行管理并能够加载到物理内存：\n1 2 // os/src/main.rs global_asm!(include_str!(\u0026#34;link_app.S\u0026#34;)); 这里我们引入了一段汇编代码link_app.S，它一开始并不存在，而是在构建操作系统时自动生成的。这里我们需要增加一个构建脚本，在项目根目录添加一个build.rs文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // os/build.rs use std::fs::{read_dir, File}; use std::io::{Result, Write}; fn main() { println!(\u0026#34;cargo:rerun-if-changed=../user/src/\u0026#34;); println!(\u0026#34;cargo:rerun-if-changed={}\u0026#34;, TARGET_PATH); insert_app_data().unwrap(); } static TARGET_PATH: \u0026amp;str = \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/\u0026#34;; fn insert_app_data() -\u0026gt; Result\u0026lt;()\u0026gt; { let mut f = File::create(\u0026#34;src/link_app.S\u0026#34;).unwrap(); let mut apps: Vec\u0026lt;_\u0026gt; = read_dir(\u0026#34;../user/src/bin\u0026#34;) .unwrap() .into_iter() .map(|dir_entry| { let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap(); name_with_ext.drain(name_with_ext.find(\u0026#39;.\u0026#39;).unwrap()..name_with_ext.len()); name_with_ext }) .collect(); apps.sort(); writeln!( f, r#\u0026#34; .align 3 .section .data .global _num_app _num_app: .quad {}\u0026#34;#, apps.len() )?; for i in 0..apps.len() { writeln!(f, r#\u0026#34; .quad app_{}_start\u0026#34;#, i)?; } writeln!(f, r#\u0026#34; .quad app_{}_end\u0026#34;#, apps.len() - 1)?; for (idx, app) in apps.iter().enumerate() { println!(\u0026#34;app_{}: {}\u0026#34;, idx, app); writeln!( f, r#\u0026#34; .section .data .global app_{0}_start .global app_{0}_end app_{0}_start: .incbin \u0026#34;{2}{1}.bin\u0026#34; app_{0}_end:\u0026#34;#, idx, app, TARGET_PATH )?; } Ok(()) } Cargo会先编译和执行该构建脚本，然后再去构建整个项目。使用make build构建内核时，上述的汇编代码link_app.S就生成了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // os/src/link_app.S .align 3 .section .data .global _num_app _num_app: .quad 5 .quad app_0_start .quad app_1_start .quad app_2_start .quad app_3_start .quad app_4_start .quad app_4_end .section .data .global app_0_start .global app_0_end app_0_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin\u0026#34; app_0_end: .section .data .global app_1_start .global app_1_end app_1_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin\u0026#34; app_1_end: .section .data .global app_2_start .global app_2_end app_2_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/02power.bin\u0026#34; app_2_end: .section .data .global app_3_start .global app_3_end app_3_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin\u0026#34; app_3_end: .section .data .global app_4_start .global app_4_end app_4_start: .incbin \u0026#34;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin\u0026#34; a 找到并加载应用程序二进制码 我们在os的batch子模块中实现一个应用管理器，它的主要功能是：\n保存应用数量和各自的位置信息，以及当前执行到第几个应用 根据应用程序位置信息，初始化好应用所需内存空间，并加载应用执行 应用管理器AppManager结构体定义如下：\n1 2 3 4 5 6 7 8 9 // os/src/batch.rs const MAX_APP_NUM: usize = 16; struct AppManeger { num_app: usize, current_app: usize, app_start: [usize; MAX_APP_NUM + 1], } 在这里，应用管理器需要保存和维护的信息都在AppManager里面。这样设计的原因在于：我们希望将AppManager实例化为一个全局变量，使得任何函数都可以访问。然后AppManager中的current_app字段表示当前执行的第几个应用，它是一个可修改的变量，会在系统运行期间发生变。因此在声明全局变量时，采用static mut是一种比较自然的方法，但是在Rust中，任何对于static mut变量的访问控制都是unsafe的，而我们要在编程中尽量避免使用unsafe，这样才能让编译器负责更多的安全性检查。\n因此我们需要考虑如何在尽量避免触及unsafe的情况下仍能声明并使用可变的全局变量。如果单独使用static而去掉mut的话，我们可以声明一个初始化之后就不可变的全局变量，但是我们需要AppManager里面的内容在运行时发生变化。这就涉及到了Rust中\n的内部可变性(Interior Mutability)，即在变量自身不可变或仅在不可变借用的情况下仍能修改绑定到变量上的值。\n我们可以使用RefCell包裹AppManager，这样RefCell无需被声明为mut，同时被包裹的AppManager也可变。但是RefCell并未被标记为Sync，因此Rust编译器认为它不能被安全的在线程间共享，也就不能作为全局变量使用。所以我们需要在RefCell的基础上，再封装一个UPSafeCell，它名字的含义是：允许我们在单核上安全使用可变全局变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // os/src/sync/up.rs use core::cell::{RefCell, RefMut}; pub struct UPSafeCell\u0026lt;T\u0026gt; { inner: RefCell\u0026lt;T\u0026gt;, } unsafe impl\u0026lt;T\u0026gt; Sync for UPSafeCell\u0026lt;T\u0026gt; {} impl\u0026lt;T\u0026gt; UPSafeCell\u0026lt;T\u0026gt; { pub unsafe fn new(value: T) -\u0026gt; Self { Self { inner: RefCell::new(value), } } pub fn exclusive_access(\u0026amp;self) -\u0026gt; RefMut\u0026lt;\u0026#39;_, T\u0026gt; { self.inner.borrow_mut() } } 1 2 3 4 5 // os/src/sync/mod.rs mod up; pub use up::UPSafeCell; UPSafeCel对于RefCell简单进行封装，它和RefCell一样提供内部可变性和运行时借用检查，只是更加严格：调用exclusive_access可以得到它包裹的数据的独占访问权。因此当我们要访问数据时，需要首先调用exclusive_access获得数据的可变借用标记，通过它可以完成数据的读写，在操作完成之后我们需要销毁这个标记，此后才能开始对该数据的下一次访问。相比RefCell它不再允许多个读操作同时存在。\nup.rs的这段代码出现了两个unsafe：\n首先new被声明为一个unsafe函数，是因为我们希望使用者在创建一个UPSafeCell时保证在访问UPSafeell内包裹的数据时始终不违背上述模式：即访问之前调用exclusive_access，访问之后销毁借用标记再进行下一次访问。 另外，将UPSafeCell标记为Sync使得它可以作为一个全局变量。这是unsafe行为，因为编译器无法确定我们的UPSafeCell能否安全的再多线程共享。 接下来，初始化AppManager的全局实例APP_MANAGER：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // os/src/batch.rs lazy_static! { static ref APP_MANAGER: UPSafeCell\u0026lt;AppManager\u0026gt; = unsafe { UPSafeCell::new({ extern \u0026#34;C\u0026#34; { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = num_app_ptr.read_volatile(); let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1]; let app_start_raw: \u0026amp;[usize] = core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1); app_start[..=num_app].copy_from_slice(app_start_raw); AppManager { num_app, current_app: 0, app_start, } }) }; } 初始化的逻辑很简单，就是找到link_app.S中提供的符号_num_app，并从这里解析出应用数量以及各个应用的起始地址。\n这里使用了外部库lazy_static提供的lazy_static!宏。引入这个外部库，需要加入依赖：\n1 2 3 4 // os/Cargo.toml [dependencies] lazy_static = { version = \u0026#34;1.4.0\u0026#34;, features = [\u0026#34;spin_no_std\u0026#34;] } lazy_static!宏提供了全局变量的运行时初始化功能。一般情况下，全局变量必须在编译时设置一个初始值，但是有些全局变量依赖与运行期间才能得到的数据作为初始值。这导致这些全局变量需要在运行时发生变化，即需要重新设置初始值之后才能使用。如果我们手动实现，需要把这种全局变量声明为static mut并衍生出很多unsafe代码。这里借助lazy_static!声明一个AppManager结构的名为APP_NAMAGER的全局实例，且只有在它第一次被使用到的时候，才会进行实际的初始化工作。\n为了满足我们的需求，我们要实现一些AppManager的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // os/src/batch.rs const APP_BASE_ADDRESS: usize = 0x80400000; const APP_SIZE_LIMIT: usize = 0x20000; impl AppManager { pub fn print_app_info(\u0026amp;self) { println!(\u0026#34;[kernel] num_app = {}\u0026#34;, self.num_app); for i in 0..self.num_app { println!( \u0026#34;[kernel] app_{} [{:#x}, {:#x})\u0026#34;, i, self.app_start[i], self.app_start[i + 1] ); } } pub fn get_current_app(\u0026amp;self) -\u0026gt; usize { self.current_app } pub fn move_to_next_app(\u0026amp;mut self) { self.current_app += 1; } unsafe fn load_app(\u0026amp;self, app_id: usize) { if app_id \u0026gt;= self.num_app { panic!(\u0026#34;All applications completed!\u0026#34;) } println!(\u0026#34;[kernel] Loading app_{}\u0026#34;, app_id); // clear icache asm!(\u0026#34;fence.i\u0026#34;); //clear app area core::slice::from_raw_parts_mut(APP_BASE_ADDRESS as *mut u8, APP_SIZE_LIMIT).fill(0); let app_src = core::slice::from_raw_parts( self.app_start[app_id] as *const u8, self.app_start[app_id + 1] - self.app_start[app_id], ); let app_dst = core::slice::from_raw_parts_mut(APP_BASE_ADDRESS as *mut u8, app_src.len()); app_dst.copy_from_slice(app_src); } } load_app方法，负责将参数app_id对应的应用程序的二进制镜像加载到物理内存以0x80400000起始的位置，这个位置是批处理操作系统和应用程序之间约定的常数地址，在之前我们也调整应用程序的内存布局以同一个地址开头。第36行开始，我们首先将一块内存清空，然后找到待加载应用二进制镜像的位置，并将它复制到正确的位置。它的本质就是将数据从一块内存复制到另一块内存，而从批处理操作系统的角度来看，是将操作系统数据段的一部分数据复制到了一个可以执行代码的内存区域。体现了冯诺伊曼计算机的代码即数据的特征。\n第34行插入了一条汇编指令fence.i，它是用来清除i-cache的。我们知道缓存是存储级结构中提高访存速度很重要的一环。而CPU对物理内存所做的缓存有分为数据缓存(d-cache)和指令缓存(i-cache)两部分，分别在CPU访存和取指时使用。在取指时，对于一个指令地址，CPU会先去i-cache里面查看它是否在某个已缓存的缓存行内，如果在的话它就会直接从高速缓存中拿到指令而不是通过总线访问内存。通常情况下，CPU 会认为程序的代码段不会发生变化，因此 i-cache 是一种只读缓存。但在这里，OS将修改会被 CPU 取指的内存区域，这会使得 i-cache 中含有与内存中不一致的内容。因此OS在这里必须使用fence.i指令手动清空i-cache，让里面所有的内容全部失效，才能够保证CPU访问内存数据和代码的正确性。\n实现特权级的切换 由于处理器具有硬件级的特权级机制，应用程序在用户态特权级运行时，是无法直接通过函数调用访问处于内核态特权级的批处理操作系统内核中的函数。但应用程序又需要得到操作系统提供的服务，所以应用程序和操作系统需要通过某种合作机制完成特权级之间的切换，使得用户态应用程序可以得到内核态操作系统函数的服务。接下来将在RISC-V64处理器提供的U/S特权级下，解决批处理操作系统和应用程序的相互配合，完成特权级切换。\nRISC-V特权级切换 特权级切换的起因 批处理操作系统被设计为运行在内核态特权级，这是作为SEE的RustSBI保证的。而应用程序被设计为运行在用户态特权级，被操作系统为核心的执行环境监督起来。在本篇中，应用程序的执行环境则是批处理系统提供的AEE(Application Execution Environment)。批处理操作系统为了建立好应用程序的执行环境，需要在执行应用之前进行一些初始化工作，并监控应用程序的执行，具体体现在：\n当应用程序被启动时，需要初始化应用程序的用户态上下文，并能切换到用户态执行应用程序 当应用程序发起系统调用之后，需要到批处理操作系统中进行处理 当应用程序执行出错时，需要到批处理系统中杀死该应用并加载运行下一个应用 当应用程序执行结束时，需要到批处理操作系统中加载运行下一个应用 这些处理都涉及到特权级切换，因此需要应用程序、操作系统和硬件一起协同，完成特权级切换机制。\n特权级切换相关的控制状态寄存器 当从一般意义上讨论RISC-V架构的Trap机制时，通常需要注意两点：\n在触发Trap之前CPU运行在哪个特权级 CPU需要切换到哪个特权级来处理该Trap，并在处理完成之后返回原特权级 在本篇中，我们仅考虑如下流程：当CPU在用户态特权级运行应用程序，执行到Trap，切换到内核态特权级，批处理操作系统的对应代码相应Trap，并执行系统调用服务，处理完毕后，从内核态返回到用户态应用程序继续执行后续指令。\n在RISC-V架构中，关于Trap有一条重要规则：在Trap前的特权级不会高于Trap后的特权级。因此如果触发Trap之后切换到S特权级，说明Trap发生之前CPU只能运行在S/U特权级。但无论如何，只要Trap到S特权级，操作系统就会使用S特权级中与Trap相关的控制状态寄存器(CSR)来辅助Trap处理。进入S特权级Trap的相关CSR：\nCSR名 该CSR与Trap相关的功能 sstatus spp等字段给出Trap发生之前CPU处在哪个特权级等信息 sepc 当Trap是一个异常时，记录Trap发生之前执行的最后一条指令的地址 scause 描述Trap的原因 stval 给出Trap附加信息 stvec 控制Trap处理代码的入口地址 特权级切换 当执行一条Trap类指令，如ecall时，CPU发现触发了一个异常并需要进行特殊处理，这涉及到执行环境切换。应用程序被切换回来之后需要从发出系统调用请求的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。应用程序的上下文包括通用寄存器和栈两个主要部分。由于CPU在不同特权级下共享一套通用寄存器，所以在运行操作系统的Trap操作过程中，操作系统也会用到这些寄存器，这会改变应用程序的上下文。因此，与函数调用需要保存函数调用上下文/活动记录一样，在执行操作系统的Trap处理过程之前，我们需要在某个地方保存这些寄存器并在Trap处理结束后恢复这些寄存器。\n除了通用寄存器之外还有一些可能在处理Trap过程中会被修改的CSR，比如CPU所在的特权级。我们要保证它们的变化在我们的预期之内。比如，对特权级转换而言，应该是Trap之前在U特权级，处理Trap的时候在S特权级，返回之后又需要回到U特权级。而对于栈问题则相对简单，只要两个应用程序执行过程中用来记录执行历史的栈所对应的内存区域不想交，就不会产生令我们头痛的覆盖问题和数据破坏问题，也就无需进行保存/恢复。\n特权级切换的具体过程一部分由硬件直接完成，另一部分则需要由操作系统来实现。\n特权级切换的硬件控制机制 当CPU执行完一条指令(例如:ecall)并准备从用户特权级Trap到S特权级时，硬件会自动完成以下事情：\nsstatus的SPP字段会被修改为CPU当前特权级 spec会被修改为Trap处理完成后默认会执行的下一条指令的地址 scause/stval分别会被修改成这次Trap的原因以及相关附加信息 CPU会跳转到stvec所设置的Trap处理入口地址，并将当前特权级设置为S，然后从Trap处理入口地址开始执行 而当CPU完成Trap处理准备返回的时候，需要通过一条S特权级的特权指令sret来完成，这一条指令具体完成以下功能：\nCPU会将当前的特权级按照sstatus的SPP字段设置为U或者S CPU会跳转到spec寄存器指向那条指令，然后继续执行 用户栈与内存栈 在Trap触发的一瞬间，CPU就会切换到S特权级并跳转到stvec\t所指示的位置。但是在正式进入S特权级的Trap之前，上面提到过我们必须保存原控制流的寄存器转台，这一般通过内核栈来保存。注意，我们需要用专门为操作系统准备的内核栈，而非应用程序运行时用到的用户栈。\n使用两个不同的栈主要是为了安全性：如果两个控制流使用同一个栈，在返回之后应用程序就能读到Trap控制流的历史信息，比如内核一些函数的地址，这样会带来安全隐患。于是，我们要做的事，在批处理操作系统中添加一段汇编代码，实现从用户栈切换到内核栈，并在内核栈上保存应用程序控制流的寄存器状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // os/src/batch.rs const KERNEL_STACK_SIZE: usize = 4096 * 2; const USER_STACK_SIZE: usize = 4096 * 2; static KERNEL_STACK: KernelStack = KernelStack { data: [0; KERNEL_STACK_SIZE], }; static USER_STACK: UserStack = UserStack { data: [0; USER_STACK_SIZE], }; #[repr(align(4096))] struct KernelStack { data: [u8; KERNEL_STACK_SIZE], } #[repr(align(4096))] struct UserStack { data: [u8; USER_STACK_SIZE], } KERNEL_STACK_SIZE和USER_STACK_SIZE指出内核栈和用户栈道大小分别为$8KiB$。两个类型是以全局变量的形式实例化在批处理操作系统的.bss段中的。\n我们为两个类型实现了get_sp方法来获取栈顶地址。由于RISC-V中栈是向下增长的，我们只需返回包裹的数组的结尾地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // os/src/batch.rs impl KernelStack { fn get_sp(\u0026amp;self) -\u0026gt; usize { self.data.as_ptr() as usize + KERNEL_STACK_SIZE } } impl UserStack { fn get_sp(\u0026amp;self) -\u0026gt; usize { self.data.as_ptr() as usize + USER_STACK_SIZE } } 于是换栈是非常简单的，只需将sp寄存器的值修改为get_sp的返回值即可。\n接下来是Trap上下文，类似前面提到的函数调用上下文，即在Trap发生时需要保存的物力资源内容，并将其放在一个名为TrapContext的类型中，定义如下：\n1 2 3 4 5 6 7 8 9 10 // os/src/trap/context.rs use riscv::register::sstatus::Sstatus; #[repr(C)] pub struct TrapContext { pub x: [usize; 32], pub sstatus: Sstatus, pub sepc: usize, } 可以看到里面包含所有的通用寄存器x0~x31，还有sstatuc和spec。为什么保存它们呢？\n对于通用寄存器而言，两条控制流运行在不同的特权级，所属的软件也可能由不同的编程语言编写，虽然在Trap控制流中只是会执行Trap处理相关的代码，但依然可以直接或间接调用很多模块，因此很难甚至不可能找出哪些寄存器无需保存，既然如此只能全部保存。但也有一些例外，x0被硬编码成0，它自然不会有变化，还有tp(x4)寄存器，除非我们手动处于一些特殊用途使用它，否则一般也不会被用到。它们虽然无需被保存，但我们仍然为其预留空间，主要是为了后续的实现方便。 对于CSR而言，我们知道进入Trap的时候，硬件会立即覆盖掉scause/stval/sstatus/sepc的全部或是其中一部分。scause/stval的情况是：它总是被Trap处理的第一时间就被使用或者在其他地方保存下来了，因此它没有被修改并造成不良影响的风险。而对于sstatus/sepc而言，它们会在Trap处理的全程有意义（在Trap控制流最后sret的时候还用到了它们），而且确实会出现Trap嵌套的情况使得它们的值被覆盖掉。所以我们需要将它们保存下来，并在sret之前恢复原样。 Trap管理 特权级切换的核心是对Trap的管理。主要涉及如下一些内容：\n应用程序通过ecall进入到内核状态时，操作系统保存被打断的应用程序的Trap上下文 操作系统根据Trap相关的CSR寄存器内容，完成系统调用服务的分发与处理 操作系统完成系统调用服务后，需要恢复被打断的应用程序的Trap上下文，并通过sret让应用程序继续执行 Trap上下文的保存与恢复 首先是具体实现Trap上下文保存和恢复的汇编代码，在批处理操作系统初始化的时候，我们需要修改stvec寄存器来指向正确的Trap处理入口点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // os/src/trap/mod.rs use core::arch::global_asm; use riscv::register::{mtvec::TrapMode, stvec}; global_asm!(include_str!(\u0026#34;trap.S\u0026#34;)); pub fn init() { extern \u0026#34;C\u0026#34; { fn __alltraps(); } unsafe { stvec::write(__alltraps as usize, TrapMode::Direct); } } 这里我们引入了一个外部符号__alltraps，并将stvec设置为Direct模式指向它的地址。我们在os/src/trap/trap.S中实现Trap上下文保存/恢复的汇编代码，分别用外部符号__alltraps和__restore标记为函数，并通过global_asm!宏将这段汇编代码插入进来。\nTrap处理的总体流程如下：首先通过__alltraps将Trap上下文保存在内核栈上，然后跳转到使用Rust编写的trap_handler函数完成Trap分发及处理。当trap_handler返回之后，使用__restore从保存在内核栈上的Trap上下文恢复寄存器。最后通过sret指令回到应用程序执行。\n首先是保存Trap上下文的__alltraps的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # os/src/trap/trap.S .macro SAVE_GP n ld x\\n, \\n*8(sp) .endm .align 2 __alltraps: csrrw sp, sscratch, sp # now sp-\u0026gt;kernel stack, sscratch-\u0026gt;user stack # allocate a TrapContext on kernel stack addi sp, sp, -34*8 # save general-purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they were saved on kernel stack csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it on the kernel stack csrr t2, sscratch sd t2, 2*8(sp) # set input argument of trap_handler(cx: \u0026amp;mut TrapContext) mv a0, sp call trap_handler 第7行我们使用.align将__alltraps的地址4字节对齐，这是RISC-V特权级规范的要求 第9行的csrrw原型是csrrw rd, csr, rs，可以将CSR当前的值读到通用寄存器rd中，然后将通用寄存器rs的值写入该CSR。因此这里起到的是交换sscratch和sp的效果。在这一行之前sp指向用户栈，sscratch指向内核栈，之后sp指向内核栈，sscratch指向用户栈 第12行，我们准备在内核栈上保存Trap上下文，于是预先分配$34 \\times 8$字节的栈帧，这里改动的是sp，说明确实是在内核栈上 第13～24行，保存Trap上下文的通用寄存器x0~x31，跳过x0和tp(x4)，原因之前已经说明。在这里也无需保存sp(x2)，因为我们要基于它来找到每个寄存器应该被保存到的正确的位置。实际上，在栈帧分配之后，我们可用于保存Trap上下文的地址区间为$[sp, sp+8 \\times 34)$，按照TrapContext结构体的内存布局，基于内核栈道位置(sp所指向的地址)来从低地址到高地址分别按顺序放置x0~x31这些通用寄存器，最后是sstatus和sepc。因此通用寄存器xn应该被保存在地址区间$[sp+8n,sp+8(n+1))$。为了简化代码，x5~x31这27个通用寄存器我们通过类似循环的.rept每次使用SAVE_GP宏来保存，其实质是相同的。注意我们需要在trap.S开头加上.altmacro才能正确使用.rept命令 第25～28行，将CSR sstatus和sepc的值分别读到寄存器t0和t1中然后保存到内核栈对应的位置上。指令csrr rd, csr功能就是将CSR的值读到寄存器rd中 第30～31行专门处理sp的问题。首先将sscratch的值读取到寄存器t2并保存到内核栈上。注意：此时sscratch指向用户栈，sp指向内核栈 第33行令a0\u0026lt;-sp，让寄存器a0指向内核栈的栈指针也就是我们刚刚保存的Trap上下文的地址，这是由于我们接下来调用trap_handler进行Trap处理，它的第一个参数cx由调用规范要从a0中获取。而Trap处理函数trap_handler需要Trap上下文的原因在于：它需要知道其中某些寄存器的值，比如在系统调用的时候应用程序传过来的syscall ID和对应参数。 当trap_handler返回之后会从调用trap_handler的下一条指令开始执行，也就是从栈上的Trap上下文恢复的__restore：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # os/src/trap/trap.S .macro LOAD_GP n ld x\\n, \\n*8(sp) .endm __restore: # case1: start running app by __restore # case2: back to U after handling trap mv sp, a0 # now sp-\u0026gt;kernel stack(after allocated), sscratch-\u0026gt;user stack # restore sstatus/sepc ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 # restore general-purpuse registers except sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # release TrapContext on kernel stack addi sp, sp, 34*8 # now sp-\u0026gt;kernel stack, sscratch-\u0026gt;user stack csrrw sp, sscratch, sp sret 第13～26行负责从内核栈顶的Trap上下文恢复通用寄存器和CSR。我们要先恢复CSR再恢复通用寄存器，这样我们使用的三个临时寄存器才能被正确恢复 在第28行之前，sp指向保存了Trap上下文之后的内核栈栈顶，sscratch指向用户栈栈顶。在第28行内核栈上回收Trap上下文所占用的内存，回归进入Trap之前的内核栈栈顶。第30行，再次交换sscratch和sp，现在sp重新只想用户栈栈顶，sscratch也依然保存进入Trap之前的状态并指向内核栈栈顶 在应用程序控制流状态会还原之后，第31行使用sret指令回到U特权级继续运行应用程序控制流 Trap分发与处理 Trap在使用Rust实现的trap_handler函数中完成分发和处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // os/src/trap/mod.rs #[no_mangle] pub fn trap_handler(cx: \u0026amp;mut TrapContext) -\u0026gt; \u0026amp;mut TrapContext { let scause = scause::read(); let stval = stval::read(); match scause.cause() { Trap::Exception(Exception::UserEnvCall) =\u0026gt; { cx.sepc += 4; cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize; } Trap::Exception(Exception::StoreFault) | Trap::Exception(Exception::StorePageFault) =\u0026gt; { println!(\u0026#34;[kernel] PageFault in application, kernel killed it.\u0026#34;); run_next_app(); } Trap::Exception(Exception::IllegalInstruction) =\u0026gt; { println!(\u0026#34;[kernel] IllegalInstruction in application, kernel killed it.\u0026#34;); run_next_app(); } _ =\u0026gt; { panic!( \u0026#34;Unsupported trap {:?}, stval = {:#x}\u0026#34;, scause.cause(), stval ); } } cx } 第4行声明返回值为\u0026amp;mut TrapContext并在第28行将传入的Trap上下文cx原样返回，因此在__restore的时候a0寄存器在调用trap_handler前后并没有发生变化，仍然指向分配Trap上下文之后的内核栈栈顶，和此时sp的值相同，这里的sp\u0026lt;-a0并不会有问题\n第7行根据scause寄存器所保存的Trap的原因进行分发处理。这里我们无须手动操作这些CSR，而是使用Rust的riscv库来更加方便的操作。引入riscv库，需要在os/Cargo.toml中添加：\n1 2 3 4 # os/Cargo.toml [dependencies] riscv = { git = \u0026#34;https://github.com/rcore-os/riscv\u0026#34;, features = [\u0026#34;inline-asm\u0026#34;] } 第8～11行，发现触发Trap的原因是来自于U特权级的Environment Call，也就是系统调用。这里我们首先修改保存在内核栈上的Trap上下文里面sepc，让其增加4。这是因为我们知道这是一个由ecall指令触发的系统调用，在进入Trap的时候，硬件会将sepc设置为这条ecall指令所在的地址。而在Trap返回之后，我们希望应用程序控制流从ecall的下一条指令开始执行。因此我们只需修改Trap上下文里面的sepc，让他增加ecall指令的码长，即4字节。这样在__restore的时候sepc在恢复之后就会指向ecall的下一条指令，并在sret之后从这里开始执行。\n用来保存系统调用返回值的a0寄存器也会同样发生变化。我们从Trap上下文取出作为syscall ID的a7和系统调用的三个参数`\n第12～19行，分别处理应用程序出现访存错误和非法指令错误的情况。此时需要打印错误信息并调用run_next_app直接切换并运行下一个应用程序。\n第20行开始，当遇到目前还不支持的Trap类型的时候，批处理操作系统整个panic报错退出。\n实现系统调用功能 对于系统调用而言，syscall函数并不会实际处理系统调用，而只是根据syscall ID分发到具体的处理函数：\n1 2 3 4 5 6 7 8 9 10 11 12 // os/src/syscall/mod.rs const SYSCALL_WRITE: usize = 64; const SYSCALL_EXIT: usize = 93; pub fn syscall(syscall_id: usize, args: [usize; 3]) -\u0026gt; isize { match syscall_id { SYSCALL_WRITE =\u0026gt; sys_write(args[0], args[1] as *const u8, args[2]), SYSCALL_EXIT =\u0026gt; sys_exit(args[0] as i32), _ =\u0026gt; panic!(\u0026#34;Unsupported syscall_id: {}\u0026#34;, syscall_id), } } 这里我们会将传进来的参数args转化成能够被具体的系统调用处理函数接受的类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // os/src/syscall/fs.rs const FD_STDOUT: usize = 1; pub fn sys_write(fd: usize, buf: *const u8, len: usize) -\u0026gt; isize { match fd { FD_STDOUT =\u0026gt; { let slice = unsafe { core::slice::from_raw_parts(buf, len) }; let str = core::str::from_utf8(slice).unwrap(); print!(\u0026#34;{}\u0026#34;, str); len as isize } _ =\u0026gt; { panic!(\u0026#34;Unsupported fd in sys_write!\u0026#34;); } } } 1 2 3 4 5 6 // os/src/syscall/process/rs pub fn sys_exit(exit_code: i32) -\u0026gt; ! { println!(\u0026#34;[kernel] Application exited with code {}\u0026#34;, exit_code); run_next_app() } sys_write我们将传入的位于应用程序内的缓冲区的开始地址和长度转化成一个字符串\u0026amp;str，然后使用批处理操作系统已经实现的print!宏打印出来。 sys_exit打印退出的应用程序的返回值并同样调用run_next_app切换到下一个应用程序。 执行应用程序 当批处理操作系统初始化完成，或者是某个应用运行结束或出错的时候，我们要调用run_next_app函数切换到下一个应用程序。此时CPU运行在S特权级，而它希望能切换到U特权级。在RISC-V架构中，唯一一种使得CPU特权级下降的方法就是执行Trap返回到特权指令，如sret、mret等。事实上，在从操作系统内核返回到运行应用程序之前，要完成如下这些工作：\n构造应用程序开始执行所需要的Trap上下文 通过__restore函数，从刚构造的Trap上下文中，恢复应用程序执行的部分寄存器 设置sepcCSR的内容为应用程序入口点0x80400000 切换scratch和sp寄存器，设置sp指向应用程序用户栈 执行sret从S特权级切换到U特权级 它们可以通过复用__restore的代码来更容易的实现上述工作。我们只需要在内核栈上压入一个为启动应用程序而特殊构造的Trap上下文，在通过__restore函数，就能让这些寄存器到达启动应用程序所需要的上下文状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // os/src/trap/context.rs impl TrapContext { pub fn set_sp(\u0026amp;mut self, sp: usize) { self.x[2] = sp; } pub fn app_init_context(entry: usize, sp: usize) -\u0026gt; Self { let mut sstatus = sstatus::read(); sstatus.set_spp(SPP::User); let mut cx = Self { x: [0; 32], sstatus, sepc: entry, }; cx.set_sp(sp); cx } } 为TrapContext实现app_init_context方法，修改其中的sepc寄存器为应用程序入口点entry，sp寄存器为我们设定的一个栈指针，并将sstatus寄存器的SPP字段设置为User。\n在run_next_app函数中我们能够看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // os/src/batch.rs pub fn run_next_app() -\u0026gt; ! { let mut app_manager = APP_MANAGER.exclusive_access(); let current_app = app_manager.get_current_app(); unsafe { app_manager.load_app(current_app); } app_manager.move_to_next_app(); drop(app_manager); extern \u0026#34;C\u0026#34; { fn __restore(cx_addr: usize); } unsafe { __restore(KERNEL_STACK.push_context(TrapContext::app_init_context( APP_BASE_ADDRESS, USER_STACK.get_sp(), )) as *const _ as usize); } panic!(\u0026#34;Unreachable in batch::run_current_app!\u0026#34;); } 在17～22行所做的事情就是在内核栈上压入一个Trap上下文，其sepc是应用程序入口0x80400000 ，其sp寄存器指向用户栈，其sstatus的SPP字段被设置为User。push_context的返回值是内核栈压入Trap上下文之后的栈顶，它会被作为__restore的参数，这使得在__restore函数中sp仍然可以指向内核栈道栈顶。这之后，就和执行一次普通的__restore函数调用一样了。\n","permalink":"https://www.niuwx.cn/posts/rcore/os2/","summary":"\u003cp\u003e保障系统安全和多应用支持是操作系统的两个核心目标，本章从这两个目标出发，思考如何设计应用程序，并进一步展现操作系统的一系列新功能:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e构造包含操作系统内核和多个应用程序的单一执行程序\u003c/li\u003e\n\u003cli\u003e通过批处理支持多个程序的自动加载和运行\u003c/li\u003e\n\u003cli\u003e操作系统利用硬件特权级机制，实现对操作系统自身的保护\u003c/li\u003e\n\u003cli\u003e实现特权级的跨越\u003c/li\u003e\n\u003cli\u003e支持跨特权级的系统调用功能\u003c/li\u003e\n\u003c/ul\u003e","title":"rCore-os2-批处理系统"},{"content":"从零开始使用Rust写一个基于RISC-V架构的类Unix内核.\n前置知识:\nRust基础语法和一些进阶语法（Trait、函数式编程，Unsafe） Git 简单汇编 参考文档:\nrCore rCore-Tutorial-v3 构建应用程序 1 cargo new os 执行此命令创建一个名为os的项目。\n1 2 3 fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } 创建项目后os/src/main.rs中已经有了“Hello, world!”的代码。\n1 cargo run 打开os文件夹后，执行此命令后可以看到控制台输出Hello, world!。\n但是，我们享受到的编程和执行程序如此方便背后有着从硬件到软件的多种机制的支持。尤其是对于应用程序的运行，需要有一个强大的执行环境来帮助。\n应用程序执行环境 现代通用操作系统上的应用程序运行需要下面多层次的执行环境栈的支持:\n我们的应用位于最上层，可以通过调用不同编程语言提供的标准库或者其他第三方库对外提供的功能强大的函数接口，使得仅需少量的代码就能完成复杂的功能。实际上这些库属于应用程序的执行环境(Execution Environment)，在我们通常不会注意到的地方，它们还会在执行应用之前完成一些初始化工作，并在应用程序执行的时候对它进行监控。\n从内核/操作系统的角度来看，它上面的一切都属于用户态，而它自身属于内核态。无论用户态应用如何编写，某些功能总要直接或者间接的通过内核/操作系统提供的系统调用(System Call)来实现。因此系统调用充当了用户和内核之间的边界。\n内核作为用户态的执行环境，它不仅要提供系统调用接口，还需要对用户态应用的执行进行监控的管理。\n平台与目标三元组 现代编译器工具集以C编译器为例，主要工作流程如下：\n1 2 3 4 1. 预处理: 源代码(source code) -\u0026gt; 预处理器(preprocessor) -\u0026gt; 宏展开的源代码 2. 编译: 宏展开的源代码 -\u0026gt; 编译器(compiler) -\u0026gt; 汇编程序 3. 汇编: 汇编程序 -\u0026gt; 汇编器(assembler) -\u0026gt; 目标代码(object code) 4. 链接: 目标代码 -\u0026gt; 链接器(linker) -\u0026gt; 可执行文件(executables) 编译应用程序时，编译器将其源代码通过编译、链接得到的可执行文件时需要知道程序要在哪个平台运行。这些平台主要指CPU类型、操作系统类型和标准运行时库的组合。\n我们通过``目标三元组(Target triple)`来描述一个目标平台。它一般包括CPU架构、CPU厂商、操作系统和运行时库。\n我们可以通过rustc来输出rust的默认配置信息：\n1 2 3 4 5 6 7 8 $ rustc --version --verbose rustc 1.63.0 (4b91a6ea7 2022-08-08) binary: rustc commit-hash: 4b91a6ea7258a947e59c6522cd5898e7c0a6a88f commit-date: 2022-08-08 host: aarch64-apple-darwin release: 1.63.0 LLVM version: 14.0.5 执行结果中，host表明默认目标平台是aarch64-apple-darwin,CPU架构是aarch64,供应商是apple,操作系统是darwin。\n我们想要在另一个硬件平台上运行Hello, world!，这与之前的默认平台不同，CPU架构需要从aarch64换到risc-v。\n通过rustc来输出Rust编译器支持那些基于risc-v的平台:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ rustc --print target-list | grep riscv riscv32gc-unknown-linux-gnu riscv32gc-unknown-linux-musl riscv32i-unknown-none-elf riscv32im-unknown-none-elf riscv32imac-unknown-none-elf riscv32imac-unknown-xous-elf riscv32imc-esp-espidf riscv32imc-unknown-none-elf riscv64gc-unknown-freebsd riscv64gc-unknown-linux-gnu riscv64gc-unknown-linux-musl riscv64gc-unknown-none-elf riscv64imac-unknown-none-elf 修改目标平台 我们希望将程序一直到RICV目标平台riscv64gc-unknown-none-elf上运行。\nPS: riscv64gc-unknown-none-elf 的CPU架构是riscv64gc，厂商是unknown，操作系统是none， elf表示没有标准的运行时库。没有任何系统调用的封装支持，但可以生成ELF格式的执行程序。我们不选择有linux-gnu支持的riscv64gc-unknown-linux-gnu，是因为我们的目标是开发操作系统内核，而非在linux系统上运行的应用程序。 使用cargo编译或编译运行时，可以使用 --target \u0026lt;target triple\u0026gt;来支持不同平台。\n1 cargo run --target riscv64gc-unknown-none-elf 执行此命令后报错，是由于目标平台上没有Rust标准库std，也不存在任何受OS支持的系统调用，这样的平台我们称为裸机平台(bare-metal)。\n既然不支持rust的std标准库，那为什么要使用rust呢？ 除了std之外，rust还有一个不需要任何操作系统支持的核心库core，它包含了rust相当一部分的核心机制。\n移除标准库依赖 接下来将移植上述的Hello, world!程序到RV64GC平台，所以我们要移除程序对Rust std标准库的依赖 ，\n因为Rust std标准库需要操作系统内核的支持。我们需要添加能够支持应用的裸机级别的库操作系统(LibOS)。\n由于后续需要rustc编译器缺省生成RISC-V 64 的目标代码，首先需要给rustc添加一个target: riscv64gc-unknown-none-elf\n1 $ rustup target add riscv64gc-unknown-none-elf 然后在os目录下新建.cargo目录，再次目录下创建config文件\n1 2 3 # os/.cargo/config [build] target = \u0026#34;riscv64gc-unknown-none-elf\u0026#34; 做此调整之后，Cargo默认会使用riscv64gc作为目标平台。\n之后执行cargo build输出如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ cargo build Compiling os v0.1.0 (/Users/ther/WorkSpace/rCore/os) error[E0463]: can\u0026#39;t find crate for `std` | = note: the `riscv64gc-unknown-none-elf` target may not support the standard library = note: `std` is required by `os` because it does not declare `#![no_std]` error: cannot find macro `println` in this scope --\u0026gt; src/main.rs:2:5 | 2 | println!(\u0026#34;Hello, world!\u0026#34;); | ^^^^^^^ error: `#[panic_handler]` function required, but not found For more information about this error, try `rustc --explain E0463`. error: could not compile `os` due to 3 previous errors 我们来解释报错信息:\n第一个error表示没有找到标准库std。具体原因报错信息也做了解释，riscv64gc-unknown-none-elf作为目标平台，并不支持标准库std。可以使用#![no_std]来告诉Rust编译器不使用std标准库而是使用``core`。 第二个error表示没有找到println!宏。这是由于之前println!宏由std标准库提供，此时并不能支持std标准库，而我们也没能自己实现。 第三个error是由于没能找到panic!宏的具体实现，这个原因有点类似于第二个error的原因。使用Rust编写程序时，我们常常会遇到一些无法恢复的致命错误，导致程序无法继续运行，这时会手动或自动调用panic!宏来打印错误的位置。所以Rust编译器在编译程序时，从安全性考虑，需要有panic!宏的具体实现。在std标准库中提供了panic!的具体实现，但是在更底层的核心库core中只有一个panic!宏的空壳，所以我们需要先自行实现一个简陋的panic处理函数。报错信息中也给出了提示，使用#[panic_handler]。 1 2 3 4 5 // os/src/main.rs #![no_std] mod lang_items; fn main() {} 1 2 3 4 5 6 7 // os/src/lang_items.rs use core::panic::PanicInfo; #[panic_handler] fn panic(_info: \u0026amp;PanicInfo) -\u0026gt; ! { loop {} } 执行cargo build后依旧会报错:\n1 2 3 4 5 $ cargo build Compiling os v0.1.0 (/Users/ther/WorkSpace/rCore/os) error: requires `start` lang_item error: could not compile `rCore` due to previous error 编译器提示我们缺少了一个名为start的语义项。之前提到语言标准哭和三方库作为应用程序的执行环境，需要负责在执行应用程序之前进行一些初始化工作，然后才跳转到应用程序的入口点（跳转到我们编写的main函数）开始执行。实际上start语义项代表了std标准库在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。\n最简单的解决方案就是直接不让编译器使用这项功能。\n1 2 3 4 5 // os/src/main.rs #![no_std] #![no_main] mod lang_items; //在开头加入设置#![no_main]告诉编译器我们没有一般意义上的main函数，并删除原来的main函数。 1 2 3 $ cargo build Compiling os v0.1.0 (/Users/ther/WorkSpace/rCore/os) Finished dev [unoptimized + debuginfo] target(s) in 0.05s 至此，我们成功的移除了标准库依赖，通过了编译器检查并生成执行码。但是原有的功能却被弱化甚至删除，接下来我们会以自己的方式来重塑这些基本功能。\n分析被移除标准库的程序 对于上面这个被移除标准库的应用程序，通过了编译器的检查和编译，形成了二进制代码。但这个二进制代码是怎样的，它能否被正常执行呢？为了分析这些程序，首先需要安装 cargo-binutils 工具集：\n1 2 $ cargo install cargo-binutils $ rustup component add llvm-tools-preview 我们可以通过各种工具来分析目前的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # 文件格式 $ file target/riscv64gc-unknown-none-elf/debug/os target/riscv64gc-unknown-none-elf/debug/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, with debug_info, not stripped # 对二进制程序os的分析可以看出它好像是一个合法的RISC-V可执行程序 # 文件头信息 $ rust-readobj -h target/riscv64gc-unknown-none-elf/debug/os File: target/riscv64gc-unknown-none-elf/debug/os Format: elf64-littleriscv Arch: riscv64 AddressSize: 64bit LoadName: \u0026lt;Not found\u0026gt; ElfHeader { Ident { Magic: (7F 45 4C 46) Class: 64-bit (0x2) DataEncoding: LittleEndian (0x1) FileVersion: 1 OS/ABI: SystemV (0x0) ABIVersion: 0 Unused: (00 00 00 00 00 00 00) } Type: Executable (0x2) Machine: EM_RISCV (0xF3) Version: 1 Entry: 0x0 ProgramHeaderOffset: 0x40 SectionHeaderOffset: 0x1B40 Flags [ (0x5) EF_RISCV_FLOAT_ABI_DOUBLE (0x4) EF_RISCV_RVC (0x1) ] HeaderSize: 64 ProgramHeaderEntrySize: 56 ProgramHeaderCount: 3 SectionHeaderEntrySize: 64 SectionHeaderCount: 14 StringTableSectionIndex: 12 } # 通过rust-readobj工具进一步分析，发现入口地址Entry是0x0 # 反汇编导出汇编程序 $ rust-objdump -S target/riscv64gc-unknown-none-elf/debug/os target/riscv64gc-unknown-none-elf/debug/os:\tfile format elf64-littleriscv # 经过反汇编，并没有生成汇编代码，所以基本可以断定，这个二进制程序虽然合法，但它是一个空程序。 QEMU模拟器 我们编写的内核主要在Qemu模拟器上运行来检验其正确性。\n1 2 3 4 5 6 # 此命令用于启动Qemu并运行我们的内核 $\tqemu-system-riscv64 \\ # 模拟64位RISC-V架构的计算机 -machine virt \\ # 将模拟的64位RISC-V计算机设置为名为virt的虚拟计算机 -nographic \\ # 表示不需要提供图形界面 -bios ../bootloader/rustsbi.bin \\ # Qemu开机时用来初始化的引导加载程序bootloader -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 # loader属性可以在Qemu开机前将宿主机的文件载入到指定物理内存地址。 virt平台，物理内存的起始物理地址为0x80000000，物理内存的默认大小为128MiB，物理内存可以通过-m进行调整。\n计算机加电之后的启动流程可以分成若干个阶段，每个阶段由一层软件负责，承担相应的初始化工作，并在此之后跳转到下一层软件的入口地址，也就是将计算机的控制权移交给下一层软件。Qemu模拟的启动流程分为三个阶段：\n由固化在Qemu中的一小段汇编程序负责 由bootloader负责 由内核镜像负责。 在使用上述命令启动Qemu后，bootloader将被加载到物理地址以0x80000000开头的区域，同时内核镜像将被加载到物理地址以0x80200000开头的区域。\n程序内存布局与编译流程 程序内存布局 将源代码编译为可执行文件后，这些看似杂乱无章的字节可以被分成代码和数据两部分：\n代码部分由一条条可以被CPU解码并执行的指令组成 数据部分只是被CPU视作可读写的内存空间 实际上，我们还可以根据具体功能将这两个部分划分为更小的单位：段(Section)。不同的段被编译器放在内存不同的位置上，这就构成了程序的内存布局。一种典型的程序相对内存布局如下：\n.text：代码段，存放程序所有的汇编代码 .rodata：已初始化数据段，只读全局数据，通常是一些常熟或者是常量字符串 .data：已初始化数据段，可修改的全局数据 .bss：未初始化数据段，保存程序中为初始化的全局变量，通常由程序的加载者代为进行数据零初始化 heap：堆，用于存放程序运行时动态分配的数据，向高地址增长 stack：栈，不仅用于函数调用上下文的保存与恢复，每个函数作用域的局部变量也被编译器放在它的栈帧内，向低地址增长 编译流程 从源代码到可执行文件的编译流程可以被细化成多个阶段：\n编译-\u0026gt;汇编-\u0026gt;链接 汇编器输出的每个目标文件都有一个独立的内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情就是将所有输入的目标文件整合成一个整体的内存布局：\n首先将不同目标文件的段在目标内存布局中重新排布，内存布局存在冲突则合并消除冲突 其次将符号替换为具体地址 内核的第一条指令 1 2 3 4 5 # os/src/entry.asm .section .text.entry # 表示将后面的内容放到名为.text.entry 的段中 .global _start # 告知编译器，这是一个全局符号，可以被其他目标文件使用 _start: li x1, 100 # 向寄存器x1中加载一个立即数100 在main.rs中嵌入这段汇编代码\n1 2 3 4 5 6 7 // os/src/main.rs #![no_std] #![no_main] mod lang_items; use core::arch::global_asm; global_asm!(include_str!(\u0026#34;entry.asm\u0026#34;)); 调整内核的内存布局 为了实现与Qemu的正确对接，我们可以通过链接脚本调整链接器的行为。\n1 2 3 4 5 6 7 8 9 # os/.cargo/config [build] target = \u0026#34;riscv64gc-unknown-none-elf\u0026#34; [taaarget.riscv64gc-unknown-none-elf] rustflags = [ \u0026#34;-Clink-arg=-Tsrc/linker.ld\u0026#34;, \u0026#34;-Cforce-frame-pointers=yes\u0026#34;, ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # os/src/linker.ld OUTPUT_ARCH(riscv) # 设置目标平台 ENTRY(_start) # 设置整个程序的入口点，_start为entry.asm中定义的全局符号 BASE_ADDRESS = 0x80200000; # 定义常量 SECTIONS { . = BASE_ADDRESS; skernel = .; stext = .; .text : { *(.text.entry) # * *(.text .text.*) } . = ALIGN(4K); etext = .; srodata = .; .rodata : { *(.rodata .rodata.*) *(.srodata .srodata.*) } . = ALIGN(4K); erodata = .; sdata = .; .data : { *(.data .data.*) *(.sdata .sdata.*) } . = ALIGN(4K); edata = .; .bss : { *(.bss.stack) sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } . = ALIGN(4K); ebss = .; ekernel = .; /DISCARD/ : { *(.eh_frame) } } 之后执行命令:\n1 2 3 $ cargo build --release Compiling os v0.1.0 (/Users/ther/WorkSpace/rCore/os) Finished release [optimized] target(s) in 0.40s 上述命令以release模式生成了内核可执行文件，它的位置在 target/riscv64gc-unknown-none-elf/release/os。\n手动加载内核可执行文件 上面得到的内核可执行文件完全符合了我们对于内存布局的要求，但是不能将其直接提交给Qemu使用，因为它除了实际会用到的代码和数据段之外，还会有一些多余的元数据，这些元数据无法被Qemu在加载文件时利用，且会使代码和数据段被加载到错误的位置。如下图所示：\n如果直接将内核可执行文件os加载到Qemu内存的0x80200000处，由于内核可执行文件的开头是一段缘数据，这会导致Qemu内存在0x80200000无法找到内核第一条指令，也就意味着RustSBI无法正常将计算机控制权转交给内核。\n执行命令可丢弃内核可执行文件中的元数据得到内核镜像:\n1 $ rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/debug/os -O binary target/riscv64gc-unknown-none-elf/os.bin 基于GDB验证启动流程 1 2 3 4 5 6 $ qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios ../bootloader/rustsbi.bin \\ -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \\ -s -S 上述命令在之前提到的启动Qemu模拟器的命令的基础上加了-s、-S两个参数：\n-s：使Qemu监听本地TCP端口1234等待GDB客户端连接 -S：使Qemu在收到GDB的请求后再开始运行 启动GDB客户端连接到Qemu：\n1 2 3 4 $ riscv64-unknown-elf-gdb \\ -ex \u0026#39;file target/riscv64gc-unknown-none-elf/release/os\u0026#39; \\ -ex \u0026#39;set arch riscv:rv64\u0026#39; \\ -ex \u0026#39;target remote localhost:1234\u0026#39; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 (gdb) b *0x80200000 # 在0x80200000处打个断点 Breakpoint 1 at 0x80200000 (gdb) c Continuing. Breakpoint 1, 0x0000000080200000 in ?? () (gdb) x/5i $pc =\u0026gt; 0x80200000:\tli\tra,100 # 可以看到我们entry.asm中的 li x1, 100，ra是寄存器x1的别名 0x80200004:\tunimp 0x80200006:\tunimp 0x80200008:\tunimp 0x8020000a:\tunimp (gdb) si # 继续执行下一条指令 0x0000000080200004 in ?? () (gdb) p/d $x1 # 以十进制打印寄存器x1的值 $1 = 100 (gdb) p/x $sp # 检查此时栈指针sp的值 $2 = 0x0 为内核支持函数调用 经过上述流程，我们已经成功的在Qemu上执行了内核的第一条指令，它是我们在entry.asm中手写的汇编代码得到的。但是我们的目的并不是使用汇编来编写内核，绝大部分功能还是要是用Rust来实现。\n不过为了将控制权转交给我们使用Rust编写的内核入口，我们还是需要编写部分汇编代码。和之前一样，这些汇编代码还是放在entry.asm中并在控制权被转交给内核后最先被执行，但是它们的功能会较之前更加复杂：\n首先设置栈，使得在内核中进行函数调用 之后直接调用使用Rust编写的内核入口点，从而控制权便被移交给了Rust代码 函数调用与栈 首先从汇编指令的级别分析一段程序的执行，假设CPU一次执行的指令的物理地址序列为${a_n}$。\n其中最简单的就是CPU一条一条连续向下执行指令，但执行序列并不总是符合这种模式，当位于物理地址${a_n}$的指令是一条跳转指令时，该模式可能被破坏。跳转指令对应于我们在程序中构造的控制流(Control Flow)的多种不同结构，比如分支结构和循环结构，用来实现这两种结构的跳转指令，只需实现跳转功能，也就是将pc寄存器设置到一个指定地址即可。\n另一种控制流结构则显得更加复杂：函数调用(Function Call)。同样使用汇编指令来分析函数调用的过程，在调用函数时，需要有一条指令跳转到被调用函数的位置，但是在被调用函数返回时，我们需要返回到那条掉转过来的指令的下一条继续执行。如果是之前提到的两种结构，执行结束后返回的地址在编译期已确定，但是对于函数调用来说，在对应的函数调用发生之前是不知道的，也就是说函数调用的返回跳转是跳转到一个函数调用发生时才能确定的地址。\n对此，指令集必须给用于函数调用的跳转指令一些额外的能力，而不只是单纯的跳转。在RISC-V架构上，有两条指令即符合这样的特征：\n指令 指令功能 jal rd, imm[20:1] rd\u0026lt;-pc+4pc\u0026lt;-pc+imm jalr rd, (imm[11:0])rs rd\u0026lt;-pc+4pc\u0026lt;-rs+imm rs：表示源寄存器(Source Register) imm：表示立即数(Immediate)，是一个常数，与源寄存器构成了输入部分 rd：表示目标寄存器(Destination Register)，它是指令的输出部分 从中可以看出，这两条指令在设置pc寄存器完成跳转指令之前，将当前跳转指令的下一条指令地址保存在了rd寄存器中。在RISC-V架构中，通常使用ra寄存器作为rd对应的具体寄存器，因此在函数返回的时候，直接跳转回ra保存的地址即可。\n在进行函数调用时，通过jalr指令保存返回地址并实现跳转；在函数调用结束返回时，通过ret伪指令回到跳转之前的下一条指令继续执行。这样，RISC-V的两条指令就实现了函数调用流程的核心机制。\n由于我们在ra寄存器中保存返回地址，要保证在函数执行的全程不发生变化，否则ret之后就会跳转到错误的位置。事实上编译器除了函数调用的相关指令外确实是基本不使用ra寄存器，也就是说在函数中没有调用其他函数，那ra的值不会发生变化。但是在实际编写代码的过程中，我们常常有函数多层嵌套调用的场景，如果我们试图在函数F中调用函数G，那么在跳转到函数G的同时，ra会被覆盖成这条指令的下一条地址，而ra之前所保存的函数F的返回地址将永久丢失。\n因此，为了能够正确实现嵌套函数调用的控制流，我们必须通过某种方式来保证在一个函数调用子函数的前后，ra寄存器的值不发生变化。但实际上，这并不仅仅局限于ra一个寄存器，而是作用于所有的通用寄存器。由于编译器是独立编译每个函数的， 因此一个函数并不知道它所调用的子函数修改了哪些寄存器。而对于一个函数而言，在调用子函数的过程中某些寄存器的值被覆盖的确会对这个函数的执行产生影响。\n我们将由于函数调用，在控制流转移前后需要保持不变的寄存器集合称之为函数调用上下文(Function Call Context)。\n由于每个CPU只有一套寄存器，所以我们若想在调用子函数时保持函数上下文不变，就需要物理内存的辅助。确切的说，就是在子函数调用之前，我们需要在物理内存中的一个区域保存(Save)函数调用上下文中的寄存器；而在子函数执行完毕后，我们会从内存中上述同样的区域读取并恢复(Restore)函数调用上下文中的寄存器。实际上，这一工作由子函数的调用者和被调用者共同完成。函数调用上下文中的寄存器被分为如下两类:\n被调用者保存(Callee-Saved)寄存器: 被调用的函数可能会覆盖这些寄存器，需要被调用者函数来保存的寄存器。即由被调用的函数来保证调用前后，这些寄存器保持不变。 调用者保存(Caller-Saved)寄存器: 被调用的函数可能会覆盖这些寄存器，需要调用者函数来保存的寄存器。即由发起调用的函数来保证调用前后，这些寄存器保持不变。 具体过程如下：\n调用函数: 首先保存不希望在函数调用过程中发生变化的调用者保存寄存器，然后通过jal/jalr指令调用子函数，返回之后恢复这些寄存器。 被调用函数: 在被调用函数的起始，先保存函数执行过程中被用到的被调用者保存寄存器，然后执行函数，在函数退出之前恢复这些寄存器。 调用规范 调用规范(Calling Convention)约定在某个指令集架构上，某种编程语言的函数调用如何实现。它包括以下内容：\n函数的输入参数和返回值参数如何传递 函数调用上下文中调用者/被调用者保存寄存器的划分 其它的在函数调用流程中对于寄存器的使用方法 RISC-V架构上的C语言调用规范\n栈 之前提到的函数调用时需要在物理内存中保存上下文中的寄存器，实际上，这块物理内存更加确切的名字是栈(Stack)。sp寄存器用来保存栈指针(Stack Pointer)，它指向内存中的栈顶地址。在RISC-V架构中，栈从高地址向低地址增长。在一个函数中，作为起始的开场代码负责分配一块新的栈空间，即将sp的值减小相应的字节数，于是物理地址区间$[新sp, 旧sp)$对应的物理内存的一部分便可以被这个函数用来进行函数调用上下问的保存/恢复，这块物理地址被称为这个函数的栈帧(Stackframe)。同理，函数中的结尾代码负责将开场代码分配的栈帧回收，也就是将sp的值增加相同的字节数以回到分配之前的状态。这同样也解释了为何sp是一个被调用者保存的寄存器。\n在合适的编译选项设置之下，一个函数的栈帧内容可能如下所示：\n它的开头和结尾分别在sp(x2)和fp(s0)所指向的地址。按照地址从高到低分别由以下内容，它们都是通过sp加上一个偏移量来访问的:\nra寄存器保存其返回之后的跳转地址，调用者保存寄存器 父亲栈帧的结束地址fp，被调用者保存寄存器 其他被调用者保存寄存器s1～s11 函数所使用到的局部变量 因此，栈上多个fp信息实际上保存了一条完整的函数调用链，通过适当的方式我们可以实现对函数调用关系的跟踪。\n至此，此节基本说明了函数调用如何实现。不过我们暂时可以忽略这些细节，我们只需在初始化阶段完成栈道设置，也就是设置好栈指针sp寄存器，编译器会帮助我们自动完成后面的函数调用相关机制的代码生成。\n分配并使用启动栈 1 2 3 4 5 6 7 8 9 10 11 12 13 # os/src/entry.asm .section .text.entry .global _start _start: la sp, boot_stack_top # 将指针sp设置为之前分配的启动栈栈顶地址 call rust_main # 调用Rust编写的内核入口点rust_main,将控制权交给Rust代码 .section .bss.stack # 将这块空间放置在一个名为.bss.stack的段中 .global boot_stack boot_stack: .space 4096*16 # 预留4096*16字节64KiB的空间用作程序的栈空间 .global boot_stack_top boot_stack_top: 1 2 3 4 5 6 7 # os/src/linker.ld .bss : { *(.bss.stack) # .bss.stack段被汇集到.bss段中 sbss = .; *(.bss .bss.*) *(.sbss .sbss.*) } 1 2 3 4 5 6 7 8 9 10 11 12 // os/src/main.rs #![no_std] #![no_main] mod lang_items; use core::arch::global_asm; global_asm!(include_str!(\u0026#34;entry.asm\u0026#34;)); #[no_mangle] pub fn rust_main() -\u0026gt; ! { loop {} } 在main.rs中，通过宏对rust_main标记，避免编译器对它的名字进行混淆，否则在链接的时候，entry.asm将找不到main.rs提供的外部符号rust_main，导致链接失败。在rust_main的开场白中，我们将第一次在栈上分配栈帧并保存函数调用上下文，它是内核运行全程最深的栈帧。\n我们顺便完成对.bss段的清零，这是内核初始化很重要的一部分，在使用任何被分配到.bss段的全局变量之前我们需要确保.bss段已被清零。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // os/src/main.rs #![no_std] #![no_main] mod lang_items; use core::arch::global_asm; global_asm!(include_str!(\u0026#34;entry.asm\u0026#34;)); #[no_mangle] pub fn rust_main() -\u0026gt; ! { clear_bss(); loop {} } fn clear_bss() { extern \u0026#34;C\u0026#34; { fn sbss(); fn ebss(); } (sbss as usize..ebss as usize).for_each(|p| unsafe { (p as *mut u8).write_volatile(0) }) } 链接脚本linker.ld给出了全局符号sbss和ebss，并指出了需要被清零的.bss段的起始和终止地址。所以只需遍历该地址区间并逐字节清零即可。\n基于SBI服务完成输出和关机 使用RustSBI提供的服务 RustSBI介于底层硬件和内核之间，是内核的底层执行环境。RustSBI提供的执行环境除了为上层应用进行环境初始化，并将计算机控制权移交给内核，还有另一项职责：在上层应用运行时提供服务。当内核发出请求时，计算机转由RustSBI控制来响应内核的请求，待请求处理完毕后，计算机控制权会被交还给内核。但是由于内核并没有与RustSBI链接，内核无法通过函数调用请求RustSBI提供的服务，我们仅仅使用RustSBI构建后的可执行文件，因此内核对于RustSBI的符号一无所知。实际上，内核需要通过另一种复杂的方式来“调用”RustSBI服务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // os/src/sbi use core::arch::asm; #[inline(always)] fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -\u0026gt; usize { let mut ret; unsafe { asm! { \u0026#34;ecall\u0026#34;, inlateout(\u0026#34;x10\u0026#34;) arg0=\u0026gt;ret, in(\u0026#34;x11\u0026#34;) arg1, in(\u0026#34;x12\u0026#34;) arg2, in(\u0026#34;x17\u0026#34;) which, } } ret } 我们将内核与RustSBI通信的相关功能在子模块sbi中实现，因此需要在main.rs中加入mod sbi将该子模块加入项目中。\n在os/src/sbi.rs中：which表示请求RustSBI的服务类型，arg0~arg2表示传递给RustSBI的三个参数，而RustSBI在将请求处理完毕后，会给内核一个返回值，这个返回值也被sbi_all返回。\n我们可以在sbi.rs中定义RustSBI支持的服务类型常量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // os/src/sbi.rs #![allow(unused)] const SBI_SET_TIMER: usize = 0; const SBI_CONSOLE_PUTCHAR: usize = 1; const SBI_CONSOLE_GETCHAR: usize = 2; const SBI_CLEAR_IPI: usize = 3; const SBI_SEND_IPI: usize = 4; const SBI_REMOTE_FENCE_I: usize = 5; const SBI_REMOTE_SFENCE_VMA: usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7; const SBI_SHUTDOWN: usize = 8; use core::arch::asm; #[inline(always)] fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -\u0026gt; usize { let mut ret; unsafe { asm! { \u0026#34;ecall\u0026#34;, inlateout(\u0026#34;x10\u0026#34;) arg0 =\u0026gt; ret, in(\u0026#34;x11\u0026#34;) arg1, in(\u0026#34;x12\u0026#34;) arg2, in(\u0026#34;x17\u0026#34;) which, } } ret } 服务SBI_CONSOLE_PUTCHAR可以用来在屏幕上输出一个字符，我们可以将这个功能使用sbi_call函数来封装：\n1 2 3 pub fn console_putchar(c: usize) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } SBI_SHUTDONW提供关机服务，同样可以封装：\n1 2 3 4 pub fn shutdown() -\u0026gt; ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); panic!(\u0026#34;It should shutdown!\u0026#34;) } 实现格式化输出 上面实现的console_putchar功能过于受限，如果想打印一行Hello,world!则需要多次调用。接下来我们尝试编写基于console_putchar的println!宏。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // os/src/console.rs #![allow(unused)] use crate::sbi::console_putchar; use core::fmt::{self, Result, Write}; struct Stdout; impl Write for Stdout { fn write_str(\u0026amp;mut self, s: \u0026amp;str) -\u0026gt; Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) =\u0026gt; { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) =\u0026gt; { $crate::console::print(format_args!(concat!($fmt, \u0026#34;\\n\u0026#34;) $(, $($arg)+)?)); } } 处理致命错误 错误处理是编程中重要的一环，它能够保证程序的可靠性和可用性。Rust将错误分为可恢复和不可恢复错误两大类，这里我们主要关心不可恢复错误，在遇到不可恢复错误时，Rust程序会直接报错退出，使用panic!宏便会直接出发一个不可恢复错误并使得程序退出。在我们的内核中，目前不可恢复错误的处理机制还不完善：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // os/src/lang_items.rss use crate::println; use crate::sbi::shutdown; use core::panic::PanicInfo; #[panic_handler] fn panic(info: \u0026amp;PanicInfo) -\u0026gt; ! { if let Some(location) = info.location() { println!( \u0026#34;Panicked at {}:{} {}\u0026#34;, location.file(), location.line(), info.message().unwrap() ); } else { println!(\u0026#34;Panicked: {}\u0026#34;, info.message().unwrap()); } shutdown() } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // os/src/main.rs #![no_std] #![no_main] #![feature(panic_info_message)] mod lang_items; mod sbi; #[macro_use] mod console; use core::arch::global_asm; global_asm!(include_str!(\u0026#34;entry.asm\u0026#34;)); #[no_mangle] pub fn rust_main() -\u0026gt; ! { clear_bss(); println!(\u0026#34;Hello, world\u0026#34;); panic!(\u0026#34;Shutdown machine!\u0026#34;); } fn clear_bss() { extern \u0026#34;C\u0026#34; { fn sbss(); fn ebss(); } (sbss as usize..ebss as usize).for_each(|p| unsafe { (p as *mut u8).write_volatile(0) }); } 注意：在main.rs中我们需要加入#![feature(panic_info_message)]才能通过PanicInfo::message获取报错信息。\n使用Qemu运行内核，可以得到结果：\n1 2 Hello, world Panicked at src/main.rs:18 Shutdown machine! 实践作业-实现彩色化LOG 详细原理：ANSI转义序列\n1 echo -e \u0026#34;\\x1b[31mhello world\\x1b[0m\u0026#34; 1 2 3 4 5 6 7 8 9 # Cargo.toml [package] name = \u0026#34;os\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2021\u0026#34; [dependencies] log = \u0026#34;0.4\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // os/src/logger.rs use log::{self, Level, LevelFilter, Log}; use crate::println; struct Logger; impl Log for Logger { fn enabled(\u0026amp;self, _metadata: \u0026amp;log::Metadata) -\u0026gt; bool { true } fn log(\u0026amp;self, record: \u0026amp;log::Record) { if !self.enabled(record.metadata()) { return; } let color = match record.level() { Level::Error =\u0026gt; 31, Level::Debug =\u0026gt; 32, Level::Info =\u0026gt; 34, Level::Trace =\u0026gt; 90, Level::Warn =\u0026gt; 93, }; println!( \u0026#34;\\u{1B}[{}m[{:\u0026gt;5}] {}\\u{1B}[0m\u0026#34;, color, record.level(), record.args(), ); } fn flush(\u0026amp;self) {} } pub fn init() { static LOGGER: Logger = Logger; log::set_logger(\u0026amp;LOGGER).unwrap(); log::set_max_level(match option_env!(\u0026#34;LOG\u0026#34;) { Some(\u0026#34;ERROR\u0026#34;) =\u0026gt; LevelFilter::Error, Some(\u0026#34;WARN\u0026#34;) =\u0026gt; LevelFilter::Warn, Some(\u0026#34;INFO\u0026#34;) =\u0026gt; LevelFilter::Info, Some(\u0026#34;DEBUG\u0026#34;) =\u0026gt; LevelFilter::Debug, Some(\u0026#34;TRACE\u0026#34;) =\u0026gt; LevelFilter::Trace, _ =\u0026gt; LevelFilter::Trace, }); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // os/src/main.rs #![no_main] #![no_std] #![feature(panic_info_message)] mod lang_items; mod sbi; mod logger; use log::*; #[macro_use] mod console; core::arch::global_asm!(include_str!(\u0026#34;entry.asm\u0026#34;)); #[no_mangle] pub fn rust_main() -\u0026gt; ! { extern \u0026#34;C\u0026#34; { fn stext(); fn etext(); fn srodata(); fn erodata(); fn sdata(); fn edata(); fn sbss(); fn ebss(); fn boot_stack(); fn boot_stack_top(); } clear_bss(); logger::init(); error!(\u0026#34;Hello, rCore!\u0026#34;); info!(\u0026#34;.text [{:#x}, {:#x}]\u0026#34;, stext as usize, etext as usize); debug!(\u0026#34;.rodata [{:#x}, {:#x}]\u0026#34;, srodata as usize, erodata as usize); trace!(\u0026#34;.data [{:#x}, {:#x}]\u0026#34;, sdata as usize, edata as usize); warn!(\u0026#34;.bss [{:#x}, {:#x}]\u0026#34;, sbss as usize, ebss as usize); error!( \u0026#34;.stack [{:#x}, {:#x}]\u0026#34;, boot_stack as usize, boot_stack_top as usize ); panic!(\u0026#34;Shutdown machine!\u0026#34;); } fn clear_bss() { extern \u0026#34;C\u0026#34; { fn sbss(); fn ebss(); } (sbss as usize..ebss as usize).for_each(|p| unsafe { (p as *mut u8).write_volatile(0) }); } 运行结果如下：\n","permalink":"https://www.niuwx.cn/posts/rcore/os1/","summary":"\u003cp\u003e从零开始使用Rust写一个基于\u003ccode\u003eRISC-V\u003c/code\u003e架构的类Unix内核.\u003c/p\u003e\n\u003cp\u003e前置知识:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRust基础语法和一些进阶语法（Trait、函数式编程，Unsafe）\u003c/li\u003e\n\u003cli\u003eGit\u003c/li\u003e\n\u003cli\u003e简单汇编\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e参考文档:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rcore-os/rCore\"\u003erCore\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rcore-os/rCore-Tutorial-v3\"\u003erCore-Tutorial-v3\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"rCore-os1-应用程序与基本执行环境"},{"content":"初识进程和线程 认识进程 在Linux系统中，每一个进程都有自己的ID，就如同人的身份证一样。Linux中有一个数据类型pid_t，它定义了进程的ID。\nfork() 首先看下如何创建新的进程，这里需要用到fork()函数，其返回值类型为pid_t。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/unistd.h\u0026gt; void get_pid() { pid_t pid = fork(); if (pid \u0026lt; 0) { printf(\u0026#34;fork error\\n\u0026#34;); exit(1); } else if (pid \u0026gt; 0) { printf(\u0026#34;parent: the pid is %d\\n\u0026#34;, pid); while (1) ; } else { printf(\u0026#34;child: this pid is %d\\n\u0026#34;, pid); while (1) ; } } int main() { get_pid(); return 0; } 执行结果：\n1 2 parent: the pid is 20580 child: this pid is 0 执行结果中有两条输出，分别是父进程和子进程。\n通过命令行执行htop找到对应的进程，我们可以发现父子进程都有其特定的pid，那么为什么程序会输出0呢？\n实际上，在调用fork()函数之后，程序创建了一个子进程，程序本身成为了父进程。\n而fork()的返回值代表什么意义呢？\n负数：创建子进程失败。 零：在子进程中，fork()返回0 正数：在父进程中，fork()返回子进程的pid 至此，以上的疑惑也就迎刃而解了，在这里介绍两个进程相关的函数：\ngetpid()：获取当前进程的pid getppid()：获取当前进程的父进程的pid 接下来再看这段程序：\n增加了一个全局变量和一个函数内部的局部变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/unistd.h\u0026gt; int global_var = 2; void get_pid() { pid_t pid = fork(); int var = 5; if (pid \u0026lt; 0) { printf(\u0026#34;fork error\\n\u0026#34;); exit(1); } else if (pid \u0026gt; 0) { printf(\u0026#34;parent: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var); exit(0); } else { global_var--; var++; printf(\u0026#34;child: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var); exit(0); } } int main() { get_pid(); return 0; } 执行结果：\n1 2 parent: this pid is 22982, global_var = 2, var = 5 child: this pid is 0, global_var = 1, var = 6 在子进程中，global_var与var分别执行的加减操作，但是在父进程中，这两个变量的值都未发生改变，这是为什么呢？\n原因在于：执行fork()函数时，子进程复制了父进程的所有资源，包括内存等等。因此，父子进程属于不同的内存空间，那么子进程中变量发生改变时，父进程中的变量必然不会改变。\nvfork() 除了fork()函数，还有一个vfork()函数，同样是系统调用函数，用来创建子进程。但是这二者是有区别的：vfork()函数在创建子进程时，父子进程共享地址空间。因此子进程中修改的全局变量在父进程中也会被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/unistd.h\u0026gt; int global_var = 2; void get_pid() { pid_t pid = vfork(); int var = 5; printf(\u0026#34;pid = %d\\n\u0026#34;, getpid()); printf(\u0026#34;global_var = %d, var = %d\\n\u0026#34;, global_var, var); if (pid \u0026lt; 0) { printf(\u0026#34;fork error\\n\u0026#34;); exit(1); } else if (pid \u0026gt; 0) { printf(\u0026#34;parent: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var); exit(0); } else { global_var--; var++; printf(\u0026#34;child: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var); exit(0); } } int main() { get_pid(); return 0; } 执行结果：\n1 2 3 4 5 6 pid = 25371 global_var = 2, var = 5 child: this pid is 0, global_var = 1, var = 6 pid = 25370 global_var = 1, var = 5 parent: this pid is 25371, global_var = 1, var = 5 execv() 在fork()与vfork()中，子进程与父进程都运行同样的代码。如果需要子进程执行不同的操作，就要用到execv()函数了\n1 2 3 4 5 6 7 //parent.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc, char* argv[]) { execv(\u0026#34;child\u0026#34;, argv); return 0; } 1 2 3 4 5 6 7 8 9 10 //child.c #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) { puts(\u0026#34;welcome!\u0026#34;); for (int i = 0; i \u0026lt; argc; i++) { puts(argv[i]); } return 0; } 分别编译两个c文件，执行parent.c编译得到的可执行文件：./parent 1 2 3。\n执行结果：\n1 2 3 4 5 welcome! ./parent 1 2 3 进程等待 进程等待就是同步父子进程。可以通过调用wait()函数来实现。\nwait()函数的工作原理是首先判断子进程是否存在， 如果创建失败，子进程不存在，那么就直接退出进程，并提示相关错误信息。如果创建成功，wait()函数将父进程挂起，知道子进程结束，并返回结束的状态和最后结束的子进程的pid。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;wait.h\u0026gt; void exit_s(int status) { if (WIFEXITED(status)) { printf(\u0026#34;normal exist, status = %d\\n\u0026#34;, WEXITSTATUS(status)); } else if (WIFSIGNALED(status)) { printf(\u0026#34;signal exit! status = %d\\n\u0026#34;, WTERMSIG(status)); } } void wait_test() { pid_t pid_a; int status; int ret; pid_a = fork(); if (pid_a \u0026lt; 0) { printf(\u0026#34;child process error\\n\u0026#34;); exit(0); } else if (pid_a \u0026gt; 0) { printf(\u0026#34;the pid of parent is %d\\n\u0026#34;, getpid()); printf(\u0026#34;wait for child ...\\n\u0026#34;); int pid_child = wait(\u0026amp;status); if (pid_child \u0026gt; 0) { printf(\u0026#34;i catch a child process with pid of %d\\n\u0026#34;, pid_child); } exit_s(status); } else { printf(\u0026#34;the pid of child is %d\\n\u0026#34;, getpid()); sleep(3); exit(2); } } int main() { wait_test(); return 0; } 执行结果：\n1 2 3 4 5 the pid of parent is 46045 wait for child ... the pid of child is 46046 i catch a child process with pid of 46046 normal exist, status = 2 在子进程中调用sleep()函数，睡眠3秒，只有子进程完成睡眠，才能正常退出并被父进程捕捉到。在此期间父进程会继续等待下去。在wait函数中会将子进程的状态保存到status中。\n在处理status的exit_s()函数中，调用了几个宏：\nWIFEXITED：当子进程正常退出时，返回真值 WEXITSTATUS：返回子进程正常退出时的状态 WTERMSIG：用于子进程被信号终止的情况 如果在程序执行过程中子进程异常退出，会是怎样的情况呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;wait.h\u0026gt; void exit_s(int status) { if (WIFEXITED(status)) { printf(\u0026#34;normal exist, status = %d\\n\u0026#34;, WEXITSTATUS(status)); } else if (WIFSIGNALED(status)) { printf(\u0026#34;signal exit! status = %d\\n\u0026#34;, WTERMSIG(status)); } } void wait_test() { pid_t pid_a; int status; int ret; pid_a = fork(); if (pid_a \u0026lt; 0) { printf(\u0026#34;child process error\\n\u0026#34;); exit(0); } else if (pid_a \u0026gt; 0) { printf(\u0026#34;the pid of parent is %d\\n\u0026#34;, getpid()); printf(\u0026#34;wait child ...\\n\u0026#34;); int pid_child = wait(\u0026amp;status); if (pid_child \u0026gt; 0) { printf(\u0026#34;i catch a child process with pid of %d\\n\u0026#34;, pid_child); } exit_s(status); } else { printf(\u0026#34;the pid of child is %d\\n\u0026#34;, getpid()); // sleep(3); pid_t pid = getpid(); kill(pid, 9); exit(2); } } int main() { wait_test(); return 0; } 执行结果：\n1 2 3 4 5 the pid of parent is 46749 wait child ... the pid of child is 46750 i catch a child process with pid of 46750 signal exit! status = 9 线程 需要先了解一下进程和线程的区别：\n进程是资源分配的最小单位，每个进程都占有独立内存空间。 线程是程序执行的最小单位，多个线程共享同一个内存空间。 一个进程由几个线程组成，线程与同属一个进程的其他线程共享当前进程拥有的全部资源。 那么，线程有哪些优势呢？\n线程不需要额外的内存申请 线程共享进程内的数据，访问数据方便，而进程则需要通过通信的方式进行。 在linux下，进程使用ps命令查看，线程则通过top命令来查看。还可以通过top -p pid来查看某个进程内的线程。\n先看一个创建进程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void *thread1(void) { int i; for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;this is the first thread\\n\u0026#34;); sleep(1); } } void *thread2(void) { int i; for (int i = 0; i \u0026lt; 5; i++) { printf(\u0026#34;this is the second thread\\n\u0026#34;); sleep(1); } } int main() { int ret = 0; pthread_t id1, id2; pthread_create(\u0026amp;id1, NULL, (void *)thread1, NULL); pthread_create(\u0026amp;id2, NULL, (void *)thread2, NULL); pthread_join(id1, NULL); pthread_join(id2, NULL); return 0; } 在这里，thread1和thread2两个函数分别属于不同的线程。\npthread_t是线程的id。\npthread_create()是创建线程的函数，参数分别是：参数id，线程属性，线程运行函数的起始地址，运行函数的参数。\n注意，由于pthread并非Linux系统的默认库，而是POSIX线程库，所以在编译的时候需要加上-lpthread来显式链接该库：gcc -g main.c -lpthread。\n执行结果：\n1 2 3 4 5 6 7 8 9 10 this is the first thread this is the second thread this is the first thread this is the second thread this is the first thread this is the second thread this is the first thread this is the second thread this is the first thread this is the second thread 进程间通信 进程间的通信包括管道、共享内存、信号量通信、消息队列、套借口(socket)和全双工管道通信。\n管道 管道顾名思义，就如同水管一样，当水从水管的一端流向另一端的时候，水流是单方向的。某一时刻只能从单方向传递数据，不能双向传递，这种就是半双工模式。半双工模式只能一端写数据，一端读数据，先来看一个半双工的例子：\n在父进程中通过pipe()函数创建一个管道，得到管道读端ppe[0]，写端ppe[1]。 在父进程中调用fork()产生一个子进程 在子进程中关闭ppe[0]，往ppe[1]中写入数据，在父进程中关闭ppe[1]，从ppe[0]中读取数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;wait.h\u0026gt; int pipe_test() { int ppe[2]; if (pipe(ppe) == -1) { perror(\u0026#34;not create a new process!\\n\u0026#34;); return 1; } int pid = fork(); if (pid == 0) { close(ppe[0]); printf(\u0026#34;child process send message\\n\u0026#34;); char *message = \u0026#34;happy new year!\\n\u0026#34;; write(ppe[1], message, strlen(message)); } else { close(ppe[1]); sleep(2); printf(\u0026#34;parent process receive message\\n\u0026#34;); char message[100]; int line = read(ppe[0], message, 100); write(STDOUT_FILENO, message, line); wait(NULL); exit(0); } return 0; } int main() { pipe_test(); return 0; } 执行结果：\n1 2 3 child process send message parent process receive message happy new year! 上面这个例子演示了单向通信，如果我们需要双向通信：父进程在读的同时也给子进程写。要实现这样的功能，就必须建立两个管道：一个管道从父进程流向子进程，一个管道从子进程流向父进程。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;wait.h\u0026gt; int pipe_test() { int ppea[2], ppeb[2]; if (pipe(ppea) == -1 || pipe(ppeb) == -1) { perror(\u0026#34;not create a new process!\\n\u0026#34;); return 1; } int pid = fork(); if (pid \u0026lt; 0) { perror(\u0026#34;not create a new process !\u0026#34;); return 1; } else if (pid == 0) { close(ppea[0]); printf(\u0026#34;child process send message\\n\u0026#34;); char *message_send = \u0026#34;happy new year!\\n\u0026#34;; write(ppea[1], message_send, strlen(message_send)); sleep(2); close(ppeb[1]); printf(\u0026#34;child process receive message\\n\u0026#34;); char message_receive[100]; int line = read(ppeb[0], message_receive, 100); write(STDOUT_FILENO, message_receive, line); exit(0); } else { close(ppea[1]); sleep(2); printf(\u0026#34;parent process receive message\\n\u0026#34;); char message_receive[100]; int line = read(ppea[0], message_receive, 100); write(STDOUT_FILENO, message_receive, line); close(ppeb[0]); printf(\u0026#34;parent process send message\\n\u0026#34;); char *message_send = \u0026#34;happy new year my child!\\n\u0026#34;; write(ppeb[1], message_send, strlen(message_send)); exit(0); } return 0; } int main() { pipe_test(); return 0; } 执行结果：\n1 2 3 4 5 6 child process send message parent process receive message happy new year! parent process send message child process receive message happy new year my child! 命令管道 上个部分介绍了管道，然而管道只能在有关联的进程中进行通信，也就是父子进程之间。那如果不相关的两个进程间也需要进行通信，这里就需要用到命令管道了，通常称为FIFO。通过这个名称可以知道命令管道遵循先进先出的原则，与数据结构中的队列类似。\n创建一个命令管道有两种方法：\n通过shell命令创建 通过函数创建命名管道 shell命令创建命名管道 首先通过mkfifo创建一个管道文件test：mkfifo test 通过cat ./test查看，此时，管道文件中没有任何数据 打开另一个终端，向FIFO中写入数据：echo \u0026quot;hello fifo\u0026quot; \u0026gt; ./test 再次通过cat ./test查看，将会得到之前写入的数据。 函数创建命名管道 下面通过c来实现命令管道：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //write.c #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int mkfifo_write() { int ppe = open(\u0026#34;./fifo\u0026#34;, O_RDWR); printf(\u0026#34;write the message:\\n\u0026#34;); char* message = \u0026#34;hello world\\n\u0026#34;; write(ppe, message, strlen(message)); close(ppe); } int main() { mkfifo_write(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //read.c #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int mkfifo_read() { char message[100]; int ppe = open(\u0026#34;./fifo\u0026#34;, O_RDWR); printf(\u0026#34;read the message:\\n\u0026#34;); int line = read(ppe, message, 100); close(ppe); write(STDOUT_FILENO, message, line); } int main(int argc, char* argv[]) { mkfifo_read(); return 0; } 编译后，开启两个终端，一个终端先执行./read，另一个终端再执行./write，第一个终端中就会显示发出的信息。\n","permalink":"https://www.niuwx.cn/posts/linux/linux_c_1/","summary":"\u003ch2 id=\"初识进程和线程\"\u003e初识进程和线程\u003c/h2\u003e\n\u003ch3 id=\"认识进程\"\u003e认识进程\u003c/h3\u003e\n\u003cp\u003e在Linux系统中，每一个进程都有自己的ID，就如同人的身份证一样。Linux中有一个数据类型pid_t，它定义了进程的ID。\u003c/p\u003e","title":"Linux C之进程"},{"content":"前段时间换了系统，开始使用Manjaro，但是驱动问题搞得很头疼，在这里记录一下解决双显卡(amd+nvidia)的显示问题。\n由于Manjaro自带了mhwd，所以下载驱动还是很方便的。但是下载了video-hybrid-amd-nvidia-prime之后，外界显示器会时常卡顿，切换到video-nvidia之后，笔记本的显示器又亮不了。\n需要使用optimus-manager。\n官方文档\n安装：yay -S optimus-manager\n配置：\nsudo vim /etc/sddm.conf，找到DisplayCommand和DisplayStopCommand，行首加#注释。\nsudo vim /etc/optimus-manager/optimus-manager.conf，添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [amd] DRI=3 driver=modesetting tearfree= [intel] DRI=3 accel= driver=modesetting modeset=yes tearfree= [nvidia] DPI=96 PAT=yes allow_external_gpus=no dynamic_power_management=no ignore_abi=no modeset=yes options=overclocking [optimus] auto_logout=yes pci_power_control=no pci_remove=no pci_reset=no startup_auto_battery_mode=integrated startup_auto_extpower_mode=nvidia startup_mode=nvidia switching=none sudo vim /etc/default/grub，在GRUB_CMDLINE_LINUX_DEFAULT中增加nvidia-drm.modeset=1。\ngrub-mkconfig \u0026amp;\u0026amp; update-grub\nPS:启用外接显示器后若KDE无法使用桌面动画，建议安装optimus-manager-qt：yay -S optimus-manager-qt。\n","permalink":"https://www.niuwx.cn/posts/other/manjaro_amd_nvidia/","summary":"前段时间换了系统，开始使用Manjaro，但是驱动问题搞得很头疼，在这里记录一下解决双显卡(amd+nvidia)的显示问题。\n由于Manjaro自带了mhwd，所以下载驱动还是很方便的。但是下载了video-hybrid-amd-nvidia-prime之后，外界显示器会时常卡顿，切换到video-nvidia之后，笔记本的显示器又亮不了。\n需要使用optimus-manager。\n官方文档\n安装：yay -S optimus-manager\n配置：\nsudo vim /etc/sddm.conf，找到DisplayCommand和DisplayStopCommand，行首加#注释。\nsudo vim /etc/optimus-manager/optimus-manager.conf，添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [amd] DRI=3 driver=modesetting tearfree= [intel] DRI=3 accel= driver=modesetting modeset=yes tearfree= [nvidia] DPI=96 PAT=yes allow_external_gpus=no dynamic_power_management=no ignore_abi=no modeset=yes options=overclocking [optimus] auto_logout=yes pci_power_control=no pci_remove=no pci_reset=no startup_auto_battery_mode=integrated startup_auto_extpower_mode=nvidia startup_mode=nvidia switching=none sudo vim /etc/default/grub，在GRUB_CMDLINE_LINUX_DEFAULT中增加nvidia-drm.","title":"Manjaro下双显卡笔记本配置"},{"content":"本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\n简单示例 应用代码 以这段简单的go web代码为例进行介绍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, HandleHello) server := \u0026amp;http.Server{ Addr: \u0026#34;:9090\u0026#34;, } fmt.Println(\u0026#34;Server startup...\u0026#34;) if err := server.ListenAndServe(); err != nil { fmt.Printf(\u0026#34;Server startup failed, err:%v\\n\u0026#34;, err) } } func HandleHello(w http.ResponseWriter, _ *http.Request) { w.Write([]byte(\u0026#34;Hello World\u0026#34;)) } 编写Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 FROM golang:alpine # 设置镜像环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 将本目录下代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件app RUN go build -o app . # 声明服务端口 EXPOSE 9090 # 启动容器时运行的命令 CMD [\u0026#34;/app\u0026#34;] 构建镜像 使用命令构建镜像。\n1 docker build . -t goweb 使用镜像 1 docker run -p 9090:9090 --name goweb-app goweb 使用-p来映射端口，这里容器中的应用需要在9090端口上运行，将其映射到主机的9090端口。也可以将其映射到其他端口，例如-p 8080:9090。\n分段构建 在编译Go程序之后，我们得到了一个可执行的二进制文件，在最终的镜像中我们是不需要go编译器的，只需要一个可以运行二进制文件的容器即可。所以可以通过分段构建，第一步编译出二进制可执行文件，第二步将该可执行文件放进可以运行的环境即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 FROM golang:alpine AS builder # 设置镜像环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 将本目录下代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件app RUN go build -o app . ################### # 最终的小镜像 ################### FROM scratch # 从builder镜像中把/app 拷贝到当前目录 COPY --from=builder /build/app / # 需要运行的命令 ENTRYPOINT [\u0026#34;/app\u0026#34;] 通过分段构建，我们就得到了一个体积非常小的镜像。\n静态资源的拷贝 如果需要部署的程序还需要用到静态资源，那么还需要将静态资源拷贝到镜像中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 FROM golang:alpine AS builder # 设置镜像环境变量 ENV GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 # 移动到工作目录：/build WORKDIR /build # 将本目录下代码复制到容器中 COPY . . # 将我们的代码编译成二进制可执行文件app RUN go build -o app . ################### # 最终的小镜像 ################### FROM scratch COPY /templates /templates COPY /static /static # 从builder镜像中把/app 拷贝到当前目录 COPY --from=builder /build/app / # 需要运行的命令 ENTRYPOINT [\u0026#34;/app\u0026#34;] ","permalink":"https://www.niuwx.cn/posts/go/docker_go/","summary":"\u003cp\u003e本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\u003c/p\u003e","title":"Docker部署Go Web应用"},{"content":"本文以Oh-my-zsh为例，Oh-my-post同样适用。\n如图，使用Windows Terminal连接服务器使用Zsh命令行时，会出现乱码，导致主题无法正常显示。\n解决方法 安装Nerd Fonts，下载喜欢的字体然后右键选择“为所有用户安装”，打开Windows Terminal修改settings.json中的\u0026quot;fontFace\u0026quot;项为Nerd字体即可，注意要更改为其显示的正式名称。\n","permalink":"https://www.niuwx.cn/posts/other/zsh/","summary":"\u003cp\u003e本文以Oh-my-zsh为例，Oh-my-post同样适用。\u003c/p\u003e","title":"Windows oh-my-zsh 命令行出现乱码的原因及解决办法"},{"content":"This is a test for hugo.\n1 2 Test\n1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;Hello World\u0026#34;) } ","permalink":"https://www.niuwx.cn/posts/hello-test/","summary":"\u003cp\u003e\u003cstrong\u003eThis is a test for hugo.\u003c/strong\u003e\u003c/p\u003e","title":"Hello Test"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]