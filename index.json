[{"content":"这篇文章将介绍图论中的拓扑排序。\n什么是拓扑排序？ 对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。\n拓扑排序  入度：指向v的边的个数叫做v的入度。 出度：v指向的点的个数叫做v的出度。  如果一个点的入度是0，那么说明这个点是起点（起点不止一个）。如果一个点的出度为0，那么说明这个点排在最后。\n举例说明：\n如图所示，这是一个有向无环图，其指向顺序为a,(b,c),d,e,则abcde和acbde都是这个图的拓扑排序。\n很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。\n拓扑排序的实现 DFS和BFS都可以实现拓扑排序。\nBFS实现拓扑排序 这种算法也叫做Kahn算法\n继续使用上面的例子进行说明\nBFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。\n无前驱的顶点优先就是顺着找，a的入度为0，则其为起点，a入队；\na出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；\n目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；\nb出队，b指向d，d入度减一，d入度为零，入队；\nd出队，d指向e，e入度减一，e入度为零，入队；\ne出队，无后续结点，结束。\n由上述过程可得拓扑排序为acbde。\n时间复杂度 假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。\n代码实现如下：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int T, n, m, u, v; int deg[N]; int vis[N]; int dest[N]; vector\u0026lt;int\u0026gt; g[N]; queue\u0026lt;int\u0026gt; q; bool toposort() { //将入度为零的点放入队列  for (int i = 1; i \u0026lt;= n; i++) { if (!deg[i]) { vis[i] = 1; q.push(i); } } int num = 0; while (!q.empty()) { int now = q.front(); q.pop(); dest[num++] = now; for (auto to : g[now]) { if (vis[to]) //判断该节点是否在队列中  continue; else { deg[to]--; //入度减一  if (!deg[to]) { //判断入度是否为零  q.push(to); //入队  vis[to] = 1; //标记其在队列中  } } } } if (num == n) return true; else return false; } int main(int argc, char const *argv[]) { memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); memset(dest, 0, sizeof(dest)); for (int i = 1; i \u0026lt;= N; i++) g[i].clear(); while (!q.empty()) q.pop(); //以上为初始化  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); //读入  g[u].push_back(v); deg[v]++; //统计入度  } if (toposort()) {//如果可以生成拓扑排序  for (int i = 0; i \u0026lt; n; i++) //输出结果  printf(\u0026#34;%d%c\u0026#34;, dest[i], i == n ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } else printf(\u0026#34;NO\\n\u0026#34;); return 0; } //测试数据 //有向有环图 2 1 1 3 3 4 4 2 //有向无环图 1 2 1 3 3 4 2 4 4 5 DFS实现拓扑排序 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int n, u, v; int c[N]; // 标志数组 vector\u0026lt;int\u0026gt; G[N]; // vector 实现的邻接表 vector\u0026lt;int\u0026gt; topo; // 拓扑排序后的节点  bool dfs(int u) { c[u] = -1; for (int v : G[u]) { if (c[v] \u0026lt; 0) return false; else if (!c[v]) if (!dfs(v)) return false; } c[u] = 1; topo.push_back(u); return true; } bool toposort() { topo.clear(); memset(c, 0, sizeof(c)); for (int u = 0; u \u0026lt; n; u++) if (!c[u]) if (!dfs(u)) return false; reverse(topo.begin(), topo.end()); return true; } int main(int argc, char const *argv[]) { return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","summary":"\u003cp\u003e这篇文章将介绍图论中的拓扑排序。\u003c/p\u003e","title":"拓扑排序"},{"content":"C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\n存储 高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出\n头文件及全局变量 #include \u0026lt;bits/stdc++.h\u0026gt;static const int LEN = 1004; int a[LEN], b[LEN], c[LEN], d[LEN]; int flag; 清空 void clean(int temp[]) { for (int i = 0; i \u0026lt; LEN; ++i) temp[i] = 0; } 存储 void read(int temp[]) { static char s[LEN + 1]; scanf(\u0026#34;%s\u0026#34;, s); clean(temp); int len = strlen(s); for (int i = 0; i \u0026lt; len; ++i) { temp[len - 1 - i] = s[i] - \u0026#39;0\u0026#39;; } } 输出 void print(int a[]) { int i; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (; i \u0026gt;= 0; i--) putchar(a[i] + \u0026#39;0\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } 这样就完成了对于数据的存储与输出\n加法 高精度加法其实就是按照竖式加法法则来计算\n从低位开始相加，满十则向高一位进一，本位取余\n{% note info, 这里使用十进制，也可以使用其他更大的进制，如1000进制 %}\n//高精度加法 void add(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] = a[i] + b[i]; if (c[i] \u0026gt; 9) {//判断是否满十  c[i] -= 10; c[i + 1] += 1; } } } 减法 高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。\n因为要考虑到小数减大数的情况，所以用此函数来判断\nbool compare(int a[], int b[]) { int i, j; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (j = LEN - 1; j \u0026gt;= 1; --j) if (b[j] != 0) break; if (i \u0026gt; j) { return 0; } else if (i \u0026lt; j) { return 1; } else { for (int p = i; p \u0026gt;= 0; --p) { if (a[p] == b[p]) continue; if (a[p] \u0026gt; b[p]) return 0; else return 1; } } return 0; } //高精度减法 void sub(int* a, int* b, int* c) { flag = compare(a, b);//判断是否是小数减大数  if (flag) {//如果是  putchar(\u0026#39;-\u0026#39;);//则输出负号  sub(b, a, c);//按照大数减小数计算  flag = 0; return; } clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] += a[i] - b[i]; if (c[i] \u0026lt; 0) { c[i] += 10; c[i + 1] -= 1; } } } 乘法 高精度*低精度 如果是高精度与低精度相乘的话，就没必要使用高精度乘法\nvoid mul(int a[], int b, int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; ++i) { c[i] += a[i] * b;//每位都乘低精度  if (c[i] \u0026gt; 9) { c[i + 1] += c[i] / 10; c[i] %= 10; } } } 高精度*高精度 高精度与高精度相乘也是模拟了手写计算乘法的方式\n//高精度乘法 void mul(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和  for (int j = 0; j \u0026lt;= i; j++) { c[i] += a[j] * b[i - j]; } if (c[i] \u0026gt; 9) { c[i + 1] = c[i] / 10; c[i] %= 10; } } } 除法 //判断长度 inline bool greater_eq(int a[], int b[], int last_dg, int len) { if (a[last_dg + len] != 0) return true; for (int i = len - 1; i \u0026gt;= 0; --i) { if (a[last_dg + i] \u0026gt; b[i]) return true; if (a[last_dg + i] \u0026lt; b[i]) return false; } return true; } //高精度除法 void div(int a[], int b[], int c[], int d[]) { clean(c); clean(d); int la, lb; for (la = LEN - 1; la \u0026gt; 0; --la) if (a[la - 1] != 0) break; for (lb = LEN - 1; lb \u0026gt; 0; --lb) if (b[lb - 1] != 0) break; if (lb == 0) { puts(\u0026#34;除数为零，错误\u0026#34;); return; } for (int i = 0; i \u0026lt; la; ++i) d[i] = a[i]; for (int i = la - lb; i \u0026gt;= 0; --i) { while (greater_eq(d, b, i, lb)) { for (int j = 0; j \u0026lt; lb; ++j) { d[i + j] -= b[j]; if (d[i + j] \u0026lt; 0) { d[i + j + 1] -= 1; d[i + j] += 10; } } c[i] += 1; } } } 测试 int main() { flag = 0; read(a); read(b); add(a, b, c); print(c); sub(a, b, c); print(c); mul(a, b, c); print(c); div(a, b, c, d); print(c); print(d); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/","summary":"\u003cp\u003eC/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\u003c/p\u003e","title":"高精度计算"},{"content":"引入 例题hdu1097\n这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\n{% folding green, 点击展开 %}\nlong long fastPower(long long base, long long power){ long long ans = 1; for(int i = 0; i \u0026lt; power; i++){ ans *=base; } return ans % 10; } {%endfolding%}\n那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？\nint fastPower(long long base, long long power){ int ans = 1; base %= 10; for(int i = 0; i \u0026lt; power; i++){ ans *= base; if(ans \u0026gt; 9) ans %= 10; } return ans; } 结果同样，如果数据过大，还是会超时。\n快速幂 {% folding green, 取模的运算法则 %}\n$(a+b) mod M = (amodM + bmodM)modM$\n$(a-b)modM = (amodM - bmodM)modM$\n$(a*b)modM = (amodM * bmodM)modM$\n{% endfolding %}\n 入门 快速幂算法可以高效快速的算出$a^n$。\n下面举一个例子\n如果计算$2^{10}$\n$2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\n尽量将指数变小，如下\n$2^{10} = (2*2)^5 = 4^5$\n此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。\n那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样\n$2^{10} = 4^4*4^1$\n将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作：\n$2^{10} = 16^2*4^1$\n将指数再次缩小一半\n$2^{10} = 256^1*4^1$\n此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，得到的结果是变化过程中所有指数为奇数时的底数的乘积\n初步实现 用代码实现上面的算法：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) { power -= 1; result = result * base % 10; power /= 2; base = base * base % 10; } else { power /= 2; base = base * base % 10; } } return result % 10; } 优化 1.由于if、else中有重复语句\npower /= 2; base = base * base % 10; 2.且在整形运算中\npower -=1; power /=2; 可以压缩成下面一句\npower /=2;  于是代码就可以压缩成以下这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) result = result * base % 10; power /= 2; base = base * base % 10; } return result % 10; } 再次优化 在C/C++中可以利用更快位运算来代替一些计算，例如\npower % 2 == 1; power \u0026amp; 1 == 1;//位运算 power /=2; power \u0026gt;\u0026gt;= 1;//位运算 于是代码就变成了这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power \u0026amp; 1) result = result * base % 10; power \u0026gt;\u0026gt;= 1; base = base * base % 10; } return result % 10; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/","summary":"\u003ch2 id=\"引入\"\u003e引入\u003c/h2\u003e\n\u003cp\u003e例题\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1097\"\u003ehdu1097\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\u003c/p\u003e\n\u003cp\u003e{% folding green, 点击展开 %}\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efastPower\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e base, \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e power){\n    \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e power; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n        ans \u003cspan style=\"color:#f92672\"\u003e*=\u003c/span\u003ebase;\n    }\n    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e{%endfolding%}\u003c/p\u003e","title":"快速幂"},{"content":"STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\n容器 使用容器时要在头文件中引入\n序列式容器 序列的元素的位置是由进入容器的时间和地点决定的\nvector vector简单点说就是一个动态数组，vector实现动态增长，当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间。\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; void PrintVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //初始化 void test01() { vector\u0026lt;int\u0026gt; v1; //默认构造  int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v2(arr, arr + sizeof(arr) / sizeof(int)); vector\u0026lt;int\u0026gt; v3(v2.begin(), v2.end()); vector\u0026lt;int\u0026gt; v4(v3); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //常用赋值操作 void test02() { int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); //成员方法  vector\u0026lt;int\u0026gt; v2; v2.assign(v1.begin(), v1.end()); //重载=  vector\u0026lt;int\u0026gt; v3; v3 = v2; int arr1[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v4(arr1, arr1 + sizeof(arr1) / sizeof(int)); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); cout \u0026lt;\u0026lt; \u0026#34;---------------\u0026#34; \u0026lt;\u0026lt; endl; //交换  v4.swap(v1); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //大小操作 void test03() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; if (v1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } PrintVector(v1); v1.resize(2); PrintVector(v1); v1.resize(6, 1); //不写默认零  PrintVector(v1); for (int i = 0; i \u0026lt; 10000; i++) { v1.push_back(i); } cout \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; //长度、大小  cout \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; //容量 } //vector存取数据 void test04() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;front: \u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; //第一个元素  cout \u0026lt;\u0026lt; \u0026#34;back: \u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; //最后一个元素 } //插入和删除 void test05() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(20); //头插法  v.insert(v.begin(), 30); //尾插法  v.insert(v.end(), 40); PrintVector(v); v.insert(v.begin() + 2, 100); //插到第二个位置  //vector支持随机访问  //支持数组下标，一般都支持随机访问  //迭代器可以直接+-操作  PrintVector(v); //删除  v.erase(v.begin()); PrintVector(v); v.erase(v.begin() + 1, v.end()); PrintVector(v); v.clear(); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } //巧用swap缩减空间 void test06() { //vector添加元素 自动增长 那么，删除元素的时候，会自动减少吗  vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; //收缩空间  vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; PrintVector(v); } void test07() { //reserve预留空间 resize区别  int num = 0; int* address = NULL; vector\u0026lt;int\u0026gt; v; v.reserve(100000); //预先分配  for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (address != \u0026amp;v[0]) { num++; } } cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; //如果你知道容器大概需要的空间，预先分配空间，可以减少时间浪费吗，提高程序运行效率 } int main() { //test01();  //test02();  //test03();  //test04();  //test05();  //test06();  test07(); return 0; } deque deque表示双端队列，即可以从前端或者后端这两端进行数据的插入和删除\n 分段连续的内存空间 支持随机访问 指定位置插入，会引起数据移动  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;deque\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; void PrintDeque(deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } //初始化 void test01() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2(10, 5); deque\u0026lt;int\u0026gt; d3(d2.begin(), d2.end()); deque\u0026lt;int\u0026gt; d4(d3); //打印  PrintDeque(d4); cout \u0026lt;\u0026lt; endl; } //赋值、大小操作 void test02() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2; deque\u0026lt;int\u0026gt; d3; d1.assign(10, 5); d2.assign(d1.begin(), d1.end()); //迭代器指定区间赋值  d3 = d2; //等号赋值  d1.swap(d2); //交换两个空间的元素  if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } d1.resize(5); //有十个，后五个扔掉 } //插入和删除 void test03() { deque\u0026lt;int\u0026gt; d1; d1.push_back(100); d1.push_front(200); d1.push_back(300); d1.push_back(400); d1.push_front(500); //500 200 100 300 400  PrintDeque(d1); int val = d1.front(); //拿到第一个数据  d1.pop_front(); //删除第一个，无返回值  val = d1.back(); d1.pop_back(); //删除最后一个元素 } int main() { //test01();  //test02();  test03(); return 0; } list  双向链表 链表是由一系列节点组成的，节点包括两个域，一个数据域，一个指针域。 链表内存是非连续的，添加删除元素 时间复杂度是常数项 不需要移动元素 链表需要额外空间保留节点关系 不支持随机访问，故不能使用算法提供的sort()来进行排序，但可以调用其成员方法  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;using namespace std; //初始化 void test01() { list\u0026lt;int\u0026gt; l1; list\u0026lt;int\u0026gt; l2(10, 10); list\u0026lt;int\u0026gt; l3(l2); list\u0026lt;int\u0026gt; l4(l3.begin(), l3.end()); //打印  for (list\u0026lt;int\u0026gt;::iterator it = l4.begin(); it != l4.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test02() { list\u0026lt;int\u0026gt; l; l.push_back(100); l.push_front(200); l.insert(l.begin(), 300); l.insert(l.end(), 200); list\u0026lt;int\u0026gt;::iterator it = l.begin(); it++; l.insert(it, 500); //删除  //l.pop_back();  //l.pop_front();  //l.erase(l.begin(), l.end());  l.remove(200); //删除匹配的所有值  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test03() { list\u0026lt;int\u0026gt; l; l.assign(10, 10); list\u0026lt;int\u0026gt; l2; l2 = l; list\u0026lt;int\u0026gt; l3; l3.swap(l); } //反转 void test04() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(i); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.reverse(); //容器元素反转  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } bool Mycompare(int val1, int val2) { return val1 \u0026gt; val2; } //排序 void test05() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(rand() % 10); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.sort(); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小  l.sort(Mycompare); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //算法sort 只支持可随机访问的容器 链表没有  //list的sort是自己的成员函数不是算法 } int main() { //test01();  //test02();  //test04();  test05(); return 0; } queue  先进先出 不提供迭代器，不能遍历，不支持随机访问 push 入队（队尾） pop 出队（队头）  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;queue\u0026gt;using namespace std; void test01() { queue\u0026lt;int\u0026gt; q;//创建队列  q.push(10); q.push(20); q.push(30); q.push(40); cout \u0026lt;\u0026lt; \u0026#34;队尾元素: \u0026#34; \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; //输出顺序 10,20,30,40 \twhile (q.size() \u0026gt; 0){ cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//输出队头 \tq.pop();//删除队头 \t} } int main() { test01(); return 0; } stack  先进后出 push 压栈 pop 出栈 栈不提供迭代器，不能遍历，不支持随机访问，只能通过top从栈顶获取和删除元素  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;stack\u0026gt;using namespace std; void test01(){ //初始化 \tstack\u0026lt;int\u0026gt; s1; stack\u0026lt;int\u0026gt; s2(s1); //stack操作 \ts1.push(10); s1.push(20); s1.push(30); s1.push(100); cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; s1.pop();//删除栈顶元素  cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; //打印栈容器数据 \twhile (!s1.empty()) { cout \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; s1.pop(); } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size:\u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } 关联式容器 容器的规则是固定的，与元素进入容器的时间和地点无关\nset/multiset set表示集合，集合是存储排序键的关联式容器，且每个键值都是唯一的，可以插入或删除但是不能更改\n 以红黑树为底层机制，查找效率非常好 set中不允许重复元素，multiset中允许重复元素 不可通过迭代器改变set元素的值，会破坏set组织  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt;using namespace std; //仿函数 类 class Mycompare { public: bool operator()(int v1, int v2) const { //此处注意，要加const限定符  return v1 \u0026gt; v2; } }; //set容器初始化 void test01() { set\u0026lt;int, Mycompare\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); //自动进行排序，默认从小到大  for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小排序怎么办？ #if 0//赋值 set\u0026lt;int\u0026gt; s2; s2 = s1; //删除 s1.erase(s1.begin()); s1.erase(6); for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; s2.clear(); cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; #endif } //set查找 void test02() { //实值  set\u0026lt;int\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); set\u0026lt;int\u0026gt;::iterator ret = s1.find(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于等于的元素  ret = s1.lower_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于的元素  ret = s1.upper_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //equal_range 返回lower_bound和upper_bound的值  pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, set\u0026lt;int\u0026gt;::iterator\u0026gt; pret = s1.equal_range(4); if (pret.first == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.first \u0026lt;\u0026lt; endl; } if (pret.second == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.second \u0026lt;\u0026lt; endl; } } class Person { public: Person(int id, int age) : id(id), age(age){}; int id; int age; }; class PersonCompare { public: bool operator()(const Person\u0026amp; p1, const Person\u0026amp; p2) const { return p1.age \u0026gt; p2.age; } }; void test03() { set\u0026lt;Person, PersonCompare\u0026gt; sp; Person p1(10, 20), p2(30, 40), p3(50, 60); sp.insert(p1); sp.insert(p2); sp.insert(p3); for (set\u0026lt;Person, PersonCompare\u0026gt;::iterator it = sp.begin(); it != sp.end(); it++) { cout \u0026lt;\u0026lt; (*it).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).age \u0026lt;\u0026lt; endl; } //查找  Person p4(90, 20); set\u0026lt;Person, PersonCompare\u0026gt;::iterator ret = sp.find(p4); //可找到，对应p1，按照age排序就按照age查找  if (ret == sp.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (*ret).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*ret).age \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对组 将两个值合并成一个值\n#define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;using namespace std; void test01() { pair\u0026lt;int, int\u0026gt; pair1(10, 20); cout \u0026lt;\u0026lt; pair1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair1.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair2 = make_pair(10, \u0026#34;aaa\u0026#34;); cout \u0026lt;\u0026lt; pair2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair2.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair3 = pair2; cout \u0026lt;\u0026lt; pair3.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair3.second \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } map/multimap  map与set区别，map具有键值和实值 所有元素根据键值自动排序 pair的第一个元素成为键值，第二个元素成为实值 map也是以红黑树为底层实现机制 不可以通过map的迭代器修改map键值，键值关系到容器内元素的排列顺序，任意改变键值会破坏容器的排列规则，但是可以改变实值 multimap允许相同键值存在，map不允许  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; //map初始化 void test01() { //map容器模板参数：第一个参数key的类型，第二个参数value的类型  map\u0026lt;int, int\u0026gt; m; //插入数据 pair.first 对应key，pair.second 对应value  //第一种  pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, bool\u0026gt; ret = m.insert(pair\u0026lt;int, int\u0026gt;(10, 10)); //放入匿名对象  if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第二种  ret = m.insert(make_pair(10, 20)); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第三种  m.insert(map\u0026lt;int, int\u0026gt;::value_type(30, 30)); //第四种  m[40] = 40; m[10] = 20; //如果key不存在，创建pair并插入  //如果key存在，修改value实值  //打印  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;m[60] = \u0026#34; \u0026lt;\u0026lt; m[60] \u0026lt;\u0026lt; endl; //访问一个不存再的key，那么map会将这个key插入到map中，对应的value默认为零  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } } class MyKey { public: MyKey(int index, int id) : index(index), id(id) {} int index; int id; }; struct mycompare { bool operator()(MyKey key1, MyKey key2) const { return key1.index \u0026gt; key2.index; } }; void test02() { map\u0026lt;MyKey, int, mycompare\u0026gt; m; //需要排序，自定义类型，给定一个排序方法  m.insert(make_pair(MyKey(1, 2), 2)); m.insert(make_pair(MyKey(3, 4), 2)); for (map\u0026lt;MyKey, int, mycompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; it-\u0026gt;first.index \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first.id \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } //equal_range void test03() { map\u0026lt;int, int\u0026gt; m; m.insert(make_pair(1, 4)); m.insert(make_pair(2, 5)); m.insert(make_pair(3, 6)); pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, map\u0026lt;int, int\u0026gt;::iterator\u0026gt; ret = m.equal_range(2); if (ret.first-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到lower_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } if (ret.second-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到upper_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对比    容器 vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言：是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快   元素安插移除 尾端 头尾两端 任何位置 - - - -    迭代器 可以理解为指针，对指针的操作基本可以对迭代器操作，但实际上，迭代器是一个类，这个类封装了一个指针\n算法 通过有限的步骤解决问题的方法\n","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/stl/","summary":"\u003cp\u003eSTL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\u003c/p\u003e","title":"STL"},{"content":"“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\n并查集可以总结为三句话：\n “并”的意思是把两个有某些关系的结点并到一起 “查”的意思是查找一个结点的根节点 “并”的时候需要用到“查”  初始化 int father[len];//此数组定义在全局  void Init(int n){ for (int i = 0; i \u0026lt; len; ++i) {//len为结点总数 \tfather[i] = i; } } 查 初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点）\n假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.\n如图即是对应关系\n//查（非递归算法） int FindRoot(int x){ r = x; while(r != father[r]){//自己是自己的爹即是找到了根结点  r = father[r]; } return r; } //递归算法 int FindRoot(int x){ return x == father[x] ? x : FindRoot(father[x]); } 并 如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作；\n相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作\n//并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(x != y){ parent[y] = x; } } 例题 hdu1213\n问题描述 今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。 此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。\n例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上 所以伊格纳修斯至少需要 2 张桌子。\n输入 输入以表示测试用例数的整数 T（1\u0026lt;=T\u0026lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1\u0026lt;=N，M\u0026lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。\n输出 对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。\n示例输入 2 5 3 1 2 2 3 4 5 5 1 2 5 示例输出 2 4 这道题用一句话概括就是在一张桌子上，每个人都要有认识的人\n代码 #include\u0026lt;stdio.h\u0026gt; int father[1001]; int find(int x) { return father[x] == x ? x : find(father[x]); } void merge (int x, int y) { x = find(x); y = find(y); if (x != y) { a[x] = y; } } int main(int argc, char const *argv[]) { int t, m, n, x, y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } for (int i = 0; i \u0026lt; m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); merge(x, y); } for (int i = 1; i \u0026lt;= n; ++i) { if (father[i] == i) { cnt++; } } printf(\u0026#34;%d\\n\u0026#34;, cnt); } return 0; } 优化 合并的优化 如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免\n不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度\n初始化代码如下\nint father[len]; int height[len]; for(int i = 0; i \u0026lt; len; i++){ father[i] = i; height[i] = 1;//初始深度为1 } //并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(height[x] == height[y]){//此处无需判断x，y根结点是否一致 \theight[x] = height[x] + 1; father[y] = x; } else if(height[x] \u0026gt; height [y]){ father[y] = x; } else { father[x] = y; } } 查询的优化 //对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。 //这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果 int find (int x){ if(x != parent[x]){ father[x] = find(father[x]); } return father[x]; } 此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并\n但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下：\nint Find(int x){ int r = x; while(father[r] != r){//找到根结点 \tr = father[r]; } int i = x; int j; while(i != r){//循环修改这条路径上的根结点 \tj = father[i];//j记录元素i此时的父亲 \tfather[i] = r;//将i的父亲改为根结点 \ti = j;//i记录为要“查询”的结点  } return r; } 经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$\n总结  并查集的思想很精妙，用一个数组表示了整片森林 优化的关键在于记录每棵树的结点数量，根据结点关系合并 ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6%e6%9f%a5%e9%9b%86.jpg\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\u003c/p\u003e","title":"并查集"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]