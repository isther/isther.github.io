[{"content":"这里将记录Golang学习的笔记。\nGo基础 Go语言基础之变量与常量\nGo语言基础之基本数据类型\nGo语言基础之运算符\nGo语言基础之流程控制\nGo语言基础之数组\nGo语言基础之切片\nGo语言基础之map\nGo语言基础之函数\nGo语言基础之指针\nGo语言基础之结构体（一）\nGo语言基础之结构体（二）\nGo语言基础之接口\nGo语言基础之并发\n","permalink":"https://www.niuwx.cn/posts/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e这里将记录Golang学习的笔记。\u003c/p\u003e","title":"Golang学习笔记"},{"content":"结构-\u0026gt;执行-\u0026gt;管理-\u0026gt;用户\n外键约束 概念：foreign key，表中指向外部主键的字段\n 外键必须要通过语法指定才能称之为外键  [constraint 外键名] foreign key (当前表字段名) references 外部表(主键字段)   外键构成条件  外键字段必须与对应表的主键字段类型一致 外键字段本身要求是一个索引（创建外键会自动生成一个索引）    示例   创建专业表和学生表，学生表中的专业id指向专业表id\n# 专业表 CREATE table t1 ( id int primary key AUTO_INCREMENT, name varchar(50) not null unique ) charset utf8; # 学生表 create table t2( id int primary key AUTO_INCREMENT, name varchar(50) not null, c_id int comment \u0026#39;指向专业表t1的主键\u0026#39; constraint `c_id` FOREIGN KEY(c_id) REFERENCES t1(id) ) charset utf8; 外键可以不指定名字，系统会自动生成\n  外键约束  当表建立外键关系后，外键就会对主表和子表里的数据产生约束效果 外键约束的是写操作（默认操作）  新增：子表插入的数据对应的外键必须在主表存在 修改：主表的记录如果在子表存在，那么主表的主键不能修改（其他字段可修改） 删除：主表的记录如果在子表存在，那么主表的主键不能删除   外键约束控制：外键可以定义时控制外键的约束作用  控制类型  on update：父表更新时子表的表现 on delete：父表删除时子表的表现   控制方式  cascade：级联操作，父表操作后自编跟随操作 set null：置空操作，父表操作后，子表关联的外键字段置空 restrict/no action：严格模式，不允许父表操作（默认）      示例   子表不能插入主表不存在的数据\ninsert into t2 values(null,\u0026#39;Tony\u0026#39;,2);# 此时父表中还没有id=2的记录，错误  insert into t1 values(null,\u0026#39;English\u0026#39;); insert into t2 values(null,\u0026#39;Peny\u0026#39;,1);   默认的外键产生后，主键不能更新被关联的主键字段或者删除被关联的主键记录\n# 错误 update t1 set id = 2; delete from t1 where id = 1;   限制外键约束，一般使用更新级联，删除置空\n on update cascade：更新级联 on delete set null：删除置空  create table t3( id int primary key AUTO_INCREMENT, name varchar(50) not null unique )charset utf8; create table t4( id int primary key AUTO_INCREMENT, name varchar(50) not null, c_id int , # 如果允许置空，就不能not null  FOREIGN KEY(c_id) references t3(id) on update cascade on delete set null )charset utf8; insert into t3 values(null,\u0026#39;Chinese\u0026#39;),(null,\u0026#39;Computer\u0026#39;); insert into t4 values(null,\u0026#39;Tony\u0026#39;,1),(null,\u0026#39;Lily\u0026#39;,2);  子表依然不允许插入父表不存在的外键 但是可以插入外键为Null的数据  # 错误 insert into t2 values(null,\u0026#39;Lilei\u0026#39;,3); insert into t2 vlaues(null,\u0026#39;Lilei\u0026#39;,null);  父表的更新（主键）会让关联的外键自动级联更新  update t1 set id = 3 where id = 1;   外键管理   在表创建后期维护外键\n  新增外键\nalter table 表名 add [constraint `外键名`] foreign key(外键字段) references 表名(主键) [on 外键约束]   删除外键\nalter table 表名 drop foreign key 外键名;   更新外键：先删除后新增\n  事务安全 事务：要做的某个事情\n  计算机中的事务是指某个程序执行单元（写操作）\n  事务安全：当事务执行后，保障事务的执行是有效的，而不会导致数据错乱\n  事务安全通常针对的是一连串的操作（多个事务）而产生的统一结果\n  MySQL中默认的写操作是直接写入的\n 执行写操作SQL 同步到数据表    示例 银行转账\ncreate table t1( id int primary key auto_increment, `name` varchar(50) not null, account decimal(10,2) default 0.00 )charset utf8; insert into t1 values(null,\u0026#39;Tom\u0026#39;,10000),(null,\u0026#39;Lucy\u0026#39;,100); # Tom扣钱 update t1 set account = account - 100 where id = 1; # Lucy收钱 update t1 set account = account + 1000;  扣钱，收钱两步都成功转账才叫成功 为了保障两步都成功才能叫事务安全  事务处理  利用手动或者手动方式实现事务管理 自动事务处理：系统默认，操作结束直接同步到数据表（事务关闭状态）  系统控制：变量autocommit（值为ON，自动提交）   手动事务处理  开启事务：start transaction 关闭事务：  提交事务：commit，同步到数据表，同时清空日志数据 回滚事务：rollback 只清空日志数据     事务回滚：在长事务执行中，可以在某个已经成功的节点设置回滚点，后续回滚的可以回到某个成功点  设置回滚点：savepoint 回滚点名字 回滚到回滚点：rollback to 回滚点名字    示例   手动事务：启用事务转账，成功提交事务\n# 开启事务 start transaction; # Tom扣钱 update t1 set account = account - 1000; # Lucy收钱 update t1 set account = account + 1000; # 提交事务 commit;   手动事务：启用事务转账，成功提交事务（回滚点）\n# 开启事务 start transaction; # Tom扣钱 update t1 set account = account - 1000 where id = 1; # 设置回滚点 savepoint spl; # Lucy收钱 update t1 set account = account + 1000 where id = 2; # 操作失败回到回滚点 rollback spl; update t1 set account = account - 1000 where id = 2; # 提交事务 commit;   自动事务\n MySQL默认自动提交事务，事务一旦发生就会立即写入数据表  show variables like \u0026#39;autucommit\u0026#39;;  关闭自动提交事务（当前设置级别用户级：当前用户当此连接有效）  set autocommit = 0;  手动提交事务  insert into t1 values(null,\u0026#39;Liu\u0026#39;,1000); commit;   事务特点  ACID四大特性 原子性(Atomicity)：一个事务操作是一个整体，不可拆分，要么都成功，要么都失败 一致性(Consistency)：事务执行之前和执行之后都必须处于一致性状态，数据的完整性没有被破坏（事务逻辑的准确性） 隔离性(Isolation)：事务操作过程中，其他事务不可见 持久性(Durability)：事务一旦提交，结果不可改变  预处理 预处理：prepare statement，一种预先编译SQL指令的方式\n 预处理不同于直接处理，是将要执行的SQL指令先发送给服务器编译，然后通过指令执行  发送预处理：prepare 预处理名字 from '要执行的SQL指令' 执行预处理：execute 预处理名字   预处理管理  预处理属于会话级别：即当前用户当次连接有效（断开会被服务器清理掉） 删除预处理：deallocate | drop 预处理名字    示例 查询学生的SQL指令需要重复执行很多次\n# 普通操作 select * from t1; # 预处理操作：发送预处理 prepare pl from \u0026#39;select * from t1\u0026#39;; # 预处理操作：执行预处理 execute pl; # 删除预处理 deallocate | drop pl; 预处理传参   在执行预处理的时候传入预处理需要的可变数据\n  一般预处理都不会是固定死的SQL指令，而是具有一些数据可变的执行（条件）\n  可变数据的位置使用占位符?占位\nprepare 预处理名字 from \u0026#39;预处理指令 变化部分使用?代替\u0026#39;     在执行预处理的时候将实际数据传进去代替占位符执行SQL\n  数据存储到变量（预处理传入的值必须是变量保存的）\nset @变量名 = 值   使用using关键字传参\nexecute 预处理名字 using @变量名   数据传入的顺序与预处理中占位符的顺序一致\n    示例 向表中插入数据\n# 准备预处理：涉及参数 prepare t1 insert from \u0026#39;insert into t1 values(null,?,?,?,?)\u0026#39;; # 设置变量并传入参数 set @name = \u0026#39;药师兜\u0026#39;; set @gender = \u0026#39;男\u0026#39;; set @age = 23; set @class_name = \u0026#39;木叶1班\u0026#39;; #执行预处理 execute t1 insert using @name,@gender,@age,@@class_name; 视图 视图：view，一种由select指令组成的虚拟表\n  视图时虚拟表，可以使用表管理（结构管理）\n 为视图提供数据的表叫做基表    # 创建视图 create view 视图名字 as select指令; # 访问视图：一般都是查询 select */字段名 from 视图名字;   视图有结构，但不存储数据\n 结构：select选择的字段 数据：访问视图时执行的select指令    对外部系统提供数据支撑(保护基表数据)\n  示例   需要对外提供一个学生详情的数据，经常使用，可以利用视图实现\n# 对外提供数据，要保护数据本身的安全 # 需要长期使用  # 创建视图 create view v_student_info as select * from t1 left join t2 using(c_id); # 使用视图：像表一样使用 select * from v_student_info;   有些复杂的SQL又是经常用到的，如多张表的连表操作：可以利用视图实现\n# 院系表 create table t1( id int primary key auto_increment, `name` varchar(50) not null )charset utf8; insert into t1 values(null,\u0026#39;语言系\u0026#39;),(null,\u0026#39;考古系\u0026#39;); # 专业表 create table t2( id int primary key auto_increment, `name` varchar(50) not null, s_id int not null comment \u0026#39;学院id\u0026#39; )charset utf8; insert into t2 values(null,\u0026#39;English\u0026#39;,1),(null,\u0026#39;Chinese\u0026#39;,1); # 学生表 create table t3( id int primary key auto_increment, `name` varchar(50) not null, s_id int not null comment \u0026#39;专业id\u0026#39; )charset utf8; insert into t3 values(null,\u0026#39;Lilei\u0026#39;,2),(null,\u0026#39;Hanmeimei\u0026#39;,2),(null,\u0026#39;Tony\u0026#39;,1); # 获取所有学生的明细信息 select stu.*,sub.name as sub_name,sub.s_id as sch_id,sch.name as sch_name from t3 as stu left join t2 sub on stu.s_id = sub.id left join t1 sch on sub.s_id = sch.id; # 以视图保存这类复杂指令，后续可以直接访问视图 create view v_student_detail as select stu.*,sub.name as sub_name,sub.s_id as sch_id,sch.name as sch_name from t3 as stu left join t2 sub on stu.s_id = sub.id left join t1 sch on sub.s_id = sch.id;   视图管理   视图查看：显示视图结构和具体视图信息\nshow tables; #查看全部视图 show create table/view 视图名字; # 查看视图创建指令 desc 视图名字; # 查看视图结构   视图修改：更改视图逻辑\nalter view 视图名 as 新的查询命令; create or replace view 视图名 as 新的查询命令 # 创建新的或者替换新的   删除视图\ndrop view 视图名;   视图的数据操作   视图所有的数据操作都是最终对基表的数据操作\n  视图操作条件\n  多基表视图：不允许操作\n  单基表视图：允许增删改\n 新增条件：视图的字段必须包含基表中所有不允许为空的字段    with check option：操作检查规则\n 默认不需要这个规则（创建视图时指定）：视图操作只要满足前面上述条件即可 增加此规则：视图的数据操作后，必须要保证该视图还能把通过视图操作的数据查出来（否则失败）    示例     增加一个单表视图和多表视图\ncreate view v_student_1 as select s_id,s_name from t1; create view v_student_2 as select s.*,c.c_name from t1 s left join t2 c using(c_id); create or replace view v_student_3 as select * from t1 where c_id is not null with check option;   新增数据\ninsert into v_student_1 values(null,\u0026#39;student7\u0026#39;); # 正确：视图包含所有必有字段 insert into v_student_2 values(null,\u0026#39;student8\u0026#39;,null,null) # 错误：不可插入 insert into v_student_3 values(null,\u0026#39;student8\u0026#39;,null) # 错误：check option，因为第三个字段c_id为null,不符合视图筛选条件，查不出来 insert into v_student_3 valeus(null,\u0026#39;student9\u0026#39;,1) # 正确   更新数据\nupdate v_student_1 set s_name = \u0026#39;boy\u0026#39; where s_id = 8; update v_student_2 set s_name = \u0026#39;boy\u0026#39; where s_id = 7; # 错误：不可修改 update v_student_3 set c_id = null where s_id = 1; # 错误：check option，修改后c_id为null，变得不符合视图筛选条件 update v_student_3 set s_name = \u0026#39;boy\u0026#39; where s_id = 1;   删除数据\ndelete from v_student_1 where s_id = 2; delete from v_student_2 where s_id = 3; # 错误：不可修改 delete from v_student_3 where s_id = 1; # 可以删除，check option不影响删除操作   视图算法   视图在执行过程中对于内部的select指令的处理方式\n  视图算法在创建视图时指定\ncreate ALGORITHM = 算法 view 视图名字 as select指令;   视图算法一共有三种\n undefined：默认的，未定义算法，即系统自动选择算法 merge：合并算法，就是将视图外部查询语句跟视图内部select语句合并执行，效率高（系统优先选择） temptable：临时表算法，即系统将视图的select语句查出来先得出一张临时表，然后外部再查询（temptable算法视图不允许写操作）    数据备份与还原 表数据备份  单独针对表里的数据部分进行备份（数据导出） 将数据从表中查出，按照一定格式存储到外部文件  字段格式化：fields  terminated by：字段数据结束后使用的符号，默认是空格 enclosed by：字段数据包裹，默认什么都没有 escaped by：特殊字符的处理，默认是转义   行格式化：lines  terminated by：行结束符号，默认是\\n，自动换行 starting by：行开始符号，默认没有      select 字段列表|* into outfile \u0026#39;外部文件路径\u0026#39; [fields terminated by 格式 enclosed by 格式] [lines terminated by 格式 starting by 格式] from 数据表;  表数据备份不限定数据的来源是一张表还是多张表（可以连表）  表数据还原  将符合数据结构的数据导入到数据表中（数据导入） 将一定格式的数据按照一定的解析方式解析成符合表字段格式的数据导入到数据表  字段处理 行处理    load data infile \u0026#39;数据文件所在路径\u0026#39; into table 表名 [fields terminated by 格式 enclosed by 格式] [lines terminated by 格式 starting by 格式] [(字段列表)];  数据文件来源  表数据备份的数据文件 外部获取或者制作的符合格式的数据    文件备份  直接对数据表进行文件保留，属于物理备份 文件备份操作简单，直接将数据表（或者数据库文件夹）进行保存迁移 MySQL中不同表存储引擎产生的文件不一致，保存手段也不一致  InnoDB：表结构文件再ibd文件夹中，数据和索引存储在外部统一的ibdata文件夹中 MyIsam：每张表的数据、结构和索引都是独立文件，直接找到三个文件迁移即可    文件还原  利用备份的文件，替换出现问题的文件，还原到备份前的良好状态 直接将备份文件放到相应位置即可 文件还原影响  InnoDB：单表结构，整库数据，知识和整库备份还原，否则会影响其他InnoDB存储表 MyIsam：单表备份，单表还原，不影响其他任何数据    ​\n","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/","summary":"\u003cp\u003e结构-\u0026gt;执行-\u0026gt;管理-\u0026gt;用户\u003c/p\u003e\n\u003ch3 id=\"外键约束\"\u003e外键约束\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e概念\u003c/strong\u003e：\u003ccode\u003eforeign key\u003c/code\u003e，表中\u003cstrong\u003e指向外部主键\u003c/strong\u003e的字段\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e外键必须要通过语法指定才能称之为外键\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e[constraint 外键名] foreign key (当前表字段名) references 外部表(主键字段)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e外键构成条件\n\u003cul\u003e\n\u003cli\u003e外键字段必须与对应表的主键字段类型一致\u003c/li\u003e\n\u003cli\u003e外键字段本身要求是一个索引（创建外键会自动生成一个索引）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"MySQL安全管理"},{"content":"多表：因为单表会出现数据冗余，所以采用多表的方式\n联合查询 联合查询   union，是指将多个查询结果合并成一个结果显示\n  联合查询是针对查询结果的合并（多条select语句合并）\n  联合查询语法\nselect 查询 # 决定字段表 \tunion 查询选项 select 查询 ...   联合查询要求：联合查询是结果联合显示\n 多个联合查询的字段结果数量一致 联合查询的字段来源于第一个查询语句的字段    查询选项：与select选项一样\n all：保留所有记录 distinct：保留去重记录（默认）    示例   创建一个表，并插入数据\ncreate table t2 like t1; insert into t2 values(null, \u0026#39;犬夜叉\u0026#39;, \u0026#39;男\u0026#39;, 200, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;日暮戈薇\u0026#39;, \u0026#39;女\u0026#39;, 16, \u0026#39;现代1班\u0026#39;), (null, \u0026#39;桔梗\u0026#39;, \u0026#39;女\u0026#39;, 88, \u0026#39;法师1班\u0026#39;), (null, \u0026#39;弥勒\u0026#39;, \u0026#39;男\u0026#39;, 28, \u0026#39;法师2班\u0026#39;), (null, \u0026#39;珊瑚\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;法师2班\u0026#39;), (null, \u0026#39;七宝\u0026#39;, \u0026#39;保密\u0026#39;, 5, \u0026#39;宠物1班\u0026#39;), (null, \u0026#39;杀生丸\u0026#39;, \u0026#39;男\u0026#39;, 220, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;铃\u0026#39;, \u0026#39;女\u0026#39;, 4, \u0026#39;现代1班\u0026#39;), (null, \u0026#39;钢牙\u0026#39;, \u0026#39;男\u0026#39;, 68, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;奈落\u0026#39;, \u0026#39;男\u0026#39;, 255, \u0026#39;神妖1班\u0026#39;), (null, \u0026#39;神乐\u0026#39;, \u0026#39;女\u0026#39;, 15, \u0026#39;神妖2班\u0026#39;);  t1与t2结构一致，可以理解为因为数据量较大，拆分到两个表中\r   使用联合查询两张表的数据拼接到一起显示\nselect * from t1 union select * form t2;   联合查询选项默认是distinct\nselect * from t1 union select * from t2; select * from t1 union all select * from t2;   联合查询不要求字段类型一致，只对数量要求一致，而且字段名称与第一条查询语句相关\nselect name from t1 union select age from t2; 如果数据不能与字段对应，那么查询没有意义\n  联合查询排序  针对联合查询的结果进行排序 order by本身是对内存结果进行排序，union的优先级高于order by，所以order by默认是对union结果进行排序 如果想对单独select的结果进行排序，需要两个步骤  将需要排序的select指令进行括号包裹（括号使用order by） order by必须配合limit才能生效（limit一个足够大的数值即可）    示例   将t1和t2表的结果使用年龄降序排序\nselect * from t1 union all select * from t2 order by age desc;   t1表按年龄降序排序，t2表按年龄升序排序\n# 无效方式 (select * from t1 order by age desc) union (select * from t1 order by age asc); # 有效方式 (select * from t1 order by age desc limit 9999) union (select * from t2 order by age asc limit 9999);   连接查询 交叉连接  cross join，不需要任何条件的连接 交叉连接产生的效果就是笛卡尔积  左表的每一条记录都会与右表的所有记录连接并保存   交叉连接没有实际数据价值，只是丰富了连接查询的完整性  示例 # 交叉连接t1和t2表 select * from t1 cross join t2; 内连接  [inner] join，将两张表根据指定的条件连接起来，严格连接 内连接是将一张表的每一个记录去另外一张表根据条件匹配  匹配成功：保留连接的数据 匹配失败：都不保留   内连接语法：左表 join 右表 on 连接条件  示例   设计学生表和专业表：学生对专业多对一关系\n# 学生表 create table t1( id int primary key auto_increment, name varchar(50) not null, course_no int )charset utf8; insert into t1 values(null,\u0026#39;student1\u0026#39;,1), (null,\u0026#39;student2\u0026#39;,1), (null,\u0026#39;student3\u0026#39;,2), (null,\u0026#39;student4\u0026#39;,3), (null,\u0026#39;student5\u0026#39;,1), (null,\u0026#39;student6\u0026#39;,default); # 专业表 create table t2( id int primary key auto_increment, name varchar(50) not null unique )charset utf8; insert into t2 values(null,\u0026#39;Computer\u0026#39;),(null,\u0026#39;Software\u0026#39;),(null,\u0026#39;Network\u0026#39;);   获取已经选择了专业的学生信息，包括所选专业\n# 学生和专业在两个表中，所以需要连表 # 学生必须有专业，而专业也必须存在，所以是内连接 # 连接条件：专业编号 # 两张表有两个字段冲突：id,name,所以需要使用别名 select t1.*,t2.name as course_name from t1 inner join t2 on t1.course_no = t2.id; # 表名的使用也可以使用别名 select s.*,c.name as c_name from t1 as s inner join t2 c on s.course_no = c.id;   外连接  outer join，是一种不严格的连接方式 外连接分为两种  左连接：left join 右连接：right join   外连接有主表和从表之分  左连接：左表为主表 右连接：右表为主表   外连接是将主表的记录去匹配从表的记录  匹配成功保留 全表匹配失败：也保留，只是从表字段置空    示例   查出学生所有信息，包括所在班级（左连接）\n# 主要数据是学生，而且是全部学生：外连接、且学生表为主表 select s.*,c.name c_name from t1 s left join t2 c on s.course_no = c.id;   查出所有班级里的所有学生\n#主表是班级 select s.*,c.name c_name from t1 s right join t2 c on s.course_no = c.id;   自然连接  natural join，是一种自动寻找连接条件的连接查询 自然连接不是一种特殊的连接方式，而是自动匹配条件的连接 自然连接包含  自然内连接：natural join 自然外连接：natural left/right join   自然连接条件匹配模式：自动寻找相同字段名作为连接条件  示例   自然连接t1和t2表\nselect * from t1 natural join t2;   自然连接是不管字段是否有关系，只管名字是否相同，如果想要自然连接成功，那么字段的设计就必须非常规范\ncreate table t11( s_id int primary key auto_increment, s_name varchar(50) not null, c_id int comment \u0026#39;课程id\u0026#39; )charset utf8; insert into t11 select * from t1; create table t22( c_id int primary key auto_increment, c_name varchar(50) not null unique )charset utf8; insert into t22 select * from t2; # 自然连接 成功 select * from t11 natural join t22;   using 关键字  连接查询时，如果是同名字段作为连接条件，using可以代替on出现，且比on更好  using是针对同名字段（using(id) === A.id = B.id） using关键字使用后会自动合并对应字段为一个 using可以同时使用多个字段作为条件    示例 查询t11中所有学生信息，包括所在班级名字\nselect s.*,c.c_name from t11 s left join t22 c using(c_id); select * from t11 s left join t22 c using(c_id); 子查询 子查询分类  根据子查询出现的位置或者产生的数据效果分类  位置分类  from子查询：子查询出现在from后做数据源 where子查询：子查询出现在where后做数据条件   按子查询得到的结果分类  标量子查询：子查询返回的结果是一行一列（一个数据） 列子查询：子查询返回的结果是一列多行（一列数据） 行子查询：子查询返回的结果是一行多列（一行数据） 表子查询：子查询返回的结果是一个二维表 exists子查询：子查询返回的结果是布尔结果（验证型）     子查询都需要使用括号()包裹，必要时需要对子查询结果进行别名处理（from子查询）  标量子查询  通常是用来做其他查询的条件  示例 获取computer专业的所有学生\n# 数据目标：学生表t11 # 条件：专业名字，不在t11中  select * from t11 where c_id = (select c_id from t_22 where c_name = \u0026#39;Computer\u0026#39;); 列子查询  通常是用来做查询条件的  示例 获取所有有学生的班级信息\n# 数据获取目标是班级信息 # 数据获取条件是在学生表中的班级id，是多个  select * from t22 where c_id in (select c_id from t11); 行子查询  子查询返回的结果是一行多列 行子查询需要条件中构造元素  (元素1),(元素2),...(元素N)   行子查询通常也是用来作为主查询的条件  示例 获取学生表中性别和年龄都和弥勒相同的学生信息\n# 查询条件有多个：性别和年龄 # 数据的条件的来源在另一张表中  # 解决思路：两个标量子查询 select * from t1 where gender = (select gender from t2 where name = \u0026#39;弥勒\u0026#39;) and age = (select from t2 where name = \u0026#39;弥勒\u0026#39;);  以上查询方式使用了两次子查询，效率降低  # 构造条件行元素(gender,age) select * from t1 where (gender,age) = (select gender,age from t2 where name = \u0026#39;弥勒\u0026#39;); 表子查询  表子查询多出现在from之后，当作数据源 表子查询通常是为了想对数据进行一次加工处理，然后再交给外部进行二次加工处理  示例 获取学生表中每个班级里年龄最大的学生信息，然后按年龄降序排序显示\n# 尝试直接解决 select any_value(name),max(age) m_age, clas_name from t1 group by class_name order by m_age desc;  分组统计中any_value()取的是分组后的第一条数据，而需要的是最大  # 解决方案：要入在分组之前将所有班级里的学生本身是降序排序，那么分组的第一条数据就是满足条件的数据，但是问题是order by必须出现在group by之后 select any_value(name),max(age),class_name from (select name,age,class_name from t1 order by age desc) as t group by class_name;  依然无效，原因是MySQL7之后若要子查询中``order by生效，需要像联合查询一样，加上limit`  select any_value(name),max(age),class_name from (select name,age,class_name from t1 order by age desc limit 99999) as t group by class_name; exists子查询  exists子查询通常是作为where条件使用  where exists(子查询)    示例 获取所有学生的班级信息\n# 获取的数据是班级表t22 # 班级是否有学生需要在t11中确认，并不需要t11提供任何数据显示 select * from t22 c where exists(select c_id from t11 where c.c_id = c_id); 比较方式  特定的比较方式都是基于比较符号一起使用的 all：满足后面全部条件  \u0026gt;all(结果集)：数据要大于结果集中的全部数据   any：满足任何条件  =any(结果集)：数据只要与结果集中的任何一个元素相等   some：满足任意条件(与any完全一样) 结果集：可以是直接的数据也可以是子查询的结果（通常是列子查询）  示例 找出t1表中与t2表中年龄相同的信息\n# 数据获取在t1表 # 数据条件在t2表  # 解决方案1：使用in列子查询 select * from t1 where age in (select distinct age from t2); # 解决方案2：使用exists子查询 select * from t1 where exists(select id from t2 where t1.age = age); # 解决方案3：使用any或者some匹配（列子查询） select * from t1 where age = some(select age from t2); ","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","summary":"\u003cp\u003e\u003cstrong\u003e多表\u003c/strong\u003e：因为单表会出现数据冗余，所以采用多表的方式\u003c/p\u003e","title":"MySQL多表操作"},{"content":"常见的SQL高级操作，主要集中在数据操作（增删改查），基于基础操作之上实现一些复杂业务的数据操作\n数据新增 主要是在新增数据时的高级操作技巧，提升数据插入的效率问题、安全问题。\n批量插入   批量插入分两种\n  全字段批量插入\ninsert into 表名 values(值列表1),(值列表2)...(值列表n);   部分字段批量插入\ninsert into 表名 (字段列表) values(值列表1),(值列表2)...(值列表n);     示例   批量插入学生成绩(全字段)\ninsert into t1 values(null,\u0026#39;Tom\u0026#39;,\u0026#39;Computer\u0026#39;,\u0026#39;90\u0026#39;),(null,\u0026#39;Lily\u0026#39;,\u0026#39;Computer\u0026#39;,\u0026#39;100\u0026#39;);   批量插入学生考试信息(不含成绩)\ninsert into t1 (stu_name,course) values(\u0026#39;Tony\u0026#39;,\u0026#39;English\u0026#39;),(\u0026#39;Ray\u0026#39;,\u0026#39;Math\u0026#39;);   蠕虫复制   从已有的表中复制数据直接插入到另外一张表\n  目的是快速增加表中的数据\n 实现表中数据复制（用于数据备份和迁移） 实现数据的指数级递增（多用于测试）    蠕虫复制语法\ninsert into 表名 [(字段列表)] select 字段列表 from 表名;   注意事项\n 字段列表必须对应 字段类型必须匹配 数据冲突需要事先考虑    示例   创建一张新表，将t1表中的数据迁移到新表中\ncreate table t2( id int primary key auto_increment, stu_name varchar(20) not null, course varchar(20) not null, score decimal(5,2) )charset utf8; insert into t2 select * from t1;   快速让t1表中的数据达到超过100条（重复执行）\ninsert into t2 (stu_name,course,score) select stu_name,course,score from t1; #   主键冲突   在数据进行插入时包含主键指定，而主键在数据表已经存在\n  主键冲突的业务通常是发生在业务主键上（业务主键本身有业务意义）\n  主键冲突的解决方案\n  忽略冲突：保留原始记录\ninsert ignore into 表名 [(字段列表)] values(值列表); # 产生主键冲突后，保留原始记录，插入数据无效   冲突更新：冲突后部分字段变成更新后的值\ninsert into 表名 [(字段列表)] values(值列表) on duplicate key update 字段 = 新值[,字段=新值...]; # 1.尝试新增 # 2.失败，更新   冲突替换：先删除原有记录，后新增记录\nreplace into 表名 [(字段列表)] values(值列表); #效率没有insert高（需要检查是否冲突）     示例   用户名作为主键的用户注册（冲突不能覆盖）：username，password，regtime\ncreate table t1( `username` varchar(50) primary key, `password` char(32) not null, regtime int unsigned not null )charset utf8; insert into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,1234546789); #冲突忽略，且数据不插入 insert ignore into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,123456789);   用户名作为主键的记录用户使用信息（不存在新增，存在则更新时间）：username，logintime\ncreate table t1( `username` varchar(50) primary key, logintime int unsigned )charset utf8; insert into t1 values(\u0026#39;username\u0026#39;,12345678); #冲突更新（替换部分字段数据） insert into t1 values(\u0026#39;username\u0026#39;,12345678) on duplicate key update logintime = unix_timestamp();  如果主键不冲突：新增 如果主键冲突：更新指定字段 上述方式适用于字段较多，但是可能冲突时数据变化的字段较少    用户名作为主键，记录用户登录信息（不存在新增、存在则更新全部）：username、login time、clientinfo\ncreate table t1( `username` varchar(50) primary key, logintime int unsigned, clientinfo varchar(255) not null )charset utf8; replace into t1 values(\u0026#39;username\u0026#39;,unix_timestamp(),\u0026#39;{PC:chrome}\u0026#39;); replace into t1 values(\u0026#39;username\u0026#39;,unix_timestamp(),\u0026#39;{phone:uc}\u0026#39;);  replace遇到主键重复就会先删除、后新增    数据查询 查询选项  用于对查询结果进行简单数据筛选 查询选项时在select关键字之后，有两个互斥值  all：默认，表示保留所有记录 distinct：去重，重复的记录（所有字段都重复）    示例 查看商品表中所有品类的商品信息，重复商品只保留一次（名字、价格、属性都一致）\ncreate table t1( id int primary key auto_increment, goods_name varchar(50) not null, goods_price decimal(10,2) default 0.00, goods_color varchar(20), goods_weight int unsigned comment \u0026#39;重量，单位克\u0026#39; )charset utf8; insert into t1 values(null,\u0026#39;mate10\u0026#39;,5499.00,\u0026#39;blue\u0026#39;,320), (null,\u0026#39;mate10\u0026#39;,5499.00,\u0026#39;gray\u0026#39;,320), (null,\u0026#39;nokia3301\u0026#39;,1299,\u0026#39;black\u0026#39;,420); # 考虑所有字段的去重（不含逻辑主键） select distinct goods_name,goods_price,goods_color,goods_weight from t1; # 不考虑颜色去重 select distinct goods_name,goods_price,goods_weight from t1; 字段选择\u0026amp;别名  字段选择：根据实际需求选择的要获取数据的字段信息 根据实际需求，明确所需要的字段名字，使用英文逗号，分隔 获取所有字段，使用星号*通配所有字段 字段数据可以不一定是来自数据源（select只要有结果即可）  数据常量：select 1 函数或变量：select unix_timestamp(),@@version(@@是系统变量的前缀，后跟变量名)   字段别名：给字段取的临时名字 字段别名使用as语法实现  字段名 as 别名 字段名 别名   字段别名的目的通常为了保护数据  字段冲突：多张表同时操作有同名字段（系统默认覆盖），想保留全部 数据安全：对外提供数据不使用真实字段名字    示例   查询商品信息\n# 全部查询 select * from t1; # 需求为商品名字和商品 select goods_name,goods_price from t1; # 别名使用 select goods_name as gn,goods_price as gp from t1;   不需要数据源的数据获取：select的表达式本身能算出结果\n# 获取当前时间戳和版本号 select unix_timestamp() as now,@@version as version,@@version;   数据源  数据来源 from之后 单表数据源：数据源就是一张表 from 表名 多表数据源：数据来源是多张表（逗号分隔） from 表名1,表名2,... 子查询数据源：数据来源是一个查询结果from (select 字段列表 from 表名) as 别名  数据源要求必须是一个表 如果是查询结果必须给其一个表别名   数据表也可以指定别名  表名 as 别名 表名 别名    示例   单表数据源：最简单的数据源，直接从一个数据表获取\nselect * from t1;   多表数据源：\nselect * from t1,t2; # 利用一张表的一条数据匹配另外一张表的所有记录 # 记录数=表1记录数*表2记录数 # 字段数=表1字段数+表2字段数   子查询数据源：数据来源是一个select对应的查询结果\n 查询语句需要使用括号 查询结果需要指定别名  select * from (select * from t1,t2) t;   如果有时候名字较长或使用不方便，可以利用表别名\nselect * from table1 as t1; select t1.*,t2.stu_name from table1 as t1 table2 as t2;   where子句  跟在from数据源之后，对数据进行条件匹配 where是在磁盘读取后，进入内存之前进行筛选  不符合条件的数据不会进入内存   where筛选的内容因为还没进入内存，所以数据是没有被加工过的  字段别名不能在where中使用    示例   查询t1表中学生名字为Lily的成绩信息\nselect * from t1 where stu_name = \u0026#39;Lily\u0026#39;;   因为where是在磁盘取数据时进行条件筛选，此时数据没有进入内存，所以字段别名是无效的\n# 错误 select stu_name sn,score from t1 where name = \u0026#39;Lily\u0026#39;;   运算符  比较运算符  \u0026gt;、\u0026lt;、=（即是赋值又是等于）、\u0026gt;=、\u0026lt;=、\u0026lt;\u0026gt;(不等于) between A and B ：A和B之间，包括A和B本身，数值比较 in (数据1,数据2,...数据N)：在列举的数据之中 like 'pattern'：上面这样的，用于字符串比较  _：单下划线，匹配对应位置的一个任意字符 %：匹配当前位置往后任意数量任意字符     逻辑运算符  and(逻辑与)、or(逻辑或)、not(逻辑非)   null运算符  is null(为空)、is not null(不为空)    示例   查询成绩不及格的所有学生信息\nselect * from t1 where score \u0026lt; 60;   查询成绩在60-90之间的学生信息\nselect * from t1 where between 60 ans 90; select * from t1 where score \u0026gt;= 60 and score \u0026lt;=90;   查询没有成绩的学生\nselect * from t1 where score is null;   group by 子句  分组统计，根据某个字段所有的结果分类，并进行数据统计分析 分组的目的不是为了显示数据，一定是为了统计数据 group by子句一定是出现在where字句之后（如果同时存在） 分组统计可以进行统计细分：先分大组，然后大组分小组 分组统计需要使用统计函数  group_concat()：将组里的某个字段全部保留 any_value()：不属于分组字段的任意一个组里的值 count()：求对应分组的记录数量  count(字段名)：统计某个字段值的数量（NULL不统计） count(*)：统计整个记录的数量（较多）   sum()：求对应分组中某个字段的和 max()/min()：求对应分组中某个字段的最大/最小值 avg()：求对应分组中某个字段的平均值    示例   创建一张表，存储学生信息\ncreate table t1( id int primary key auto_increment, `name` varchar(10) not null, `gender` enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;,\u0026#39;保密\u0026#39;), age tinyint unsigned not null, class_name varchar(10) not null comment \u0026#39;班级名称\u0026#39; )charset utf8; insert into t1 values(null,\u0026#39;鸣人\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;佐助\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;小樱\u0026#39;,\u0026#39;女\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;佐井\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;大蛇丸\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;木叶0班\u0026#39;), (null,\u0026#39;卡卡西\u0026#39;,\u0026#39;男\u0026#39;,29,\u0026#39;木叶2班\u0026#39;), (null,\u0026#39;雏田\u0026#39;,\u0026#39;女\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;我爱罗\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;木叶1班\u0026#39;), (null,\u0026#39;向日葵\u0026#39;,\u0026#39;女\u0026#39;,8,\u0026#39;木叶10班\u0026#39;), (null,\u0026#39;博人\u0026#39;,\u0026#39;男\u0026#39;,8,\u0026#39;木叶10班\u0026#39;), (null,\u0026#39;鼬\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;木叶0班\u0026#39;), (null,\u0026#39;带土\u0026#39;,\u0026#39;男\u0026#39;,28,\u0026#39;木叶2班\u0026#39;), (null,\u0026#39;琳\u0026#39;,\u0026#39;女\u0026#39;,27,\u0026#39;木叶2班\u0026#39;)；   统计每个班的人数\nSELECT COUNT(*),class_name from t1 group by class_name;   多分组：统计每个班的男女学生数量\nSELECT COUNT(*),class_name,gender from t1 group by class_name,gender;   统计每个班里的人数，并记录班级学生的名字\nSELECT COUNT(*),group_concat(`name`) from t1 group by class_name;   回溯统计  在进行分组时（通常是多分组），每一次结果的回溯都进行一次汇总统计 回溯统计语法：在统计之后使用with rollup  示例 统计每个班的男女同学数量，同时要知道班级人数总数\n# 只统计每个班的男女同学数量，没有班级汇总 SELECT COUNT(*),class_name,gender,group_concat(`name`) from t1 group by class_name,gender; # 汇总统计：回溯 SELECT count(*),class_name,gender,group_concat(`name`) from t1 group by class_name,gender with rollup; 分组排序  在分组后统计结果，根据分组字段进行升序或者降序显示数据 默认系统自动升序排序 可以设定分组结果的排序方式  group by 字段名 [ASC]：升序 group by 字段名 DESC：降序    示例 SELECT COUNT(*),class_name,gender,group_concat(`name`),any_value(`name`) from t1 group by class_name,gender desc; having子句  类似于where子句，是用来进行条件筛选数据的 having子句本身是针对分组统计结果进行条件筛选的 having子句必须出现在group by子句之后（如果同时存在） having针对的数据是在内存里已经加载的数据 having几乎能做where能做的所有事，但是where却不一定  字段别名（where针对磁盘数据，在处理时还没有别名） 统计结果（where在group by之前） 分组统计函数（having通常是针对group by存在的）    示例   获取班级人数小于3的班级\nSELECT COUNT(*) as `count`,class_name,group_concat(`name`) from t1 group by class_name having count \u0026lt; 3; SELECT COUNT(*) as `count` ,class_name,group_concat(`name`) from t1 group by class_name having COUNT(*) \u0026lt; 3; # 多用了一次函数（效率降低）  SELECT class_name,group_concat(`name`) from t1 group by class_name having COUNT(*) \u0026lt; 3;   order by子句  排序，根据某个指定的字段进行升序或者降序 排序的参照物是校对集 order by子句在having子句字后（如果同时存在） 排序分为升序和降序：默认升序  order by 字段 [ASC]：升序 order by 字段 DESC：降序   多字段排序：在根据某个字段排序好之后，可以再细分  示例   单字段：按照年龄升序\nselect * from t1 order by age; select * from t1 order by age asc;   多字段：先性别降序，后年龄升序\nselect * from t1 order by gender desc, age; select * from t1 order by gender desc, age asc;   limit子句  限制数据的获取数量 limit子句必须在order by子句之后（如果同时存在） limit限制数量方式有两种  limit 数量 limit 起始位置,数量    示例   获取表中前3条\nselect * from t1 limit 3;   获取表中第三条开始之后的3条数据\nselect * from t1 limit 3,3;   数据更新 限制更新  更新时对更新的记录数进行限制 限制更新通过limit实现 其实是局部更新的一种手段，一般更多情况下依据条件精确更新  示例 对会员选3个发送10元红包\nCREATE table t1( id int primary key auto_increment, `username` varchar(50) not null unique, `password` char(12) not null, account decimal(10,2) default 0.00 )charset utf8; INSERT INTO t1 VALUES(null,\u0026#39;username1\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username2\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username3\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username4\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username5\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username6\u0026#39;,\u0026#39;password\u0026#39;,default), (null,\u0026#39;username7\u0026#39;,\u0026#39;password\u0026#39;,default); UPDATE t1 set account = account + 10 LIMIT 3; SELECT * from t1; 数据删除 限制删除  限制要删除的记录数 使用limit限制 一般很少使用，通常使用where条件精确删除  示例 删除没有账户余额的一个用户\ndelete from t1 where account = 0 limit 1; 清空数据  将表中的数据清楚，表的所有状态回到原始状态 本质是先删除，后创建 清空后可以使表的一些变化状态回到原始状态，例如自增长回归初值 清空语法：truncate 表名  示例 清空用户数据表\ntruncate t1; ","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E9%AB%98%E7%BA%A7sql%E6%93%8D%E4%BD%9C/","summary":"\u003cp\u003e常见的SQL高级操作，主要集中在数据操作（增删改查），基于基础操作之上实现一些复杂业务的数据操作\u003c/p\u003e","title":"MySQL高级SQL操作"},{"content":"关系型数据库设计范式  Normal Format，符合某一种级别的关系模式的集合，表示一个关系内部各个属性之间的联系的合理化程度 范式是离散数学的概念 范式目标是在满足组织和存储的前提下使数据结构冗余最小化 范式级别越高，表的级别就越标准 目前数据库应用的范式有以下几层  第一范式：1NF 第二范式：2NF 第三范式：3NF 逆规范化    示例  员工表    工号 姓名 部门 入职时间     0001 张三 人事部 2021-07-26   0002 李四 运营部 2021-07-26      每个员工都与部门挂钩，但是部门不可能有很多，所以上述表中会有很多数据重复，此时应该将部门单独维护出来，减少数据冗余。\n   部门编号 部门名称     1 人事部   2 运营部       工号 姓名 部门 入职时间     0001 张三 1 2021-07-26   0002 李四 2 2021-07-26     范式一共有6层，但是数据库的设计通常只要求满足3层即可。\n 第一范式1NF  1NF，数据字段设计时必须满足原子性 1NF要求字段数据是不需要拆分就可以直接使用 如果数据使用的时候需要进行拆分那么就违背1NF   步骤\n 设计的字段是否在使用的时候还需要再拆分 将数据拆分到最小单位，设计字段 满足1NF   示例    姓名 性别 课程 教室 成绩 学习时间     张三 男 C++ 101 100 2月1日-2月15日   李四 女 C 102 100 2月1日-2月15日   王五 男 JAVA 103 100 2月1日-2月15日    当前表的学习时间在使用的时候肯定是基于开始时间和结束时间的，而这种设计会存在使用时的数据拆分，不满足原子性，同时也不满足1NF。\n   姓名 性别 课程 教室 成绩 开始时间 结束时间     张三 男 C++ 101 100 2月1日 2月15日   李四 女 C 102 100 2月1日 2月15日   王五 男 JAVA 103 100 2月1日 2月15日    第二范式2NF  2NF，字段设计不能存在部分依赖 部份依赖：首先表存在复合主键，其次有的字段不是依赖整个主键，而只是依赖主键中的一部分 部份依赖解决：让所有非主属性都依赖一个候选关键字  最简单方式：取消复合主键（一般选用逻辑主键替代，但是本质依然是复合主键做主），所有非主属性都依赖主属性（逻辑主键） 正确方式：将部分依赖关系独立成表    示例 学生成绩中学生和课程应该是决定性关系，因此属于主属性（主键）\n   姓名(P) 性别 课程(P) 教室 成绩 开始时间 结束时间     张三 男 C++ 101 100 2月1日 2月15日   李四 女 C 102 100 2月1日 2月15日   王五 男 JAVA 103 100 2月1日 2月15日     成绩是由学生和课程决定的，是完全依赖主属性 性别只依赖学生（部份依赖） 教室、开始时间和结束时间依赖课程（部份依赖）  解决方案：将学生信息维护到一张表，课程信息维护到一张表，成绩表取两个表的主属性即可\n学生表\n   Stu_id(P) 姓名 性别     1 张三 男   2 李四 女   3 王五 男     Stu_id是姓名的代指属性（逻辑主键，本质主键是姓名） 性别只依赖主属性  课程表\n   Class_id(P) 课程 教室 开始时间 结束时间     1 C++ 101 2月1日 2月15日   2 C 102 2月1日 2月15日   3 JAVA 103 2月1日 2月15日     Class_id是课程的代指属性（逻辑主键） 教室、开始时间和结束时间都依赖课程  成绩表\n   Stu_id(P) Class_id(P) 成绩     1 1 100   2 2 100   3 3 100     Stu_id和Class_id共同组成主属性（复合主键） 成绩依赖Stu_id和Class_id本身，不存在部份依赖  第三范式3NF  3NF，字段设计不能存在传递依赖 传递依赖：字段某个非主属性不直接依赖主属性，而是通过依赖某个其他非主属性而传递到主属性之上 传递依赖解决：让依赖非主属性的字段与依赖字段独立成表  示例    学号(P) 姓名 专业编号 专业名称     1 张三 0001001 软件工程   2 李四 0001002 土木工程     姓名和专业编号都依赖于学号 专业名称依赖于专业编号 专业名称间接依赖学号：依赖传递 随着学生增加，专业名字会出现大量数据冗余  解决方案：将存储传递依赖部分的字段独立成表，然后在需要使用相关信息的时候，引入即可。\n专业表\n   专业编号(P) 专业名称     0001001 软件工程   0001002 土木工程    学生表\n   学号(P) 姓名 专业编号     1 张三 0001001   2 李四 0001002    逆规范化  为了提升数据查询的效率而刻意违背范式的规则 逆规范化的目标是为了提升数据访问效率 所谓逆规范化就是减少表之间的关联查询（效率降低），刻意增加数据冗余。  表关系  一个表代表一个实体，实体之间都有关联关系 根据范式的要求来设计表关系，减少数据冗余 根据实际需求来设计表关系，提升访问效率  示例 设计一个简单的新闻管理系统的数据库\n 新闻信息表：id、标题、内容、发布时间、作者id（作者主属性）、分类id（分类表主属性）、阅读量、推荐数 作者表：id、作者名字、作者来源id（来源表） 来源表：id、来源名字、来源描述 分类表：id、分类名字、分类级别（父分类id） 评论表：id、评论人id（评论人表）、评论时间、评论内容 评论人表：id、评论人名字  一对一关系  一张表中的一条记录与另外一张表中有且仅有一条记录有关系 一对一关系通常是用来将一张原本就是议题的表拆分成两张表  频繁使用部分：常用字段 不常使用部分：生僻字段 使用相同的主键对应   一对一关系设计较多使用在优化方面  示例    学号(P) 姓名 性别 年龄 身高 体重 籍贯 政治面貌     1 张三 男 20 185 160 山西 农民   2 李四 女 21 168 110 山西 党员     姓名、性别、年龄属于常用字段，频繁查询  一对一关系设计\n 将常用字段取出，与学号组合成一张常用表 将不常用字段取出，与学号组成一张不常用表 表与表数据对应关系：基于学号（唯一）是一对一关系  常用表\n   学号(P) 姓名 性别 年龄     1 张三 男 20   2 李四 女 21    不常用表\n   学号(P) 身高 体重 籍贯 政治面貌     1 185 160 山西 农民   2 168 110 山西 党员    一对多关系   又称多对一关系，一张表中的一条记录与另外一张表的多条记录对应，反过来另外一张表的多条记录只能对应当前表的一条记录\n  一对多关系是实体中非常常见的一种关系，实体设计时也应用非常多\n  一对多关系的核心解决方案是如何让记录能够正确匹配到另外表中的数据\n 一表设计：一表记录在另外一张表中有多条记录，所在无法记录多个字段 多表设计：多表记录在另外一张表中只有一条记录，可以设置字段记录对应的主属性（通常主键）    示例 老师与学科间的关系：一个老师只能教一个学科，但是一个学科可有多个老师来教。\n老师表\n   老师ID(P) 姓名 性别 年龄     1 张三 男 25   2 李四 女 26   3 王五 男 29    学科表\n   学科ID(P) 学科名称 课时长度     1 C++ 600   2 JAVA 800     以上两个实体没有体现彼此之间的关联关系 实际上讲师与学科之间肯定是有关联的  在多表中增加字段维护一表\n   老师ID(P) 姓名 性别 年龄 学科ID     1 张三 男 25 1   2 李四 女 26 2   3 王五 男 29 1    多对多关系  一张表中的一条记录对应另外一个表中多条记录，反过来一样 多对多关系在实体中是最常见的关系 多对多是无法在自身表中维护对应关系（违背1NF），需要通过第三方表来实现多对多关系变成多个多对一关系  设计一个中间表，记录两张表之间的对应关系（主属性） 中间表与其他表都是多对一关系    示例 老师与学生之间的关系：一个老师教多个学生，一个学生也会被多个老师教，实体关系为多对多。\n老师表\n   老师ID(P) 姓名 性别 年龄     1 张老师 男 25   2 李老师 女 26   3 王老师 男 29    学生表\n   学生ID(P) 姓名 性别 年龄     1 张三 男 20   2 李四 女 21   3 王五 男 19     以上实体没有从结构上体现表之间的关系  增加一个中间表\n中间表\n   ID(P) 学生ID 老师ID     1 1 1   2 1 2   3 1 3   4 2 1   5 2 2   6 2 3   7 3 1   8 3 2   9 3 3   ","permalink":"https://www.niuwx.cn/posts/mysql/%E8%8C%83%E5%BC%8F%E5%92%8C%E8%A1%A8%E5%85%B3%E7%B3%BB/","summary":"\u003ch3 id=\"关系型数据库设计范式\"\u003e关系型数据库设计范式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNormal Format\u003c/code\u003e，符合某一种级别的关系模式的集合，表示一个关系内部各个属性之间的联系的合理化程度\u003c/li\u003e\n\u003cli\u003e范式是离散数学的概念\u003c/li\u003e\n\u003cli\u003e范式目标是在满足组织和存储的前提下使数据结构冗余最小化\u003c/li\u003e\n\u003cli\u003e范式级别越高，表的级别就越标准\u003c/li\u003e\n\u003cli\u003e目前数据库应用的范式有以下几层\n\u003cul\u003e\n\u003cli\u003e第一范式：1NF\u003c/li\u003e\n\u003cli\u003e第二范式：2NF\u003c/li\u003e\n\u003cli\u003e第三范式：3NF\u003c/li\u003e\n\u003cli\u003e逆规范化\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"范式和表关系"},{"content":"字段类型  字段类型在定义表结构时设定 设定好字段类型后，插入数据时必须与字段类型对应，否则数据错误 MySQL有四大数据类型  整数类型 小数类型 字符串类型 时间日期类型    整数类型  MySQL中为了数据空间的有效使用，设定了五种整数类型  迷你整型：tinyint，使用1个字节存储整数，最多存储256个整数(-128~127) 短整型：smallint，使用2个字节存储整数 中整型：mediumint，使用3个字节存储整数 标准整型：int，使用4个字节存储整数 大整型：bigint，使用8个字节存储整数   数值型存储在MySQL中分为有符号（有负数）和无符号（纯正数）   步骤\n 确定数据的格式是存储整数 预估整数的范围，选择合适的整数类型 确定整数是否需要符号（负数区间）   示例 # 年龄：无负数，正常年龄不会超过256，迷你整型 create table t1( age tinyint unsigned #unsigned修饰整数，表示无符号 )charset utf8; 显示宽度  显示宽度一般是该整数类型能表示的最大值对应的数字个数（通过desc查看字段表显示） 显示宽度包括符号（如果允许为负数，-负号会增加一个宽度） 显示宽度可以主动控制 显示宽度不会影响类型能表示的最大数值 可以通过zerofill让不够宽度的数值补充到对应宽度：在字段类型后使用zerofill  示例   有符号和无符号对应的宽度不一样\ncreate table t1( a tinyint, b tinyint unsigned )charset utf8;   可以主动控制显示宽度\nalter table t1 add c tinyint(2) unsigned;   显示宽度不影响数据的大小\ninsert into t1 values(1,1,1); insert into t1 values(100,100,100);   可以通过zerofill让小于显示宽度的数值前置补充0到显示宽度\nalter table t1 add d tinyint(2) zerofill; # 0填充只能针对正数 insert into t1 values(1,1,1,1);   小数类型（浮点型）   无法保证精度\n  浮点数又称为精度数据，分为两种\n 单精度：float，使用4个字节存储，精度范围为7~8位有效数字 双精度：double，使用8个字节存储，精度范围位15~16位有效数字    浮点数超过精度范围会自动进行四舍五入\n  精度可以指定整数部分和小数部分\n 默认不指定，整数部分不超过最大值，小数部分保留2位 可以指定：float/double（总长度，小数部分长度）    可以使用科学计数法插入数据\n   步骤\n 确定当前设计的字段的数据为不精确型数据（或者小数） 确定数据的大小或者精度的要求范围  6~7位有效数字使用float 14~15位有效数字使用double   确定精度的分布：整数部分和小数部分   示例   记录商品的价格\ncreate table t1( goods_name varchar(20), goods_price float )charset utf8; insert into t1 values(\u0026#34;lala\u0026#34;,19.99); #正常保留 insert into t1 values(\u0026#34;haha\u0026#34;,1999.9999); #四舍五入成2000   小数类型（定点型）  可以保证精度 不固定存储空间存储 每9个数字使用4个字节存储 定点型可以指定整数部分长度和小数部分长度  默认不指定：10位有效整数，0位小数 可以指定：decimal(有效数位，小数部分数位) 有效数位不超过65个   数据规范  整数部分超出报错 小数部分超出四舍五入     步骤\n 确定小数是否需要保证精度 确定有效数位长度   示例 # 资产和负债应该都是精确的，小数部分可以到分 create table t1( money decimal(14,2), bet decimal(10,2) )charset utf8; insert into t1 values(1111111111.12,1111111.99); insert into t1 values(1111111111.12,111111111111111.99)# 整数部分超出报错 insert into t1 values(1111111111.12,1111111.999)# 四舍五入 insert into t1 values(1111111111.12,99999999.999)# 四舍五入导致整数部分超出报错 字符串类型（定长型）  定长型：char(L)，指定固定长度的存储空间存储字符串 定长是指定存储长度 定长的长度是字符数量而不是字节  L的最大值是255 实际存储空间：$L字符数*字符集对应字节数$   定长里存储的数据不能超过指定长度 字符串数据使用单引号或者双引号包裹   步骤\n 确定数据类型为字符串（或不能用整数存储的超长数字符号） 确定数据长度基本一致（定长占用固定空间） 确定具体长度   示例 记录个人信息：身份证信息和手机号码\n# 身份证为固定长度18为 # 手机号码为11位固定长度 create table t1( id_number char(18), phone_number char(11) )charset utf8; insert into t1 values(\u0026#39;142629190001016666\u0026#39;,\u0026#39;12345678910\u0026#39;); 字符串类型（变长型）  变长型：varchar(L)，根据实际存储的数据变化存储空间 变长型的存储空间是由实际存储数据决定的 变长型的L也是指字符而不是字节  L指定的是最大存储的数据长度 L最大值理论是65535 变长需要额外产生1-2个字节，用来记录实际数据的长度  数据长度小于256，多1个字节 数据长度大于256，多2个字节   实际存储空间：$实际字符数*字符集对应字节数+记录长度$   变长数据不能超过定义的最大长度   步骤\n 确定数据类型为字符串 确定数据是不规则的数据 确定最大长度   示例 记录个人信息：用户名、密码、姓名、身份证\n# 用户名不确定长度，最长不超过50个字符 # 密码不确定长度，最长不超过16个字符 # 姓名不确定长度，最长不超过10个字符 # 身份证固定长度，18个字符 create table t1( `username` varchar(50), `password` varchar(16), `name` varchar(10), `id_number` char(18) )charset utf8; # 使用``包括字段名，防止字段名与关键字重名导致报错  insert into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;14262919000101666\u0026#39;); 字符串类型（文本字符串）  test/blob，专门用来存储较长的文本 文本字符串包含两大类  test：普通字符  tinytext：迷你文本，不超过$2^8-1$个字符 text：普通文本，不超过$2^{16}-1$个字符 mediumtext：中型文本，不超过$2^{24}-1$个字符 longtext：长文本，不超过$2^{32}-1$个字符（4G）   blob：二进制字符（与text类似）  tinyblob blob mediumblob longblob     文本字符串会自动根据文本长度选择合适的具体类型 一般在文本超过255个字符时，都会使用text（blob现在极少使用）   步骤\n 确定类型为文本文件 确定数据长度可能超过255个字符 使用text   示例 # 标题一般不会超过50个字符，varchar # 作者一般不会超过10个字符，varchar # 内容通常都很长，使用text create table t1( author varchar(10), title varchar(50), content text )charset utf8; insert into t1 values(\u0026#39;佚名\u0026#39;,\u0026#39;给家长的一封信\u0026#39;,\u0026#39;某某某的爸爸/妈妈...您好...\u0026#39;); 字符串类型（枚举）  一种映射存储方式，以较小的空间存储较多的数据 枚举是在定义时确定可能出现的问题 枚举在定义后数据只能出现定义时其中的一种 枚举类似一种单选框 枚举使用1-2个字节存储，最多可以设计65535个选项 枚举实际存储是使用数值，映射对应的元素数据，从1开始 枚举语法：enum(元素1,元素2....元素N)   步骤\n 确定数据是固定的几种数据之一 使用枚举穷举相应的元素 数据存储只能选择穷举中的元素之一   示例   记录人群类型：小朋友，少年，青年，中年，老年，每个人只属于一种类型题\ncreate table t1( type enum(\u0026#39;小朋友\u0026#39;,\u0026#39;少年\u0026#39;,\u0026#39;青年\u0026#39;,\u0026#39;中年\u0026#39;,\u0026#39;老年\u0026#39;) )charset utf8; insert into t1 values(\u0026#39;少年\u0026#39;); insert into t1 values(\u0026#39;神仙\u0026#39;);# error 不存在的数据不能插入   enum是建立映射关系，然后实际存储是数字，数值是按照元素顺序从1开始\n# 可以使用字段 + 0来判断数据具体的效果（字符串转数值为0） select type,type + 0 from t1; insert into t1 values(5);   字符串类型（集合）  set，一种映射存储方式，以较小的空间存储较多的数据 集合是在定义时确定可能出现的元素进行穷举 集合在定义后数据只能出现定义时其中的元素（可以是多个） 集合类似一种多选框 集合使用1-8个字节存储数据，最多可以设计64个元素 集合实际存储是使用数值（二进制位），映射对应的元素数据，每个元素对应一个比特位 集合语法：set(元素1,元素2,.....元素N)   步骤\n 确定数据是固定的几种数据集合 使用集合穷极相应的元素 数据存储只能选择穷举中的元素组合   示例   记录个人的球类爱好，有篮球，足球，羽毛球，网球，乒乓球，排球，台球，冰球\n# 爱好可以使多种 create table t1( hobby set(\u0026#39;足球\u0026#39;,\u0026#39;篮球\u0026#39;,\u0026#39;羽毛球\u0026#39;,\u0026#39;网球\u0026#39;,\u0026#39;乒乓球\u0026#39;,\u0026#39;排球\u0026#39;,\u0026#39;台球\u0026#39;,\u0026#39;冰球\u0026#39;) )charset utf8; insert into t1 values(\u0026#39;足球\u0026#39;); insert into t1 values(\u0026#39;足球,台球,篮球\u0026#39;);   集合建立的也是映射关系，映射方式是每个元素对应一个字节的比特位， 从左边开始第一个对应字节从右边开始的第一位\n# 可以通过字段 + 0的方式查看存储的具体数值 select hobby,hobby + 0 from t1; # 可以通过插入数值来组合元素，但是需要确定对应的十进制转换成二进制有对应的元素对应 insert into t1 value(8); # 网球   时间如期类型（年）  year，MySQL中用来存储年份的类型 MySQL中使用1个字节存储年份 year能够表示的范围是1901-2155（256年）  year的特殊值是0000   year允许用户是用两种方式设计（效果一样）  year year(4)     步骤\n 确定存储的数据是年份 确定年份的区间在1901-2155之间 使用year类型   示例   记录个人的出生年份\ncreate table t1( y1 year, y2 year(4) )charset utf8; insert into t1 values(1901,2155); insert into t1 values(1800); # error 不在范围内   year类型允许使用2位数来插入，系统自动匹配对应的年份\n 69以前：系统默认加2000 69以后：系统默认加1900  insert into t1 values(69,70); insert into t1 values(68,71);   year类型的特殊值是0000，可以使用00或者0000插入\ninsert into t1(00,0000);   时间日期类型（时间戳）  timestamp，基于格林威治时间的时间记录 MySQL中时间戳表现形式不是秒数，而是年月日时分秒格式  YYYY-MM-DD HH:II::SS YYYYMMDDHHIISS   timestamp使用4个字节存储 timestamp的特点是所对应的记录不论哪个字段被更新，该字段都会更新到当前时间   步骤\n 确定类型需要使用年月日时分秒格式 确定当前字段需要记录数据的最近更新时间 使用timestamp时间戳   示例   记录商品库存的最后更新时间\ncreate table t1( goods_name varchar(10), goods_inventory int unsigned, change_time timestamp )charset utf8; insert into t1 values(\u0026#39;大白菜\u0026#39;,100,\u0026#39;1971-01-01 00:00:00\u0026#39;); insert into t1 values(\u0026#39;小白菜\u0026#39;,100,\u0026#39;19700101000000\u0026#39;);   timestamp会在自己所在的记录任何位置被修改时自动更新时间\nupdate t1 set goods_inventory = 90; 在MySQL8后，取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性：on update current_timestamp\nalter table t1 add c_time timestamp on update current_timestamp update t1 set goods_inventory = 80;   时间日期类型（日期）  date，用来记录年月日信息 使用3 个字节存储数据 存储日期的格式为：YYYY-MM-DD 存储的范围是：1001-01-01到9999-12-31 目前来说，还够用   步骤\n 确定存储的数据格式为日期格式 确定数据格式为YYYY-MM-DD 使用date类型   示例 记录个人生日\ncreate table t1( `name` varchar(10), birth date )charset utf8; insert into t1 values(\u0026#39;张三\u0026#39;,\u0026#39;2000-01-01\u0026#39;); insert into t1 values(\u0026#39;李四\u0026#39;,\u0026#39;2021-07-23\u0026#39;); 时间日期类型（日期时间）  datetime，用来综合存储日期和时间 存储格式为：YYYY-MM-DD HH:II:SS 存储区间为：1000-01-01 00:00:00到9999-12-31 23:59:59   步骤\n 确定存储的时间格式包含日期 确定存储格式为：YYYY-MM-DD HH:II:SS 使用datetime   示例 记录个人具体的出生时间\ncreate table t1( `name` varchar(10), birth datetime )charset utf8; insert into t1 时间日期类型（时间）  time，用来记录时间或者时间段 数据范围是：-838:59:59-838:59:59 数据插入的格式分为两种  时间格式：HH:II:SS 时间段格式：D HH:II:SS     步骤\n 确定要存储的类型是时间格式 确定格式类型为time能表示的格式 使用time存储   示例 记录用户登录的具体时间\n# 具体登录时间可以使用时间戳（包含年月日时分秒信息） # 也可以使用时间datetime格式，或者date+time双字段格式 create table t1( login_time1 int unsigned, login_time2 datetime, login_date date, login_time3 time )charset utf8; insert into t1 values(12345678,\u0026#39;2000-12-12 12:12:12\u0026#39;,\u0026#39;2000-12-12\u0026#39;,\u0026#39;12:12:12\u0026#39;); insert into t1 values(1234567,\u0026#39;2000-12-12 12:12:12\u0026#39;,\u0026#39;2000-12-12\u0026#39;,\u0026#39;3 12:12:12\u0026#39;); 属性 属性作用  建立在字段类型之后，对字段除类型之外的其他约束 属性是在定义表字段的时候针对每个字段进行属性设定 设定好的属性可以通过查看表字段desc进行查看 数据在进行增删改（写）操作时需要在满足字段要求的同时满足属性的要求  示例 desc t1; # Field: 字段名字 # Type: 数据类型 # Null: 是否为空（属性） # Key: 索引类型（属性） # Default: 默认值（属性） # Extra: 额外属性 NULL属性  NULL：数据是否允许为空 不为空设计： Not Null 数据为空一般不具备运算和分析价值，所以通常数据都需要设定Not Null（不区分大小写）   步骤\n 数据类型确定 数据是否为空确定  允许为空：不考虑Null属性 不允许为空：Not Null     示例   用户信息表：用户名、密码、姓名、年龄、注册时间\ncreate table t1( `username` varchar(50) not null, `password` char(32) not null, name varchar(20), age tinyint unsigned, reg_time int unsigned not null )charset utf8;   如果字段不能为空（Not Null），那么数据就必须满足条件：插入时不能为空的字段就需要主动提供值\ninsert into t1 values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;,\u0026#39;张三\u0026#39;,20,123456789); # 错误操作，reg_time不能为空，而默认为空， insert into t1 (`username`,`password`) values(\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;);   Defaule属性  defaule，在设计表字段的时候给定默认数据，在后续字段操作（数据新增）的时候系统没有检测到字段有数据的时候自动使用的值 默认值在字段设计的时候使用（默认值需要满足数据类型规范） 默认值通常设计的字段容易出现的数据  一般字段的默认值默认是Null   默认值触发  在系统进行数据插入时自动检测触发 主动使用default关键字触发默认值     步骤\n 确定字段的数据类型 确定字段可能出现的数据会是某个经常出现的值 设定默认值 触发默认值  自动触发：数据插入时不给字段复制 手动触发：数据插入时主动使用default关键字     示例   用户开户：银行卡账号、身份证号码、姓名、账户余额\ncreate table t1( account varchar(19) not null, id_card char(18) not null, `name` varchar(20) not null, money decimal(16,2) default 0.00 not null )charset utf8;   默认值触发\n# 默认触发 insert into t1 (account,id_card,name) values(\u0026#39;123456789101112131\u0026#39;,\u0026#39;142629200001011010\u0026#39;,\u0026#39;张三\u0026#39;); # 主动触发 insert into t1 values(\u0026#39;123456789101112131\u0026#39;,\u0026#39;142629200001010101\u0026#39;,\u0026#39;李四\u0026#39;,default);   主键  primary key，用来保证整张表中对应的字段永远不会出现重复数据 主键在一张表中只能有一个 主键的另外一个特性是能够提升主键字段作为查询条件的效率(索引) 主键不能为空：Not Null(默认) 逻辑主键：数据没有具体业务意义，纯粹是一种数值数据  逻辑主键通常是整数：int 逻辑主键目的是方便检索和数据安全（不暴露数据真实信息）   复合主键：多个字段共同组成不能重复的数据  primary key(字段1,字段2,...) 联合主键使用不多，一般也不会超过2个字段     步骤\n 确定字段数据具有唯一性 确定数据不允许为空 确定数据会经常用于数据检索 使用主键primary key 一般每张表都会使用一个逻辑主键(id)   示例   银行账户信息：账户、姓名、余额\n# 银行账户具有唯一性，不可重复，不可为空 create table t1( account varchar(17) primary key, `name` varchar(20) not null, money decimal(16,2) not null default 0.00 )charset utf8; # 复合主键 create table t2( account varchar(17), `name` varchar(20), money decimal(16,2) not null default 0.00, primary key(account,`name`) )charset utf8; # 一般使用逻辑主键 create table t3( id int unsigned primary key, account varchar(17) not null, `name` varchar(20) not null, money decimal(16,2) not null default 0.00 )charset utf8;   主键数据不允许重复\ninsert into t3 values(1,\u0026#39;123456\u0026#39;,\u0026#39;1\u0026#39;,default); # 错误 主键1已经存在 insert into t3 values(1,\u0026#39;456789\u0026#39;,\u0026#39;2\u0026#39;,default); # 联合主键就是联合字段加起来不重复即可 insert into t2 values(\u0026#39;123456\u0026#39;,\u0026#39;Tom\u0026#39;,default); insert into t2 values(\u0026#39;456789\u0026#39;,\u0026#39;Tom\u0026#39;,default);   主键管理  在创建表并且已经有数据后的维护 删除主键 追加主键 修改主键（先删后增）  示例   删除主键：主键只有一个，所以删除语法也比较特殊\nalter table t1 drop primary key;   后期新增主键：如果是针对业务主键需要保证字段数据没有Null数据且没有数据重复（一般主键都会在表创建时维护好）\nalter table t1 add primary key(account,name);   自增长属性  auto_increment，被修饰的字段在新增时，自动增长的数据 自增长数据可以理解为一种默认值，如果主动给值，那么自动增长不会触发 自增长有两个变量控制  初始值：auto_increment_offset，默认为1 步长：auto_increment_increment，默认为1 查看自增长控制：show variables like 'auto_increment'     步骤\n 确定数据类型为整形 确定数据需要有规则的变化  从1开始 每次增长1 可以调整，但是通常有固定规则   必须有索引字段（索引主键） 使用auto_increment   示例   记录学生信息：学号和姓名\n# 学生信息：学号自动增长 create table t1( id int primary key auto_increment, stu_no int(8) zerofill not null, stu_name varchar(20) not null )charset utf8;   触发自增长\n# 使用自增长 可以使用NULL或者default触发 insert into t1 values(null,1,\u0026#39;Jim\u0026#39;); insert into t1 values(default,2,\u0026#39;Tom\u0026#39;); #主动控制：自增长的值会从当前最大的值开始自动增长 insert into t1 values(5,3,\u0026#39;张三\u0026#39;); insert into t1 (stu_no,stu_name) values(4,\u0026#39;李四\u0026#39;);   自增长管理  修改表中自增长的值：让下次自增长按照指定的值开始 修改自增长的控制：调整自增长的变化  示例   修改表中自增长的值，跳过一些值，直接从下次开始按照新的目标出现\nalter table t1 auto_increment = 50; insert into t1 (stu_no,stu_name) values(1,\u0026#39;测试1\u0026#39;); # 奇数保留原值，偶数自动加一（可能） 由于数据不稳定   修改自增长控制：步长和起始值（修改针对的是整个数据库，而非单张表）\nset auto_increment_increment = 2;# 当前用户当前连接有效（局部） set @@auto_increment_incremtn = 2;# 所有用户一定有效（全局）   唯一键  unique key，用来维护数据的唯一性 一个表中可以有多个唯一键 唯一键与主键的区别在于唯一键允许数据为Null（且数量不限） 唯一键与主键一样，可以提升字段数据当做条件查询的效率（索引） 复合唯一键：多个字段共同组成  unique key(字段1,字段2,字段3,...) 一般不会出现，最多2个字段组成     步骤\n 确定数据列具有唯一性 确定数据列不用作为主键 确定数据会经常用于检索条件 该字段是否允许数据为空 使用唯一键   示例   用户表：用户名唯一，而且经常作为查询条件\ncreate table t1( id int primary key auto_increment, `username` varchar(50) unique, `password` char(32) not null )charset utf8; insert into t1 values(null,\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;); insert into t1 values(null,Null,\u0026#39;password\u0026#39;); insert into t1 values(null,Null,\u0026#39;password\u0026#39;); # 错误 insert into t1 values(null,\u0026#39;username\u0026#39;,\u0026#39;password\u0026#39;);   学生成绩表：一个学生只能有一个学科成绩，但是可以有多个学科\n# 学号和学科编号共同组成唯一 create table t1( id int primary key auto_increment, stu_name varchar(20) not null, course varchar(20) not null, score decimal (5,2), unique key(stu_name,course) )charset utf8; insert into t1 values(null,\u0026#39;Jim\u0026#39;,\u0026#39;Math\u0026#39;,60); insert into t1 values(null,\u0026#39;Jim\u0026#39;,\u0026#39;English\u0026#39;,60);   唯一键管理  删除唯一键：一张表中不止一个唯一键，所以删除方式相对麻烦：alter table 表名 drop index 唯一键名字 新增唯一键：alter table 表名 add unique key(字段列表)  示例   删除表中已有的唯一键\nalter table t1 drop index `stu_name`;   追加唯一键\nalter table t1 add unique key `stu_course` (stu_name,course);   comment 属性  comment，是用文字描述字段的作用的 comment代表的内容是对字段的描述  方便以后自己了解字段的作用 方便团队了解字段的作用   描述如果涉及到字符集（中文）一定要在创建表之前设计好客户端字符集（否则会出现乱码）  示例 create table t1( id int primary key auto_increment comment \u0026#39;id逻辑主键自增长\u0026#39; )charset utf8; 数据库记录长度  MySQL中规定一条记录所占用的存储长度最长不超过65535个字节 记录长度是表中所有字段预计占用的长度之和 所有字段只要允许Null存在，系统就会一个字节存储Null 因为MySQL记录长度的存在，varchar永远达不到理论长度 一般数据长度超过255个字符都会使用text/blob进行存储 ","permalink":"https://www.niuwx.cn/posts/mysql/%E5%AD%97%E6%AE%B5/","summary":"\u003ch3 id=\"字段类型\"\u003e字段类型\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e字段类型在定义表结构时设定\u003c/li\u003e\n\u003cli\u003e设定好字段类型后，插入数据时必须与字段类型对应，否则数据错误\u003c/li\u003e\n\u003cli\u003eMySQL有四大数据类型\n\u003cul\u003e\n\u003cli\u003e整数类型\u003c/li\u003e\n\u003cli\u003e小数类型\u003c/li\u003e\n\u003cli\u003e字符串类型\u003c/li\u003e\n\u003cli\u003e时间日期类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"字段"},{"content":"字符集 了解字符集的概念，掌握MySQL数据库存储数据的字符集逻辑以及设置方式\n字符集的概念  字符集根据不同国家的符号不同，有不同的字符集 不同的字符集占用的存储空间不一样，存储的底层也不一样 不同字符集之间可以进行转换 常见字符集  ASCⅡ：美国信息交换标准码，一般英文符号，一个字节存储 latin1：拉丁文字符集，一个字节存储，ISO-8859-1的别名，能够向下兼容ASCIⅡ GB2312：信息交换用汉字编码字符集，是中国1981年的一套国际规范，2个字节存储 GBK：汉字内码拓展规范（1995年），两个字节表示 Unicode：万国码（统一码），使用同一的编码方式来解决传统的局限，1994年出现 UTF-8：针对Unicode的可变长度字符编码，采用1-6个字节编码Unicode字符 （目前通用编码规则）。建议使用UTF-8字符集进行数据存储。（MySQL8中建议使用UTF8MB4）    示例 ASCⅡ码表\nMySQL字符集  MySQL内部对象可以在各个层级设置字符集 MySQL内部对象存在字符集继承：字段-\u0026gt;表-\u0026gt;数据库-\u0026gt;DBMS MySQL内部内嵌几乎所有主流字符集 数据存储的最终字符集由字段控制 客户端与服务器进行交互时，需要明确告知服务器客户端自己的字符集（数据格式）  示例 查看MySQL支持的所有字符集\nshow charset; 乱码问题解决   乱码原因1：数据在存储的时候已经变成乱码\n 客户端字符集与服务端解析字符集不一致 读取时想转成其他字符集均会错误    乱码原因2：数据存储时正确，但是读取时解析成错误字符集\n 客户端能解析的字符集与服务器提供的字符集不一致    乱码解决方案：不论存储还是读取，都提前告知服务器当前客户端的字符集\nset names 客户端字符集;   字符集设置原理  MySQL服务器提供了变量来记录客户端的字符集 MySQL对应的存储字符集的变量可以修改 set names 字符集就是对变量的修改，总共有三个  character_set_client：客户端提供的数据的字符集 character_set_results：客户端需要服务端提供的数据的字符集 character_set_connection：连接使用的字符集，内部数据操作    示例   查看系统内部存储这些记录字符集的信息\nshow variables like \u0026#39;character_set%\u0026#39; # %表示通配符，匹配后续不确定的数据   修改客户端字符变量，保证数据正常存进服务端\nset character_set_client = gbk;   修改客户端解析字符集变量，保证数据正常被客户端查看\nset character_set_results = gbk;   使用set names 字符集批量修改，保证客户端被服务端正确理解，同时客户端也能正常解析\nset names gbk;   校对集 校对集概念  数据比较时对应的规则 校对集依赖字符集 校对集的校对方式分为三种：  大小写不敏感：_ci,case insensitive 大小写敏感：_cs，case sensitive 二进制比较：_bin,binary（大小写敏感）   校对集是在进行数据比较的时候触发  示例   _ci，大小写不敏感\n# A 和 a是相同的，不存在谁大谁小   _cs，大小写敏感\n# A 和 a有大小关系，所以不同   _bin，二进制比较\n# A 的二进制 01000001 # a 的二进制 01100001 # 二进制按位比较，所以不同   校对集设置   校对规则可以在MySQL四层对象设计\n DBMS：系统配置 DB：数据库指定（库选项） Table：标指定（表选项） Filed：字段指定（字段选项，一般不用）    校对集从Field到DBMS继承：优先级Field最高\n  每个校对集都有字符集对应的默认规则\n  校对集设置语法\ncollate 校对集规则;   示例   查看MySQL支持的所有校对集\nshow collation;   在数据库层设置校对集（常用）\ncreate database test_4 charset utf8MB4 collate utf8MB4_bin;   在数据表层设计校对集\ncreate table t_4( id int, name varchar(10) ) charset utf8Mb4 collate utf8MB4_bin;   在字段层设计校对集（一般不常用）\ncreate table t_4( id int, name varchar(50) collate utf8Mb4_bin )charset utf8MB4;   校对集应用  校对集的应用通常是通过数据比较触发：order by 字段 数据表中数据一旦产生，校对集的修改就无效  示例   创建校对规则数据表并插入数据\n# 创建默认校对规则表（不区分大小写） CREATE TABLE t1( name varchar(1) )CHARSET utf8Mb4; INSERT INTO t1 values(\u0026#34;B\u0026#34;); INSERT INTO t1 values(\u0026#34;A\u0026#34;); INSERT INTO t1 values(\u0026#34;b\u0026#34;); INSERT INTO t1 values(\u0026#34;a\u0026#34;); select * from t1 order by name; #执行结果 A a B b # 创建二进制校对规则（区分大小写） CREATE TABLE t2( name varchar(1) )charset utf8MB4 collate utf8MB4_bin; INSERT INTO t2 VALUES(\u0026#34;B\u0026#34;); INSERT INTO t2 VALUES(\u0026#34;A\u0026#34;); INSERT INTO t2 VALUES(\u0026#34;b\u0026#34;); INSERT INTO t2 VALUES(\u0026#34;a\u0026#34;); select * from t2 order by name; #执行结果 A B a b   触发校对：排序order by\nselect * from t1 order by name; select * from t2 order by name;   数据已经存在的表重新修改校对规则\nalter table t1 collate utf8MB4_general_ci; # 不会报错，但是实际校对规则依旧不变   校对集的触发自动的，只要数据在进行比较的时候就会自动触发设定的校对规则。\n","permalink":"https://www.niuwx.cn/posts/mysql/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%9B%86/","summary":"\u003ch3 id=\"字符集\"\u003e字符集\u003c/h3\u003e\n\u003cp\u003e了解字符集的概念，掌握MySQL数据库存储数据的字符集逻辑以及设置方式\u003c/p\u003e","title":"字符集、校对集"},{"content":"SQL语法规则  概念 SQL语法规则：SQL是一种结构化编程语言\n  基础SQL指令通常是以行为单位 SQL指令需要语句结束符，默认是英文分号：;、\\g、\\G  \\G：主要用于查询数据   SQL指令类似自然语言 编写的SQL中如果用到了关键字或者保留字，需要使用反引号``来包括，让系统忽略   示例\n  结构创建  create 数据类型 结构名 结构类型; 显示结构  #显示结构 show 结构类型（复数）; #显示结构创建详细 show create 结构类型 结构名; 数据操作（数据表）  #新增数据 insert into 表名 values #查看数据 select from 表名 #更新数据 update 表名 set #删除数据 delete from 表名 根据数据库的对象层级，可以将基础SQL操作分为三类：\n 库操作：数据库相关操作 表操作：数据表（字段）相关操作 数据操作：数据相关操作  SQL库操作 创建数据库  使用create database 数据库名字 创建  数据库层面可以指定字符集：charset/character set   数据库层面可以指定校对集：collate 创建数据库会在磁盘指定存放处产生一个文件夹 创建语法：  create database 数据库名字 [数据库选项]; 示例   创建一个指定名字的数据库\ncreate database test_1;   创建一个指定字符集的数据库\ncreate database test_2 charset utf8MB4   创建一个指定校对集的数据库\ncreate database test_3 charset utf8MB4 collate utf8mb4_general_ci;   数据库命名规则：与C同\n显示数据库  数据库的查看是根据用户权限限定的 数据库的查看分为两种查看方式：  查看全部数据库 查看数据库创建指令    示例   显示数据库\nshow databases;   显示数据库创建命令\nshow create databases test_1;   使用数据库  数据库的操作通常是针对数据表或数据 通过使用数据库可以让后续指令默认针对具体数据库环境、简化后续命令 使用数据库语法：use 数据库名字;  示例 use test_1; 修改数据库   数据库名字不可修改（老版本可以）\n 先新增 后迁移 再删除    数据库修改分为两个部分\n 字符集 校对集    数据库修改指令（与创建指令差不多）\nalter database 数据库名字 库选项   示例   修改数据库字符集\nalter database test_2 charset dbk;   修改数据库校对集（如果字符集修改必须同时改变字符集）\nalter database test_3 charset gbk collate gbk_chinese_ci;   删除数据库   删除数据库会删除数据库内所有的表和数据\n  删除数据库操作要慎重（删前备份）\n  删除数据库后，对应的存储文件夹就会消失\n  删除语法\ndrop database 数据库名字;   示例 drop database test_1; SQL表（字段）操作 创建数据表 根据业务需求，确定数据表的字段信息，然后创建表结构\n  表与字段不分家，相辅相成\n  表的创建需要指定存储的数据库\n 明确指定数据库 先使用数据库    字段至少需要指定改名字、类型\n  数据库表不限定字段数量\n 每个字段间使用逗号,分隔 最后一个字段不需要逗号    表可以指定表选项（都有默认值）\n 存储引擎：engine[=]具体存储引擎 字符集：[default] charset 具体字符集 （继承数据库） 校对集：collate（继承数据库）    表创建语法\ncreate table [数据库名.]表名( 字段名 字段类型, ... 字段名 字段类型, )表选项;   示例   创建简单数据表\ncreate table t_1( name varchar(50) );   创建数据表\u0026mdash;多字段\ncreate table t_2( name varchar(50), age int, gender varchar(10) );   创建数据表\u0026mdash;表选项\ncreate table t_3( name varchar(50) )engine Innodb charset utf8MB4;    拓展\n存储引擎是指数据存储和管理方式，MySQL中提供了多种存储引擎，一般使用默认存储引擎。\n InnoDB  默认存储引擎 支持事务处理和外键 数据统一管理   MyIsam  不支持事务和外键 数据、表结构、索引独立管理 MySQL5.6以后不在维护    如果想创建一个与已有表一样的数据表，MySQL提供了一个便捷的复制模式\n create table 表名 like 数据库名字.表名   显示数据表  数据表的显示与用户权限有关 显示数据表有两种方式  显示所有数据表 显示具体数据表的创建指令    示例   显示所有数据表\u0026mdash;当前数据库下\nshow tables;   显示所有数据表\u0026mdash;指定数据库\nshow tables from test_1;   显示部分关联数据表\u0026mdash;匹配\nshow tables like \u0026#39;%like\u0026#39;; #_：匹配一个字符(固定位置) #%：匹配N个字符   显示数据表的创建指令\nshow create table t_1;   查看数据表   通常是查看字段信息\n  详细的显示字段的各项信息\n  查看语法有三种\ndesc 表名; describe 表名; show columns from 表名;   更改数据表  更改表名：rename teble 表名 to 新表名 修改表选项：alter table 表名  示例   修改表名\nrename table t_1 to t1; 注意：如果有时候要跨库修改的话，需要使用数据库名.表名\n  修改表选项\nalter table t1 charset gbk;   更改字段  字段操作包含字段名字、类型和属性的操作 字段操作通常是在表已经存在数据后进行  新增字段   字段的新增必须同时存在字段类型\n  新增语法\nalter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]   示例   给已经存在的表增加一个字段\nalter table t1 add age int;   字段位置   字段位置分为两种\n 第一个字段：first 某个字段后：after已经存在字段名    字段位置适用于追加字段、修改字段、更改字段名\n  字段位置语法\nalter table 表名 字段操作 字段位置;   示例   为表增加一个字段，放在最前面\nalter table t1 add id int first;   在表某字段后增加一个字段\nalter table t1 add card varchar(18) after name;   更改字段名   字段名的修改必须跟上字段类型\n  字段名修改语法\nalter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置];   示例 修改字段名card为sfz\nalter table t1 change card sfz varchar(18); 修改字段   修改字段类型、字段属性和位置\n  修改字段语法\nalter table 表名 modify 字段名 字段类型 [字段属性] [位置];   示例 修改sfz类型为char(18)并且把位置放到id后面\nalter table t1 modify sfz char(18) after id; 删除字段   删除字段会将数据也删除\n  删除字段语法\nalter table 表名 drop 字段名;   示例 alter table t1 drop age; SQL数据操作 新增数据  新增数据是根据表的字段顺序和数据类型要求将数据存放到数据表中 数据表中的数据以行(row)为存储单位，实际存储属于字段(field)存储数据 数据插入分两种方式  全字段插入：insert into 表名 values(字段列表顺序对应的所有值) 部分字段插入：insert into 表名(字段列表) values(字段列表对应的值的顺序列表)    示例   插入完整数据\ninsert into t1 values(1,\u0026#34;666\u0026#34;,\u0026#34;张三\u0026#34;,\u0026#34;小张\u0026#34;);   根据字段插入数据\ninsert into t1 (id,name ) values(1,\u0026#34;李四\u0026#34;);   查看数据   查到的数据显示出来是一张二维表\n  数据显示包含字段名和字段本身\n  数据查看分两种方式\n 查看全部字段：使用*代替所有字段 查看部分字段：明确字段名，使用逗号分隔    查看数据很多时候也是根据条件查询部分数据\n  查看语法\nselect */字段列表 from 表名;   示例   查看所有数据\nselect * from t1;   查看部分字段数据\nselect id,name;   查看表中id为1的信息\nselect * from t1 where id = 1;   更新数据   更新数据通常时根据条件更新某些数据，而不是全部记录都更新\n  更新数据语法\nupdate 表名 set 字段 = 新值[,字段 = 新值] [where 条件筛选];   示例   更新所有记录的身份信息\nupdate t1 set sfz = \u0026#34;777\u0026#34;;   更新某个记录的多个字段数据\nupdate t1 set name = \u0026#34;张三\u0026#34;，sfz = \u0026#34;666\u0026#34; where id = 777;   删除数据   删除数据是一种不可逆操作\n  数据删除通常都是有条件删除\n  数据删除语法\ndelete from 表名 [where 条件];   示例 删除数据\ndelete from t1 where id = 777; ","permalink":"https://www.niuwx.cn/posts/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"\u003ch3 id=\"sql语法规则\"\u003eSQL语法规则\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e概念\n\u003cstrong\u003eSQL语法规则\u003c/strong\u003e：SQL是一种结构化编程语言\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e基础SQL指令通常是以行为单位\u003c/li\u003e\n\u003cli\u003eSQL指令需要语句结束符，默认是英文分号：\u003ccode\u003e;\u003c/code\u003e、\u003ccode\u003e\\g\u003c/code\u003e、\u003ccode\u003e\\G\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\\G\u003c/code\u003e：主要用于查询数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSQL指令类似自然语言\u003c/li\u003e\n\u003cli\u003e编写的SQL中如果用到了关键字或者保留字，需要使用反引号``来包括，让系统忽略\u003c/li\u003e\n\u003c/ul\u003e","title":"MySQL基本操作"},{"content":"数据库的基本知识  概念\n数据库：database，是一种存储数据的仓库。\n  数据库是根据数据结构组织，存储和管理数据的 数据库能够长期、高效的管理和存储数据 数据库的目的就是能够存储（写）和提供（读）数据  数据库分类  概念\n数据库分类：根据数据库的架构和数据组织原理进行分类。\n   早起根据数据库的组织数据的存储模型分类\n 层次数据库：基于层次的数据结构（数据分层） 网状数据库：基于网状的数据结构（数据网络） 关系数据库：基于关系模型的数据结构（二维表）    现在较多根据实际数据管理模型分类（存储介质）\n 关系型数据库：基于关系模型的数据结构（二维表）通常存储在磁盘 非关系型数据库：没有具体模型的数据结构（键值对）通常存储在内存    关系型数据库  概念\n关系型数据库：一种建立在关系模型上的数据库\n  关系模型：  关系数据结构（存储） 关系操作集合（操作） 关系完整约束（约束）   关系型数据库存储在磁盘中（永久性存储） 关系型数据库系统(DBS)模型有四层结构  数据库管理系统(DBMS)：管理系统运行 数据库(DB)：数据存储的管理者 数据表(Table)：数据关系管理者 数据字段(Field)：依赖于数据表、实际数据存储者   关系型数据库产品  大型：Oracle、DB2 中性：MySQL、SqlServer 小型：Sybase、Access    非关系型数据库  概念\n非关系型数据库：NoSQL（Not only SQL），不仅仅是关系型数据库\n  所以不是关系型数据库的统称 数据存储模型不是二维表，而是键值对（KEY-VALUE） 存储的位置通常是内存（效率高） 不能永久性存储（需要定时存到关系型数据库中） 常见的非关系型数据库产品  MongoDB Redis Memcached    对比 NoSQL通常与关系型数据库配合使用，他们彼此是一种互补关系。\n NoSQL运行在内存、解决效率问题  I/O问题 效率问题   MySQL运行在磁盘、解决稳定问题  安全问题（永久存储） 稳定    SQL基本介绍  概念\nSQL：Structured Query Language，结构化查询语言，是一种针对关系型数据库特殊标准化的编程语言。\n  SQL是一种编程语言 能够实现用户数据库查询和程序设计 SQL根据操作不同，分为几类：  DQL：Data Query Language ，数据查询语言，用于查询和检索数据 DML：Data Manipulation Language，数据操作语言，用于数据的写操作（增删改） DDL：Data Definition Language，数据定义语言，用于创建数据结构 DCL：Data Control Language，数据控制语言，用于用户权限管理 TPL：Transaction Process Language，事务处理语言，辅助DML进行事务操作（因此也归属于DML）     SQL虽然是编程语言，但是目前数据库通常只用来进行数据管理（逻辑部分给其他编程语言） SQL虽然是针对关系型数据库的通用语言，但是不同的产品操作指令不完全通用  MySQL基本介绍  概念\nMySQL：瑞典AB公司下的一款关系型数据库\n  MySQL当前属于甲骨文公司（AB-\u0026gt;Sun-\u0026gt;Oracle） MySQL开源免费（部分存储引擎收费） MySQL是一种C/S结构软件，因此需要MySQL的客户端来访问服务端（数据管理）  mysqld.exe：服务端 mysql.exe：客户端   MySQL使用SQL指令对数据库进行操作  访问原理 graph LR\rA[MySQL客户端] --\u0026gt;B[寻找服务端 host寻找]\rB --\u0026gt; C[寻找服务器 Port寻找]\rC --\u0026gt; D[验证身份 username验证 password验证]\rD --\u0026gt; E{服务器}\rMySQL访问  MySQL访问：客户端连接上服务器，然后实现数据操作的过程\n  客户端访问服务端  利用Windows控制台访问（MySQL客户端） 利用数据库管理工具（Navicat）   客户端需要连接认证  -h：主机地址（本机localhost 、可以忽略） -P：端口号（默认3306） -u：用户名 -p：用户密码   客户端连接上服务端就表示占用了一个资源，可以进行对应权限的操作  MySQL数据库连接资源有限：单个服务器最多16384个 连接资源不够了其他访问就需要排队等待 用完尽可能释放资源   ","permalink":"https://www.niuwx.cn/posts/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","summary":"\u003ch3 id=\"数据库的基本知识\"\u003e数据库的基本知识\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e概念\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据库\u003c/strong\u003e：database，是一种存储数据的仓库。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e数据库是根据数据结构组织，存储和管理数据的\u003c/li\u003e\n\u003cli\u003e数据库能够长期、高效的管理和存储数据\u003c/li\u003e\n\u003cli\u003e数据库的目的就是能够存储（写）和提供（读）数据\u003c/li\u003e\n\u003c/ul\u003e","title":"MySQL基本操作"},{"content":"这篇文章将介绍图论中的拓扑排序。\n什么是拓扑排序？ 对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。\n拓扑排序  入度：指向v的边的个数叫做v的入度。 出度：v指向的点的个数叫做v的出度。  如果一个点的入度是0，那么说明这个点是起点（起点不止一个）。如果一个点的出度为0，那么说明这个点排在最后。\n举例说明：\n如图所示，这是一个有向无环图，其指向顺序为a,(b,c),d,e,则abcde和acbde都是这个图的拓扑排序。\n很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。\n拓扑排序的实现 DFS和BFS都可以实现拓扑排序。\nBFS实现拓扑排序 这种算法也叫做Kahn算法\n继续使用上面的例子进行说明\nBFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。\n无前驱的顶点优先就是顺着找，a的入度为0，则其为起点，a入队；\na出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；\n目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；\nb出队，b指向d，d入度减一，d入度为零，入队；\nd出队，d指向e，e入度减一，e入度为零，入队；\ne出队，无后续结点，结束。\n由上述过程可得拓扑排序为acbde。\n时间复杂度 假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。\n代码实现如下：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int T, n, m, u, v; int deg[N]; int vis[N]; int dest[N]; vector\u0026lt;int\u0026gt; g[N]; queue\u0026lt;int\u0026gt; q; bool toposort() { //将入度为零的点放入队列  for (int i = 1; i \u0026lt;= n; i++) { if (!deg[i]) { vis[i] = 1; q.push(i); } } int num = 0; while (!q.empty()) { int now = q.front(); q.pop(); dest[num++] = now; for (auto to : g[now]) { if (vis[to]) //判断该节点是否在队列中  continue; else { deg[to]--; //入度减一  if (!deg[to]) { //判断入度是否为零  q.push(to); //入队  vis[to] = 1; //标记其在队列中  } } } } if (num == n) return true; else return false; } int main(int argc, char const *argv[]) { memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); memset(dest, 0, sizeof(dest)); for (int i = 1; i \u0026lt;= N; i++) g[i].clear(); while (!q.empty()) q.pop(); //以上为初始化  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); //读入  g[u].push_back(v); deg[v]++; //统计入度  } if (toposort()) {//如果可以生成拓扑排序  for (int i = 0; i \u0026lt; n; i++) //输出结果  printf(\u0026#34;%d%c\u0026#34;, dest[i], i == n ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } else printf(\u0026#34;NO\\n\u0026#34;); return 0; } //测试数据 //有向有环图 2 1 1 3 3 4 4 2 //有向无环图 1 2 1 3 3 4 2 4 4 5 DFS实现拓扑排序 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int n, u, v; int c[N]; // 标志数组 vector\u0026lt;int\u0026gt; G[N]; // vector 实现的邻接表 vector\u0026lt;int\u0026gt; topo; // 拓扑排序后的节点  bool dfs(int u) { c[u] = -1; for (int v : G[u]) { if (c[v] \u0026lt; 0) return false; else if (!c[v]) if (!dfs(v)) return false; } c[u] = 1; topo.push_back(u); return true; } bool toposort() { topo.clear(); memset(c, 0, sizeof(c)); for (int u = 0; u \u0026lt; n; u++) if (!c[u]) if (!dfs(u)) return false; reverse(topo.begin(), topo.end()); return true; } int main(int argc, char const *argv[]) { return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","summary":"\u003cp\u003e这篇文章将介绍图论中的拓扑排序。\u003c/p\u003e","title":"拓扑排序"},{"content":"C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\n存储 高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出\n头文件及全局变量 #include \u0026lt;bits/stdc++.h\u0026gt;static const int LEN = 1004; int a[LEN], b[LEN], c[LEN], d[LEN]; int flag; 清空 void clean(int temp[]) { for (int i = 0; i \u0026lt; LEN; ++i) temp[i] = 0; } 存储 void read(int temp[]) { static char s[LEN + 1]; scanf(\u0026#34;%s\u0026#34;, s); clean(temp); int len = strlen(s); for (int i = 0; i \u0026lt; len; ++i) { temp[len - 1 - i] = s[i] - \u0026#39;0\u0026#39;; } } 输出 void print(int a[]) { int i; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (; i \u0026gt;= 0; i--) putchar(a[i] + \u0026#39;0\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } 这样就完成了对于数据的存储与输出\n加法 高精度加法其实就是按照竖式加法法则来计算\n从低位开始相加，满十则向高一位进一，本位取余\n{% note info, 这里使用十进制，也可以使用其他更大的进制，如1000进制 %}\n//高精度加法 void add(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] = a[i] + b[i]; if (c[i] \u0026gt; 9) {//判断是否满十  c[i] -= 10; c[i + 1] += 1; } } } 减法 高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。\n因为要考虑到小数减大数的情况，所以用此函数来判断\nbool compare(int a[], int b[]) { int i, j; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (j = LEN - 1; j \u0026gt;= 1; --j) if (b[j] != 0) break; if (i \u0026gt; j) { return 0; } else if (i \u0026lt; j) { return 1; } else { for (int p = i; p \u0026gt;= 0; --p) { if (a[p] == b[p]) continue; if (a[p] \u0026gt; b[p]) return 0; else return 1; } } return 0; } //高精度减法 void sub(int* a, int* b, int* c) { flag = compare(a, b);//判断是否是小数减大数  if (flag) {//如果是  putchar(\u0026#39;-\u0026#39;);//则输出负号  sub(b, a, c);//按照大数减小数计算  flag = 0; return; } clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] += a[i] - b[i]; if (c[i] \u0026lt; 0) { c[i] += 10; c[i + 1] -= 1; } } } 乘法 高精度*低精度 如果是高精度与低精度相乘的话，就没必要使用高精度乘法\nvoid mul(int a[], int b, int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; ++i) { c[i] += a[i] * b;//每位都乘低精度  if (c[i] \u0026gt; 9) { c[i + 1] += c[i] / 10; c[i] %= 10; } } } 高精度*高精度 高精度与高精度相乘也是模拟了手写计算乘法的方式\n//高精度乘法 void mul(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和  for (int j = 0; j \u0026lt;= i; j++) { c[i] += a[j] * b[i - j]; } if (c[i] \u0026gt; 9) { c[i + 1] = c[i] / 10; c[i] %= 10; } } } 除法 //判断长度 inline bool greater_eq(int a[], int b[], int last_dg, int len) { if (a[last_dg + len] != 0) return true; for (int i = len - 1; i \u0026gt;= 0; --i) { if (a[last_dg + i] \u0026gt; b[i]) return true; if (a[last_dg + i] \u0026lt; b[i]) return false; } return true; } //高精度除法 void div(int a[], int b[], int c[], int d[]) { clean(c); clean(d); int la, lb; for (la = LEN - 1; la \u0026gt; 0; --la) if (a[la - 1] != 0) break; for (lb = LEN - 1; lb \u0026gt; 0; --lb) if (b[lb - 1] != 0) break; if (lb == 0) { puts(\u0026#34;除数为零，错误\u0026#34;); return; } for (int i = 0; i \u0026lt; la; ++i) d[i] = a[i]; for (int i = la - lb; i \u0026gt;= 0; --i) { while (greater_eq(d, b, i, lb)) { for (int j = 0; j \u0026lt; lb; ++j) { d[i + j] -= b[j]; if (d[i + j] \u0026lt; 0) { d[i + j + 1] -= 1; d[i + j] += 10; } } c[i] += 1; } } } 测试 int main() { flag = 0; read(a); read(b); add(a, b, c); print(c); sub(a, b, c); print(c); mul(a, b, c); print(c); div(a, b, c, d); print(c); print(d); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/","summary":"\u003cp\u003eC/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\u003c/p\u003e","title":"高精度计算"},{"content":"并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。\n并发和并行 并发：同一时间段内执行多个任务。\n并行：同一时刻执行多个任务。\nGo语言的并发通过goroutine实现。goroutine类似于进程，属于用户态的进程。可以根据需要创建成千上万个goroutine并发工作。goroutine是由Go语言的运行时调度完成，而线程是由操作系统调度完成。\nGo语言还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言并成的CSP并发模式的重要实现基础。\ngoroutine Go语言中goroutine的概念类似于线程但 goroutine是由Go的运行时（runtime）调度和管理的。\ngoroutine的使用 Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加go关键字，就可以为一个函数创建一个goroutine。\n一个gotoutine必定对应一个函数，可以创建的多个goroutine去执行相同的函数。\n启动单个goroutine 例如：\npackage main import \u0026#34;fmt\u0026#34; func hello() { fmt.Println(\u0026#34;Hello goroutine!\u0026#34;) } func main() { hello() fmt.Println(\u0026#34;main goroutine done!\u0026#34;) } 这个例子的输出结果是Hello goroutine! 和main goroutine done!。\npackage main import \u0026#34;fmt\u0026#34; func hello() { fmt.Println(\u0026#34;Hello goroutine!\u0026#34;) } func main() { go hello() fmt.Println(\u0026#34;main goroutine done!\u0026#34;) } 这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了main goroutine done!，这是为什么呢？\n在程序启动时，Go程序为main()函数创建一个默认的goroutine，当main()函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，hello()还没来得及进行，程序就结束了。\n如何才能将hello()进行呢？最简单粗暴的方式就是time.Sleep。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello() { fmt.Println(\u0026#34;Hello goroutine!\u0026#34;) } func main() { go hello() fmt.Println(\u0026#34;main goroutine done!\u0026#34;) time.Sleep(1000) } 执行上面的代码会发现，这一次先打印main goroutine done!，然后紧接着打印Hello Goroutine!，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。\n启动多个goroutine 例子：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func hello(i int) { defer wg.Done() //goroutine结束也要登记,-1 \tfmt.Println(\u0026#34;Hello goroutine\u0026#34;, i) } func main() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1) //启动一个goroutine就登记一次,+1 \tgo hello(i) } wg.Wait() //等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。\ngoroutine与线程 goroutine调度 GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。\nGOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。\nGo语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。\nGo1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。\n我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func a() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026#34;A:\u0026#34;, i) } } func b() { for i := 1; i \u0026lt; 10; i++ { fmt.Println(\u0026#34;B:\u0026#34;, i) } } func main() { runtime.GOMAXPROCS(1) go a() go b() time.Sleep(time.Second) } 两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。\nGo语言中的操作系统线程和goroutine的关系：\n 一个操作系统线程对应用户态多个goroutine。 go程序可以同时使用多个操作系统线程。 goroutine和OS线程是多对多的关系，即m:n。  channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\nchannel类型 channel是一种类型，一种引用类型。声明格式如下：\nvar 变量 chan 元素类型 例如：\nvar ch1 chan int var ch2 chan bool var ch3 chan []int 创建channel 通道是引用类型，通道类型的空值是nil。\nvar ch chan int fmt.Println(ch) //nil 声明的通道在make初始化后才能使用。\n格式如下：\nmake(chan 元素类型, [大小]) 例如：\nch1 := make(chan int) ch2 := make(chan bool) ch3 := make(chan []int) channel操作 通道有发送（send）、接收(receive）和关闭（close）三种操作。\n发送和接收都使用\u0026lt;-符号。\n现在我们先使用以下语句定义一个通道：\nch := make(chan int) 发送 将一个值发送到通道中。\nch \u0026lt;- 10 // 把10发送到ch中 接收 从一个通道中接收值。\nx := \u0026lt;- ch // 从ch中接收值并赋值给变量x \u0026lt;-ch // 从ch中接收值，忽略结果 关闭 我们通过调用内置的close函数来关闭通道。\nclose(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n关闭后的通道有以下特点：\n 对一个关闭的通道再发送值就会导致panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致panic。  无缓冲的通道 无缓冲的通道又称为阻塞的通道。例如：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { ch := make(chan int) ch \u0026lt;- 10 fmt.Println(\u0026#34;成功\u0026#34;) } 这段代码在执行时会出现错误\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5f exit status 2 因为ch := make(chan int)创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。\n上面的代码会阻塞在ch \u0026lt;- 10这一行代码形成死锁。\n解决方法：\n一种方法就是启用一个goroutine去接受，例如：\npackage main import ( \u0026#34;fmt\u0026#34; ) func rec(c chan int) { ret := \u0026lt;-c fmt.Println(\u0026#34;成功\u0026#34;, ret) } func main() { ch := make(chan int) go rec(ch) ch \u0026lt;- 10 fmt.Println(\u0026#34;成功\u0026#34;) } 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。\n使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。\n有缓冲的通道 解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：\nfunc main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 \tch \u0026lt;- 10 fmt.Println(\u0026#34;发送成功\u0026#34;) } 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量。\nfor range 从通道循环取值 当向通道中发送完数据时，我们可以通过close函数来关闭通道。\n当通道被关闭时，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？\n看这个例子：\npackage main import \u0026#34;fmt\u0026#34; func main() { ch1 := make(chan int) ch2 := make(chan int) // 开启goroutine将0~100的数发送到ch1中 \tgo func() { for i := 0; i \u0026lt; 100; i++ { ch1 \u0026lt;- i } close(ch1) }() // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中 \tgo func() { for { i, ok := \u0026lt;-ch1 // 通道关闭后再取值ok=false \tif !ok { break } ch2 \u0026lt;- i * i } close(ch2) }() // 在主goroutine中从ch2中接收值打印 \tfor i := range ch2 { // 通道关闭后会退出for range循环 \tfmt.Println(i) } } 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是for range的方式。使用for range遍历通道，当通道被关闭的时候就会退出for range。\n单向通道 有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。\nGo语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下：\nfunc counter(out chan\u0026lt;- int) { for i := 0; i \u0026lt; 100; i++ { out \u0026lt;- i } close(out) } func squarer(out chan\u0026lt;- int, in \u0026lt;-chan int) { for i := range in { out \u0026lt;- i * i } close(out) } func printer(in \u0026lt;-chan int) { for i := range in { fmt.Println(i) } } func main() { ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2) } 其中，\n chan\u0026lt;- int是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作； \u0026lt;-chan int是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。  在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。\nworker pool （goroutine池） 在工作中我们通常会使用可以指定启动的goroutine数量–worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。\n例如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func worker(id int, jobs \u0026lt;-chan int, results chan\u0026lt;- int) { for i := range jobs { fmt.Printf(\u0026#34;worker:%d start job:%d\\n\u0026#34;, id, i) time.Sleep(time.Second) fmt.Printf(\u0026#34;worker:%d end job:%d\\n\u0026#34;, id, i) results \u0026lt;- i * 2 } } func main() { jobs := make(chan int, 100) results := make(chan int, 100) //只开启3个goroutine \tfor w := 1; w \u0026lt;= 3; w++ { go worker(w, jobs, results) } //5个任务 \tfor j := 1; j \u0026lt;= 5; j++ { jobs \u0026lt;- j } close(jobs) for a := 1; a \u0026lt;= 5; a++ { \u0026lt;-results } } select多路复用 在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：\nfor{ // 尝试从ch1接收值  data, ok := \u0026lt;-ch1 // 尝试从ch2接收值  data, ok := \u0026lt;-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。\nselect的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下：\nselect{ case \u0026lt;-ch1: ... case data := \u0026lt;-ch2: ... case ch3\u0026lt;-data: ... default: 默认操作 } 举个例子来演示下select的使用：\nfunc main() { ch := make(chan int, 1) for i := 0; i \u0026lt; 10; i++ { select { case x := \u0026lt;-ch: fmt.Println(x) case ch \u0026lt;- i: } } } 使用select语句能提高代码的可读性。\n 可处理一个或多个channel的发送/接收操作。 如果多个case同时满足，select会随机选择一个。 对于没有case的select{}会一直等待，可用于阻塞main函数。  并发安全和锁 有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。\n举个例子：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x int64 var wg sync.WaitGroup func add() { for i := 0; i \u0026lt; 50000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 上面的代码中我们开启了两个goroutine去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。\n互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x int64 var wg sync.WaitGroup var lock sync.Mutex func add() { for i := 0; i \u0026lt; 50000; i++ { lock.Lock() //上锁 \tx = x + 1 lock.Unlock() //解锁 \t} wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区，其他的goroutine则在等待锁；当互斥锁释放后，等待的goroutine才可以获取锁进入临界区，多个goroutine同时等待一个锁时，唤醒的策略是随机的。\n读写互斥锁 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。\n读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。\n读写锁示例：\nvar ( x int64 wg sync.WaitGroup //lock sync.Mutex \trwlock sync.RWMutex ) func write() { // lock.Lock() // 加互斥锁 \trwlock.Lock() // 加写锁 \tx = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 \trwlock.Unlock() // 解写锁 \t// lock.Unlock() // 解互斥锁 \twg.Done() } func read() { // lock.Lock() // 加互斥锁 \trwlock.RLock() // 加读锁 \ttime.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 \trwlock.RUnlock() // 解读锁 \t// lock.Unlock() // 解互斥锁 \twg.Done() } func main() { start := time.Now() for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go write() } for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go read() } wg.Wait() end := time.Now() fmt.Println(end.Sub(start)) } 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。\nsync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：\n   方法名 功能     (wg * WaitGroup) Add(delta int) 计数器+delta   (wg *WaitGroup) Done() 计数器-1   (wg *WaitGroup) Wait() 阻塞直到计数器变为0    sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。\n我们利用sync.WaitGroup将上面的代码优化一下：\nvar wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\u0026#34;Hello Goroutine!\u0026#34;) } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 \tfmt.Println(\u0026#34;main goroutine done!\u0026#34;) wg.Wait() } 需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。\nsync.Once 说在前面的话：这是一个进阶知识点。\n在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案–sync.Once。\nsync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) {} 备注：如果要执行的函数f需要传递参数就需要搭配闭包来使用。\n加载配置文件示例 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\nvar icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \u0026#34;left\u0026#34;: loadIcon(\u0026#34;left.png\u0026#34;), \u0026#34;up\u0026#34;: loadIcon(\u0026#34;up.png\u0026#34;), \u0026#34;right\u0026#34;: loadIcon(\u0026#34;right.png\u0026#34;), \u0026#34;down\u0026#34;: loadIcon(\u0026#34;down.png\u0026#34;), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个goroutine并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\nfunc loadIcons() { icons = make(map[string]image.Image) icons[\u0026#34;left\u0026#34;] = loadIcon(\u0026#34;left.png\u0026#34;) icons[\u0026#34;up\u0026#34;] = loadIcon(\u0026#34;up.png\u0026#34;) icons[\u0026#34;right\u0026#34;] = loadIcon(\u0026#34;right.png\u0026#34;) icons[\u0026#34;down\u0026#34;] = loadIcon(\u0026#34;down.png\u0026#34;) } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的goroutine操作，但是这样做又会引发性能问题。\n使用sync.Once改造的示例代码如下：\nvar icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \u0026#34;left\u0026#34;: loadIcon(\u0026#34;left.png\u0026#34;), \u0026#34;up\u0026#34;: loadIcon(\u0026#34;up.png\u0026#34;), \u0026#34;right\u0026#34;: loadIcon(\u0026#34;right.png\u0026#34;), \u0026#34;down\u0026#34;: loadIcon(\u0026#34;down.png\u0026#34;), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 并发安全的单例模式 下面是借助sync.Once实现的并发安全的单例模式：\npackage singleton import ( \u0026#34;sync\u0026#34; ) type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\nsync.Map Go语言中内置的map不是并发安全的。请看下面的示例：\nvar m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\u0026#34;k=:%v,v:=%v\\n\u0026#34;, key, get(key)) wg.Done() }(i) } wg.Wait() } 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了之后执行上面的代码就会报fatal error: concurrent map writes错误。\n像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。\nvar m = sync.Map{} func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) value, _ := m.Load(key) fmt.Printf(\u0026#34;k=:%v,v:=%v\\n\u0026#34;, key, value) wg.Done() }(i) } wg.Wait() } 原子操作 代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库sync/atomic提供。\n示例 我们填写一个示例来比较下互斥锁和原子操作的性能。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(\u0026amp;a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(\u0026amp;a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { c.Inc() wg.Done() }() } wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start)) } func main() { c1 := CommonCounter{} // 非并发安全 \ttest(c1) c2 := MutexCounter{} // 使用互斥锁实现并发安全 \ttest(\u0026amp;c2) c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高 \ttest(\u0026amp;c3) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/","summary":"\u003cp\u003e并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。\u003c/p\u003e","title":"Go语言基础之并发"},{"content":"接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\n接口类型 在Go语言中接口（interface）是一种类型，一种抽象的类型。\ninterface是一组method的集合，不关心属性（数据），只关心行为（方法）。\n引入 package main import \u0026#34;fmt\u0026#34; type Cat struct{} //猫 func (c Cat) Say() string { return \u0026#34;喵喵喵\u0026#34; } type Dog struct{} //狗 func (d Dog) Say() string { return \u0026#34;汪汪汪\u0026#34; } func main() { c := Cat{} fmt.Println(c.Say()) d := Dog{} fmt.Println(d.Say()) } 上述代码定义了猫和狗，以及他们叫声的方法，可以发现，main中会有重复的代码，如果再加上其他动物，代码还会重复，那如果把他们都归类成“会叫的动物”来处理呢？\n像这样类似的例子还有很多，例如：\n支付宝、微信、银联等在线支付的方式，可以把它们当成支付方式来处理。\n计算三角形、正方形、圆形等的周长和面积，可以把他们当成图形来处理\n等等……\n而在Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于所有的具体类型，接口是一种抽象的类型。当看到一个接口类型的值时，你不知道它是什么，只知道通过它的方法能做什么。\n接口的定义 Go语言提倡面向接口编程\n每个接口由数个方法组成，格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … }  接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。  例如：\ntype writer interface{ Write([]byte) error } 当你看到这个接口类型的值时，并不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。\n接口实现的条件 一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个{% emp 需要实现的方法列表 %}\n例如：\ntype Sayer interface { Say() } type Cat struct{} func (c Cat) Say() { //Cat实现了Sayer接口  fmt.Println(\u0026#34;喵喵喵\u0026#34;) } type Dog struct{} func (d Dog) Say() { //Dog实现了Sayer接口  fmt.Println(\u0026#34;汪汪汪\u0026#34;) } 接口类型的变量 实现了接口有什么作用呢？\n接口类型变量能够储存所有实现了该接口的实例。\n例如：\nfunc main() { var x Sayer c := Cat{} d := Dog{} x = c x.Say() x = d x.Say() } 值接收者和指针接收者实现接口的区别 定义一个Mover接口和一个Dog结构体\ntype Mover interface{ move() } type Dog struct{} {% tabs tab-1 %}\nfunc (d Dog) move() { fmt.Println(\u0026#34;狗跑了\u0026#34;) } func main() { var x Mover var wangcai = Dog{} x = wangcai x.move() var fugui = \u0026amp;Dog{} x = fugui x.move() } 从上面这段代码不难发现，使用值接收者实现接口之后，不管是Dog结构体还是*Dog结构体指针类型的变量都可以赋值给该接口变量。\n同样的代码，如果使用指针接受实现接口呢？\nfunc (d *Dog) move() { fmt.Println(\u0026#34;狗跑了\u0026#34;) } func main() { var x Mover var wangcai = Dog{} x = wangcai //x不可以接收Dog类型 \tx.move() var fugui = \u0026amp;Dog{} x = fugui x.move() } 此时实现Mover接口的是*Dog类型，所以不能给x传入Dog类型。\n{% endtabs %}\n类型与接口的关系 一个类型实现多个接口 一个类型可以同时实现多个接口，而接口之间批次独立。例如，狗可以叫，也可以跑。就可以分别定义Sayer接口和Mover接口：\npackage main import \u0026#34;fmt\u0026#34; type Sayer interface { say() } type Mover interface { move() } type Dog struct { name string } func (d Dog) say() { fmt.Printf(\u0026#34;%s说\\n\u0026#34;, d.name) } func (d Dog) move() { fmt.Printf(\u0026#34;%s跑了\\n\u0026#34;, d.name) } func main() { var x Mover var y Sayer var a = Dog{\u0026#34;旺财\u0026#34;} x = a y = a x.move() y.say() } 多个类型实现同一接口 Go语言中不同的类型还可以实现同一接口，例如：\npackage main import \u0026#34;fmt\u0026#34; type Mover interface { move() } type Dog struct { name string } func (d Dog) move() { fmt.Printf(\u0026#34;%s跑了\\n\u0026#34;, d.name) } type Car struct { name string } func (c Car) move() { fmt.Printf(\u0026#34;%s跑了\\n\u0026#34;, c.name) } func main() { var x Mover var d = Dog{\u0026#34;旺财\u0026#34;} var c = Car{\u0026#34;保时捷\u0026#34;} x = d x.move() x = c c.move() //不关心具体是什么，只需调用方法即可 } 接口嵌套 接口与接口之间可以通过嵌套创造出新的接口\n//Sayer接口 type Sayer interface{ say() } //Mover接口 type Mover interface{ move() } //接口嵌套 type animal interface{ Sayer Mover } 嵌套得到的接口的使用与普通接口一样：\ntype Cat struct { name string } func (c Cat) say() { fmt.Println(\u0026#34;喵喵喵\u0026#34;) } func (c Cat) move() { fmt.Println(\u0026#34;猫跑了\u0026#34;) } func main() { var x animal x = Cat{name: \u0026#34;臭宝\u0026#34;} x.move() x.say() } 空接口 空接口的定义 空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。\n空接口类型的变量可以存储任意类型的变量。\npackage main import \u0026#34;fmt\u0026#34; func main() { var x interface{} s := \u0026#34;Hello\u0026#34; x = s fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, x, x) i := 100 x = i fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, x, x) b := true x = b fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, x, x) } 空接口的应用 {% tabs tab-2 %}\n使用空接口实现可以接受任意类型的函数参数\nfunc show(a interface{}) { fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, a, a) } 使用空接口实现可以保存任意值的字典。\npackage main import \u0026#34;fmt\u0026#34; func main() { var studentInfo = make(map[string]interface{}) studentInfo[\u0026#34;name\u0026#34;] = \u0026#34;臭宝\u0026#34; studentInfo[\u0026#34;age\u0026#34;] = 18 studentInfo[\u0026#34;married\u0026#34;] = false fmt.Println(studentInfo) //map[age:18 married:false name:臭宝] } {% endtabs %}\n类型断言","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/","summary":"\u003cp\u003e接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\u003c/p\u003e","title":"Go语言基础之接口"},{"content":"在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。\n构造函数 在C++面向对象中，声明一个对象后，可以写一些针对该对象的一些方法，例如构造函数等。Go语言中的结构体没有构造函数，可以自己实现。\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } //构造函数 func Student(name string, age int, id string, score int) *student { return \u0026amp;student{ //struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型 \tname, age, id, score, } } func main() { s := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) //\u0026amp;main.student{name:\u0026#34;小学生\u0026#34;, age:7, id:\u0026#34;666\u0026#34;, score:60} } 方法和接收者 Go语言中的方法(Method)是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者(Receiver)。接收者的概念类似于C++中的this。\n定义格式如下：\nfunc (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 }  接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是this之类的命名。例如，student类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。  例如：\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } //构造函数 func Student(name string, age int, id string, score int) *student { return \u0026amp;student{ //struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型 \tname, age, id, score, } } func (s student) study() { fmt.Printf(\u0026#34;我要好好学习！\\n\u0026#34;) } func main() { p := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) p.study() } 方法和函数的区别就是函数不属于任何类型，方法只属于特定的类型\n{% tabs tab-1 %}\n指针类型的接收者由一个结构的指针组成，由于指针的特性，调用方法时可以修改接收者指针的任何成员变量，在方法结束后，修改依然有效。这种方法类似于C++中使用this。\n例如：\nfunc (s *student) setAge(age int) { s.age = age } 这是一个修改student的age 的方法\n调用：\nfunc main() { p := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) fmt.Println(p.age) //7 \tp.setAge(18) fmt.Println(p.age) //18 } 与指针类型的接收者对比，调用方法时，拿到的是值类型接收者的值的拷贝份。在值类型接收者的方法中可以获取接收者的成员值，但修改成员变量指针对这个副本，无法修改接收者变量本身。\n例如：\nfunc (s student) setAge(age int) { s.age = age } func main() { p := Student(\u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60) fmt.Println(p.age) //7 \tp.setAge(18) fmt.Println(p.age) //7 }  需要修改接收者的成员值 接收者是比较复杂的结构体，拷贝开销大  {% endtabs %}\n任意类型添加方法 Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。例如，基于内置的int类型使用type关键字可以定义新的自定义类型，然后为这个自定义类型添加方法。\npackage main import \u0026#34;fmt\u0026#34; type MyInt int func (m MyInt) SayHello() { fmt.Println(\u0026#34;Hello, I\u0026#39;m SatHello\u0026#34;) //Hello, I\u0026#39;m SatHello } func main() { var m MyInt m.SayHello() m = 100 fmt.Printf(\u0026#34;%#v %T\\n\u0026#34;, m, m) //100 main.MyInt } 注意：只可以给本包的类型定义方法\n结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段称为匿名字段。\npackage main import \u0026#34;fmt\u0026#34; type student struct { string int } func main() { s := \u0026amp;student{ \u0026#34;小学生\u0026#34;, 7, } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) //\u0026amp;main.student{string:\u0026#34;小学生\u0026#34;, int:7} } 匿名字段的说法并不代表没有字段名，而是默认采用类型名作为字段名。从其定义中不难发现，\n由于结构体要求字段名必须唯一，因此一个结构体中一种类型的匿名字段只能有一个。\n嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针，例如：\npackage main import \u0026#34;fmt\u0026#34; //成绩信息 type grade struct { math int chinese int english int } //学生信息 type student struct { name string age int mygrade grade //grade  //↑可采用匿名字段的方式嵌套 } func main() { s := \u0026amp;student{ name: \u0026#34;小学生\u0026#34;, age: 7, mygrade: grade{ math: 60, chinese: 60, english: 60, }, } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, s) //\u0026amp;main.student{name:\u0026#34;小学生\u0026#34;, age:7, mygrade:main.grade{math:60, chinese:60, english:60}} } 结构体的“继承” Go语言中使用结构体也可以实现C++中面向对象的继承。\npackage main import \u0026#34;fmt\u0026#34; type Animal struct { name string } func (a Animal) move() { fmt.Printf(\u0026#34;%s会动\\n\u0026#34;, a.name) } type Dog struct { age int *Animal //通过嵌套匿名结构体实现继承 } func (d *Dog) wang() { fmt.Printf(\u0026#34;%s汪汪汪的叫\\n\u0026#34;, d.name) } func main() { d := \u0026amp;Dog{ age: 4, Animal: \u0026amp;Animal{ name: \u0026#34;小明\u0026#34;, }, } d.move() d.wang() } 结构体字段的可见性 结构体中字段大写开头表示可公开访问，小写代表私有（仅在定义当前结构体的包中可访问）\n{% note warning, 区别私有概念 %}\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/","summary":"\u003cp\u003e在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。\u003c/p\u003e","title":"Go语言基础之结构体（二）"},{"content":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\n自定义类型和类型别名 {% tabs tab-1 %}\n在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以像C/C++一样使用type关键字来定义自定义类型。\n自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：\n//将MyInt定义为int类型 type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性\n类型别名规定：MyType只是Type的别名，本质上MyType与Type是同一个类型。\ntype MyType = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下：\ntype byte = uint8 type rune = int32 自定义类型和类型别名在语法上看似只有一个等号的差别，但其实不然，例如：\n//自定义类型 type NewInt int //类型别名 type MyInt = int func main(){ var a NewInt var b MyInt fmt.Printf(\u0026#34;%T\\n\u0026#34;, a) //main.NewInt  fmt.Printf(\u0026#34;%T\u0026#34;, b) //int } 输出结果显示a的类型是main.NewInt，表示main包下定义的``NewInt类型；b的类型是int`。\nMyInt类型在编译完成时，会被替换成int\n{% endtabs %}\n结构体 Go语言中结构体的定义与C/C++中类似。\n我们想表达一个事物的全部或部分属性时，这时用单一的基本数据类型无法满足需求，Go语言提供了自定义数据类型，可以封装多个基本数据类型，这就是结构体。\n通过struct来定义，同时在Go语言中，也通过struct实现面向对象\n结构体的定义 使用type和struct关键字来定义结构体，如下：\ntype MyType struct { Name1 Type1 Name2 Type2 ... }  MyType：自定义类型的名称，同一个包中不可重复 Name1和Name2：结构体中成员名称，同一结构体中不可重复 Type1和Type2：成员的具体类型  例如，定义一个学生的结构体：\ntype student struct { name string age int id string score int } 这样，使用student结构体就可以很方便在代码中表示和储存信息了\nGo语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型\n结构体实例化 只有结构体实例化后，才会对相应的变量分配内存。结构体实例化与声明内置类型一样，使用var关键字声明变量\nvar student1 student {% tabs tab-2 %}\n通过.访问结构体的成员\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { var stu student //声明结构体变量  //赋值 \tstu.name = \u0026#34;小学生\u0026#34; stu.age = 7 stu.id = \u0026#34;666\u0026#34; stu.score = 60 fmt.Println(stu) } 输出结果：\n{小学生 7 666 60} 在定义一些临时数据结构等场景下，可以使命匿名结构体\npackage main import \u0026#34;fmt\u0026#34; func main() { var user struct { Name string Age int } user.Name = \u0026#34;小学生\u0026#34; user.Age = 7 fmt.Println(user) } 输出结果：\n{小学生 7} Go语言中还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址：\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { var s = new(student) fmt.Printf(\u0026#34;%T\\n\u0026#34;, s) fmt.Println(s) s.name = \u0026#34;小学生\u0026#34; //Go语言中支持对结构体指针直接使用.来访问结构体成员 \ts.age = 7 s.id = \u0026#34;666\u0026#34; s.score = 60 fmt.Println(s) } 输出结果：\n*main.student \u0026amp;{ 0 0} \u0026amp;{小学生 7 666 60} 使用\u0026amp;对结构体进行取址操作相当于对该结构体进行了依次new实例化操作\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { s := \u0026amp;student{} fmt.Printf(\u0026#34;%T\\n\u0026#34;, s) fmt.Println(s) s.name = \u0026#34;小学生\u0026#34; s.age = 7 s.id = \u0026#34;666\u0026#34; s.score = 60 fmt.Println(s) } 输出结果：\n*main.student \u0026amp;{ 0 0} \u0026amp;{小学生 7 666 60} {% endtabs %}\n结构体初始化 没有初始化的结构体，其成员变量都是对应类型的零值\npackage main import \u0026#34;fmt\u0026#34; type student struct { name string age int id string score int } func main() { var stu student fmt.Printf(\u0026#34;%#v\\n\u0026#34;, stu) } 输出结果：\nmain.student{name:\u0026#34;\u0026#34;, age:0, id:\u0026#34;\u0026#34;, score:0} {% tabs tab-3 %}\n使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值\nstu := student{ name: \u0026#34;小学生\u0026#34;, age: 7, id: \u0026#34;666\u0026#34;, score: 60, } fmt.Println(stu)//{小学生 7 666 60} 也可以对结构体指针进行键值对初始化：\nstu := student{ name: \u0026#34;小学生\u0026#34;, age: 7, id: \u0026#34;666\u0026#34;, score: 60, } fmt.Println(stu)//\u0026amp;{小学生 7 666 60} 当某些字段没有初始值时，该字段可以不写。此时，没有指定初始值的字段的值时该字段类型的零值\nstu := student{ name: \u0026#34;小学生\u0026#34;, score: 60, } fmt.Printf(\u0026#34;%#v\u0026#34;, stu)//main.student{name:\u0026#34;小学生\u0026#34;, age:0, id:\u0026#34;\u0026#34;, score:60} 初始话结构体时可以简写，也就是初始化时不写键，直接写值即可：\nstu := student{ \u0026#34;小学生\u0026#34;, 7, \u0026#34;666\u0026#34;, 60, } fmt.Println(stu)//{小学生 7 666 60} 使用这种格式要注意：\n 必须初始化结构体的所有字段 顺序必须一致 不可与简直初始化混用  {% endtabs %}\n结构体内存布局 结构体占用一块连续的内存\npackage main import \u0026#34;fmt\u0026#34; type test struct { a int8 b int8 c int8 d int8 } func main() { n := test{ 1, 2, 3, 4, } fmt.Printf(\u0026#34;n.a %p\\n\u0026#34;, \u0026amp;n.a) fmt.Printf(\u0026#34;n.b %p\\n\u0026#34;, \u0026amp;n.b) fmt.Printf(\u0026#34;n.c %p\\n\u0026#34;, \u0026amp;n.c) fmt.Printf(\u0026#34;n.d %p\\n\u0026#34;, \u0026amp;n.d) } 输出结果：\nn.a 0xc000012090 n.b 0xc000012091 n.c 0xc000012092 n.d 0xc000012093 空结构体 空结构体不占用空间\nvar t struct{} fmt.Println(unsafe.Sizeof(t)) // 0 ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80/","summary":"\u003cp\u003eGo语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\u003c/p\u003e","title":"Go语言基础之结构体（一）"},{"content":"任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\nGo语言中的指针 Go语言中的指针与C/C++中指针有一定的区别，Go语言中的指针不能进行偏移和运算，是安全指针。因此，Go语言中的指针操作比较简单，只需要记住两个符号\u0026amp;（取址）和*（取值）\n指针地址和指针类型 每个变量在运行都有一个地址，这个地址也就代表变量在内存中的位置。Go语言中使用\u0026amp;对变量进行取地址。例如：\na := 10 //定义整型变量a p := \u0026amp;10//p为整型类型的指针类型，其中保存的是变量a的地址 在Go语言中，每个值类型都有对应的指针类型。\n指针取值 在对变量使用\u0026amp;取地址后，可以使用*对接收了地址的指针变量进行取值，有一个很简单的例子：\npackage main import \u0026#34;fmt\u0026#34; func main() { a := 10 b := \u0026amp;a fmt.Println(*b) } {% folding green, 输出结果 %}\n10 {% endfolding %}\n指针传值示例 package main import \u0026#34;fmt\u0026#34; func myfunc(x *int) { *x = 20 } func main() { a := 10 myfunc(\u0026amp;a) fmt.Println(a) } {% folding blue, 输出结果 %}\n20\r{% endfolding %}\nnew \u0026amp; make 先分析一个经典的例子\nfunc main() { var a *int *a = 100 fmt.Println(*a) var b map[string]int b[\u0026#34;哈哈哈\u0026#34;] = 100 fmt.Println(b) } 执行这段代码，其实是会报错的。\n 在声明了整型的指针类型a之后，系统并没有给变量分配内存空间 在声明了map类型的b之后，同样，系统并没有给其分配内存空间  Go语言中对于值类型的声明，在声明的时候就默认分配了内存空间。然而对于引用类型，在使用的时候不仅要声明它，还要给它分配内存空间，否则无法储存。\n所以就要使用Go语言中new和make来分配内存\nnew new是一个内置的函数，语法如下：\nname := new(Type) //name 变量名 //Type 指针变量指向的变量的类型 举例说明：\npackage main import \u0026#34;fmt\u0026#34; func main() { a := new(int) b := new(bool) //使用new函数后得到的是一个指针变量，且该指针对应的值为该类型的零值 \tfmt.Println(*a) fmt.Println(*b) } 在上述开始的经典例子中，var a *int只是声明了指针变量a，但是并未初始化，指针作为引用类型需要初始化才会有内存空间，才可对其进行赋值。\nfunc main(){ var a *int a = new(int) *a = 100 fmt.Println(*a) } make make也用于内存分配，区别于new，只用于slice(切片)，map以及chan(通道)的内存创建，而不是他们的指针类型，因为这三种类型本来就是引用类型。\n语法如下：\nb := make(map[Type1]Type2, Size) make函数是无可替代的，在使用slice，map以及chan时，都需要使用make初始化。\n在上述开始的经典例子中，var b map[string]int只是声明了b是一个map类型的变量，并未初始化。\nfunc main(){ var b map[string]int b = make(map[string]int, 10) b[\u0026#34;哈哈哈\u0026#34;] = 10 fmt.Println(b) } new和make的异同  new和make都是用来做内存分配的 make只用于slice，map，channel的初始化 new用于指针类型的分配，而且内存对应的值为类型零值 ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/","summary":"\u003cp\u003e任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\u003c/p\u003e","title":"Go语言基础之指针"},{"content":"函数是基本的代码块，用于执行一个任务。\nGo 语言至少要有个 main() 函数。\n本文将介绍Go语言中函数的相关内容。\n函数 Go语言中支持函数、匿名函数、闭包。\n函数定义 Go语言中定义函数使用关键字func，如下：\nfunc 函数名(参数1,参数2)(返回值1,返回值2){ 函数体 }  函数名：命名规则与变量相同 参数：参数由参数变量和参数变量类型组成 返回值：返回值由返回值变量和返回值类型组成，也可以只写返回值的类型。Go语言支持多个返回值，须用()包裹。  具体用以下例子说明：\n{% tabs tab-1 %}\nfunc mysum(x int, y int) int { return x + y } func myhello(){ fmt.Println(\u0026#34;Hello Boy!\u0026#34;) } {% endtabs %}\n函数调用 在定义了函数之后，可以通过函数名()的方式对函数进行调用。\n例如调用上述定义的两个函数，代码如下：\nfunc main(){ myhello(); ret := mysum(1, 2) fmt.Println(ret) } 参数 {% tabs tab-2 %}\n函数中的参数如果相邻变量的类型相同，则可以省略类型，只留一个，例如：\nfunc mysum(x, y int) int { return x + y } 可变参数是指函数的参数数量不固定，Go语言中的可变参数通过在参数名后加...来表示。\n{% note warning, 可变参数通常要作为函数的最后一个参数 %}\n例如：\nfunc mysum2(x ...int) int { fmt.Println(x) //x是一个切片  sum :=0 for _, v := range x{ sum = sum + v } return sum } func main(){ ret1 := mysum2() ret2 := mysum2(10) ret3 := mysum3(10, 20, 30) fmt.Println(ret1,ret2,ret3) } {% endtabs %}\n返回值 Go语言中通过关键字return返回\n{% tabs tab-3 %}\nGo语言中函数支持多个返回值，函数如果有多个返回值时，必须用()将返回值括起来\nfunc myfunc(x, y int)(int, int){ sum := x + y sub := x - y return sum,sub } 函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。\n例如：\nfunc myfunc(x, y int) (sum, sub int) { sum = x + y sub = x - y return } 当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。\nfunc myfunc(x string) []int { if x == \u0026#34;\u0026#34; { return nil // 没必要返回[]int{} \t} ... } {% endtabs %}\n函数进阶 函数类型和变量 使用type关键字来定义一个函数类型，格式如下：\ntype mytype func(int, int) int 上面的语句定义了一个mytype类型，一种函数类型，且这种函数接受两个int类型的参数并且返回一个int类型的返回值。简单点来说，凡是满足这个条件的函数都是mytype类型的函数，例如：\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } func main() { type mytype func(int, int) int var c mytype c = add //将函数add赋值给变量c \tfmt.Println(c(1, 2)) // 可以像add一样调用c } 高阶函数 函数作为参数 Go语言中，函数可以作为参数。例如：\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } func myfunc(x, y int, canshu func(int, int) int) int { return canshu(x, y) } func main() { ret1 := myfunc(1, 2, add) fmt.Println(ret1) } 也可以使用定义函数类型\npackage main import \u0026#34;fmt\u0026#34; func add(x, y int) int { return x + y } type mytype func(x, y int) int func myfunc(x, y int, canshu mytype) int { return canshu(x, y) } func main() { ret1 := myfunc(1, 2, add) fmt.Println(ret1) } 函数作为返回值 Go语言中，函数可以作为返回值\n//待补充 匿名函数和闭包 匿名函数 Go语言中函数内部定义函数与之前有所不同，只能定义匿名函数。匿名函数就是没有函数名的函数，格式如下：\nfunc(参数)(返回值){ 函数体 } 匿名函数因为没有函数名，没办法想普通函数一样被调用，所以匿名函数需要保存到某个变量或者立即执行该函数：\nfunc main(){ add :=func(x, y int){//将匿名函数保存到变量中  fmt.Println(x + y) } add(10,20)//通过变量调用匿名函数  //自执行函数，匿名函数定义完加()直接执行  func(x, y int){ fmt.Println(x + y) }(10, 20) } 闭包 闭包指的是一个函数和其相关的引用环境组合而成的实体。简单点说，闭包 = 函数 + 引用环境。例如：\npackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { var x int return func(y int) int { x += y return x } } func main() { var f = adder() fmt.Println(f(10)) //10 \tfmt.Println(f(20)) //30 \tfmt.Println(f(30)) //60  f1 := adder() fmt.Println(f1(40)) //40 \tfmt.Println(f1(50)) //90 } 变量f是一个函数并且它引用了其外部作用域中x变量，此时f是一个闭包。在f的生命周期内，变量x也一直有效。\n闭包进阶示例 {% tabs tab-4 %}\npackage main import \u0026#34;fmt\u0026#34; func adder2(x int) func(int) int { return func(y int) int { x += y return x } } func main() { var f = adder2(10) fmt.Println(f(10)) //20 \tfmt.Println(f(20)) //40 \tfmt.Println(f(30)) //70  f1 := adder2(20) fmt.Println(f1(40)) //60 \tfmt.Println(f1(50)) //110 } package main import \u0026#34;fmt\u0026#34; func myfunc(base int) (func(int) int, func(int) int) { add := func(i int) int { base += i return base } sub := func(i int) int { base -= i return base } return add, sub } func main() { f1, f2 := myfunc(10) fmt.Println(f1(1), f2(2)) //11 9 \tfmt.Println(f1(3), f2(4)) //12 8 \tfmt.Println(f1(5), f2(6)) //13 7 } {% endtabs %}\ndefer语句 Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句最先被执行，和C语言中栈的顺序一样\n例如：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;start\u0026#34;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(\u0026#34;end\u0026#34;) } 运行结果：\nstart end 3 2 1 利用defer语句延迟调用的特性，可以很方便的处理资源释放的问题\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/","summary":"\u003cp\u003e函数是基本的代码块，用于执行一个任务。\u003c/p\u003e\n\u003cp\u003eGo 语言至少要有个 main() 函数。\u003c/p\u003e\n\u003cp\u003e本文将介绍Go语言中函数的相关内容。\u003c/p\u003e","title":"Go语言基础之函数"},{"content":"Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。\nmap map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。\nmap定义 Go语言中 map的定义语法如下：\nmap[KeyType]ValueType 其中，\n KeyType:表示键的类型。 ValueType:表示键对应的值的类型。  map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：\nmake(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。\nmap基本使用 map中的数据都是成对出现的，map的基本使用示例代码如下：\nfunc main() { scoreMap := make(map[string]int, 8) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[\u0026#34;小明\u0026#34;]) fmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, scoreMap) } 输出：\nmap[小明:100 张三:90] 100 type of a:map[string]int map也支持在声明的时候填充元素，例如：\nfunc main() { userInfo := map[string]string{ \u0026#34;username\u0026#34;: \u0026#34;沙河小王子\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;, } fmt.Println(userInfo) // } 判断某个键是否存在 Go语言中有个判断map中键是否存在的特殊写法，格式如下:\nvalue, ok := map[key] 举个例子：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值 \tv, ok := scoreMap[\u0026#34;张三\u0026#34;] if ok { fmt.Println(v) } else { fmt.Println(\u0026#34;查无此人\u0026#34;) } } map的遍历 Go语言中使用for range遍历map。\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 for k, v := range scoreMap { fmt.Println(k, v) } } 但我们只想遍历key的时候，可以按下面的写法：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 for k := range scoreMap { fmt.Println(k) } } 注意： 遍历map时的元素顺序与添加键值对的顺序无关。\n使用delete()函数删除键值对 使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：\ndelete(map, key) 其中，\n map:表示要删除键值对的map key:表示要删除的键值对的键  示例代码如下：\nfunc main(){ scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 delete(scoreMap, \u0026#34;小明\u0026#34;)//将小明:100从map中删除 \tfor k,v := range scoreMap{ fmt.Println(k, v) } } 按照指定顺序遍历map func main() { rand.Seed(time.Now().UnixNano()) //初始化随机数种子  var scoreMap = make(map[string]int, 200) for i := 0; i \u0026lt; 100; i++ { key := fmt.Sprintf(\u0026#34;stu%02d\u0026#34;, i) //生成stu开头的字符串 \tvalue := rand.Intn(100) //生成0~99的随机整数 \tscoreMap[key] = value } //取出map中的所有key存入切片keys \tvar keys = make([]string, 0, 200) for key := range scoreMap { keys = append(keys, key) } //对切片进行排序 \tsort.Strings(keys) //按照排序后的key遍历map \tfor _, key := range keys { fmt.Println(key, scoreMap[key]) } } 元素为map类型的切片 下面的代码演示了切片中的元素为map类型时的操作：\nfunc main() { var mapSlice = make([]map[string]string, 3) for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%v\\n\u0026#34;, index, value) } fmt.Println(\u0026#34;after init\u0026#34;) // 对切片中的map元素进行初始化 \tmapSlice[0] = make(map[string]string, 10) mapSlice[0][\u0026#34;name\u0026#34;] = \u0026#34;小王子\u0026#34; mapSlice[0][\u0026#34;password\u0026#34;] = \u0026#34;123456\u0026#34; mapSlice[0][\u0026#34;address\u0026#34;] = \u0026#34;沙河\u0026#34; for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%v\\n\u0026#34;, index, value) } } 值为切片类型的map 下面的代码演示了map中值为切片类型的操作：\nfunc main() { var sliceMap = make(map[string][]string, 3) fmt.Println(sliceMap) fmt.Println(\u0026#34;after init\u0026#34;) key := \u0026#34;中国\u0026#34; value, ok := sliceMap[key] if !ok { value = make([]string, 0, 2) } value = append(value, \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;) sliceMap[key] = value fmt.Println(sliceMap) } ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/","summary":"\u003cp\u003eGo语言中提供的映射关系容器为\u003ccode\u003emap\u003c/code\u003e，其内部使用\u003ccode\u003e散列表（hash）\u003c/code\u003e实现。\u003c/p\u003e","title":"Go语言基础之map"},{"content":"本文主要介绍Go语言中切片（slice）及它的基本使用。\n引入 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：\nfunc arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum + v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，\na := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了，这样就难受的一批。而切片可以很好的解决这个问题\n切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。\n切片的定义 声明切片类型的基本语法如下：\nvar name []T  name:表示变量名 T:表示切片中的元素类型  例如：\nfunc main() { // 声明切片类型 \tvar a []string //声明一个字符串切片 \tvar b = []int{} //声明一个整型切片并初始化 \tvar c = []bool{false, true} //声明一个布尔切片并初始化 \tvar d = []bool{false, true} //声明一个布尔切片并初始化 \tfmt.Println(a) //[] \tfmt.Println(b) //[] \tfmt.Println(c) //[false true] \tfmt.Println(a == nil) //true \tfmt.Println(b == nil) //false \tfmt.Println(c == nil) //false \t// fmt.Println(c == d) //切片是引用类型，不支持直接比较，只能和nil比较 } 切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。\n切片表达式 简单切片表达式 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1\u0026lt;=索引值\u0026lt;4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] \tfmt.Printf(\u0026#34;s:%v len(s):%v cap(s):%v\\n\u0026#34;, s, len(s), cap(s)) } 输入结果如下：\ns:[2 3] len(s):2 cap(s):4 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:\na[2:] // 等同于 a[2:len(a)] a[:3] // 等同于 a[0:3] a[:] // 等同于 a[0:len(a)] {% span red, 注意： %}\n对于数组或字符串，如果0 \u0026lt;= low \u0026lt;= high \u0026lt;= len(a)，则索引合法，否则就会索引越界（out of range）。\n对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low \u0026lt;= high。如果索引在运行时超出范围，就会发生运行时panic。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] \tfmt.Printf(\u0026#34;s:%v len(s):%v cap(s):%v\\n\u0026#34;, s, len(s), cap(s)) s2 := s[3:4] // 索引的上限是cap(s)而不是len(s) \tfmt.Printf(\u0026#34;s2:%v len(s2):%v cap(s2):%v\\n\u0026#34;, s2, len(s2), cap(s2)) } 输出结果如下：\ns:[2 3] len(s):2 cap(s):4 s2:[5] len(s2):1 cap(s2):1 完整切片表达式 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：\na[low : high : max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} t := a[1:3:5] fmt.Printf(\u0026#34;t:%v len(t):%v cap(t):%v\\n\u0026#34;, t, len(t), cap(t)) } 输出结果如下：\nt:[2 3] len(t):2 cap(t):4 完整切片表达式需要满足的条件是0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a)，其他条件和简单切片表达式相同。\n使用make()函数构造切片 我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下：\nmake([]T, size, cap) 其中：\n T:切片的元素类型 size:切片中元素的数量 cap:切片的容量  举个例子：\nfunc main() { a := make([]int, 2, 10) fmt.Println(a) //[0 0] \tfmt.Println(len(a)) //2 \tfmt.Println(cap(a)) //10 } 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。\n切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。\n 多个切片指向同一数组时，对任一切片进行操作时，都有可能对其他切片造成影响  切片不能直接比较 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：\nvar s1 []int //len(s1)=0;cap(s1)=0;s1==nil s2 := []int{} //len(s2)=0;cap(s2)=0;s2!=nil s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil 所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。\n切片的赋值拷贝 下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。\nfunc main() { s1 := make([]int, 3) //[0 0 0] \ts2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 \ts2[0] = 100 fmt.Println(s1) //[100 0 0] \tfmt.Println(s2) //[100 0 0] } 切片遍历 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。\nfunc main() { s := []int{1, 3, 5} for i := 0; i \u0026lt; len(s); i++ { fmt.Println(i, s[i]) } for index, value := range s { fmt.Println(index, value) } } append()方法为切片添加元素 Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。\nfunc main(){ var s []int s = append(s, 1) // [1] \ts = append(s, 2, 3, 4) // [1 2 3 4] \ts2 := []int{5, 6, 7} s = append(s, s2...) // [1 2 3 4 5 6 7] } **注意：**通过var声明的零值切片可以在append()函数直接使用，无需初始化。\nvar s []int s = append(s, 1, 2, 3) 没有必要像下面的代码一样初始化一个切片再传入append()函数使用，\ns := []int{} // 没有必要初始化 s = append(s, 1, 2, 3) var s = make([]int) // 没有必要初始化 s = append(s, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。\n举个例子：\nfunc main() { //append()添加元素和切片扩容 \tvar numSlice []int for i := 0; i \u0026lt; 10; i++ { numSlice = append(numSlice, i) fmt.Printf(\u0026#34;%v len:%d cap:%d ptr:%p\\n\u0026#34;, numSlice, len(numSlice), cap(numSlice), numSlice) } } 输出：\n[0] len:1 cap:1 ptr:0xc0000a8000 [0 1] len:2 cap:2 ptr:0xc0000a8040 [0 1 2] len:3 cap:4 ptr:0xc0000b2020 [0 1 2 3] len:4 cap:4 ptr:0xc0000b2020 [0 1 2 3 4] len:5 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc0000b8000 [0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc0000b8000 从上面的结果可以看出：\n append()函数将元素追加到切片的最后并返回该切片。 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。  append()函数还支持一次性追加多个元素。 例如：\nvar citySlice []string // 追加一个元素 citySlice = append(citySlice, \u0026#34;北京\u0026#34;) // 追加多个元素 citySlice = append(citySlice, \u0026#34;上海\u0026#34;, \u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;) // 追加切片 a := []string{\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;} citySlice = append(citySlice, a...) fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆] 使用copy()函数复制切片 首先我们来看一个问题：\nfunc main() { a := []int{1, 2, 3, 4, 5} b := a fmt.Println(a) //[1 2 3 4 5] \tfmt.Println(b) //[1 2 3 4 5] \tb[0] = 1000 fmt.Println(a) //[1000 2 3 4 5] \tfmt.Println(b) //[1000 2 3 4 5] } 由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。\nGo语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：\ncopy(destSlice, srcSlice []T) 其中：\n srcSlice: 数据来源切片 destSlice: 目标切片  举个例子：\nfunc main() { // copy()复制切片 \ta := []int{1, 2, 3, 4, 5} c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c \tfmt.Println(a) //[1 2 3 4 5] \tfmt.Println(c) //[1 2 3 4 5] \tc[0] = 1000 fmt.Println(a) //[1 2 3 4 5] \tfmt.Println(c) //[1000 2 3 4 5] } 从切片中删除元素 Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：\nfunc main() { // 从切片中删除元素 \ta := []int{30, 31, 32, 33, 34, 35, 36, 37} // 要删除索引为2的元素 \ta = append(a[:2], a[3:]...) fmt.Println(a) //[30 31 33 34 35 36 37] } 总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)\n","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/","summary":"\u003cp\u003e本文主要介绍Go语言中切片（slice）及它的基本使用。\u003c/p\u003e","title":"Go语言基础之切片"},{"content":"本文主要介绍Go语言中数组（array）及它的基本使用。\nArray(数组) 数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：\n// 定义一个长度为3元素类型为int的数组a var a [3]int 数组定义： var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。\nvar a [3]int var b [4]int a = b //不可以这样做，因为此时a和b是不同的类型 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。\n数组的初始化 数组的初始化也有很多方式。\n方法一 初始化数组时可以使用初始化列表来设置数组元素的值。\nfunc main() { var testArray [3]int //数组会初始化为int类型的零值 \tvar numArray = [3]int{1, 2} //使用指定的初始值完成初始化 \tvar cityArray = [3]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} //使用指定的初始值完成初始化 \tfmt.Println(testArray) //[0 0 0] \tfmt.Println(numArray) //[1 2 0] \tfmt.Println(cityArray) //[北京 上海 深圳] } 方法二 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：\nfunc main() { var testArray [3]int var numArray = [...]int{1, 2} var cityArray = [...]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} fmt.Println(testArray) //[0 0 0] \tfmt.Println(numArray) //[1 2] \tfmt.Printf(\u0026#34;type of numArray:%T\\n\u0026#34;, numArray) //type of numArray:[2]int \tfmt.Println(cityArray) //[北京 上海 深圳] \tfmt.Printf(\u0026#34;type of cityArray:%T\\n\u0026#34;, cityArray) //type of cityArray:[3]string } 方法三 我们还可以使用指定索引值的方式来初始化数组，例如:\nfunc main() { a := [...]int{1: 1, 3: 5} fmt.Println(a) // [0 1 0 5] \tfmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, a) //type of a:[4]int } 数组的遍历 遍历数组a有以下两种方法：\nfunc main() { var a = [...]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} // 方法1：for循环遍历 \tfor i := 0; i \u0026lt; len(a); i++ { fmt.Println(a[i]) } // 方法2：for range遍历 \tfor index, value := range a { fmt.Println(index, value) } } 多维数组 Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。\n二维数组的定义 func main() { a := [3][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]] \tfmt.Println(a[2][1]) //支持索引取值:重庆 } 二维数组的遍历 func main() { a := [3][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } for _, v1 := range a { for _, v2 := range v1 { fmt.Printf(\u0026#34;%s\\t\u0026#34;, v2) } fmt.Println() } } 输出：\n北京\t上海\t广州\t深圳\t成都\t重庆\t注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：\n//支持的写法 a := [...][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } //不支持多维数组的内层使用... b := [3][...]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } 数组是值类型 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。\nfunc modifyArray(x [3]int) { x[0] = 100 } func modifyArray2(x [3][2]int) { x[2][0] = 100 } func main() { a := [3]int{10, 20, 30} modifyArray(a) //在modify中修改的是a的副本x \tfmt.Println(a) //[10 20 30] \tb := [3][2]int{ {1, 1}, {1, 1}, {1, 1}, } modifyArray2(b) //在modify中修改的是b的副本x \tfmt.Println(b) //[[1 1] [1 1] [1 1]] } 注意：\n 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T表示指针数组，*[n]T表示数组指针 。 ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/","summary":"\u003cp\u003e本文主要介绍Go语言中数组（array）及它的基本使用。\u003c/p\u003e","title":"Go语言基础之数组"},{"content":"流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。\nGo语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。\nif else (分支结构) if条件判断基本写法 Go语言中if条件判断的格式如下：\nif 表达式1 { 分支1 } else if 表达式2 { 分支2 } else{ 分支3 } Go语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 同理，与else匹配的{也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。\n例如：\nfunc myfunc() { score := 65 if score \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt;= 85 { fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } } if条件判断特殊写法 if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：\nfunc myfunc() { if score := 65; score \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt;= 85 { fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } } 两种写法有什么不同呢？\nfor (循环结构) Go 语言中的所有循环类型均可以使用for关键字来完成。\nfor循环的基本格式如下：\nfor 初始语句;条件表达式;结束语句{ 循环体语句 } 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。\nfunc myfunc1() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：\nfunc myfunc2() { i := 0 for ; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句和结束语句都可以省略，例如：\nfunc myfunc3() { i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } } 这种写法类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。\n{% noteblock, 无限循环 %}\n{% folding yellow, Folding 点击打开 %}\nfor { 循环体语句 } {% endfolding %}\nfor循环可以通过break、goto、return、panic语句强制退出循环。\n{% endnoteblock %}\nfor range(键值循环) Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：\n 数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。  switch case 使用switch语句可方便地对大量的值进行条件判断。\nfunc switch1() { finger := 3 switch finger { case 1: fmt.Println(\u0026#34;大拇指\u0026#34;) case 2: fmt.Println(\u0026#34;食指\u0026#34;) case 3: fmt.Println(\u0026#34;中指\u0026#34;) case 4: fmt.Println(\u0026#34;无名指\u0026#34;) case 5: fmt.Println(\u0026#34;小拇指\u0026#34;) default: fmt.Println(\u0026#34;无效的输入！\u0026#34;) } } Go语言规定每个switch只能有一个default分支。\n一个分支可以有多个值，多个case值中间使用英文逗号分隔。\nfunc Switch2() { switch n := 7; n { case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;奇数\u0026#34;) case 2, 4, 6, 8: fmt.Println(\u0026#34;偶数\u0026#34;) default: fmt.Println(n) } } 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：\nfunc switch3() { age := 30 switch { case age \u0026lt; 25: fmt.Println(\u0026#34;好好学习！\u0026#34;) case age \u0026gt; 25 \u0026amp;\u0026amp; age \u0026lt; 35: fmt.Println(\u0026#34;好好工作！\u0026#34;) case age \u0026gt; 60: fmt.Println(\u0026#34;好好享受！\u0026#34;) default: fmt.Println(\u0026#34;长命百岁！\u0026#34;) } } fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。\nfunc switch4() { s := \u0026#34;a\u0026#34; switch { case s == \u0026#34;a\u0026#34;: fmt.Println(\u0026#34;a\u0026#34;) fallthrough case s == \u0026#34;b\u0026#34;: fmt.Println(\u0026#34;b\u0026#34;) case s == \u0026#34;c\u0026#34;: fmt.Println(\u0026#34;c\u0026#34;) default: fmt.Println(\u0026#34;...\u0026#34;) } } 输出：\na b {% note warning, 注意Go与C中switch的区别 %}\ngoto(跳转到指定标签) goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：\nfunc goto1() { var breakFlag bool for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 \tbreakFlag = true break } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } // 外层for循环判断 \tif breakFlag { break } } } 使用goto语句能简化代码：\nfunc goto2() { for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 \tgoto breakTag } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } return // 标签 breakTag: fmt.Println(\u0026#34;结束for循环\u0026#34;) } break(跳出循环) break语句可以结束for、switch和select的代码块。\nbreak语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子：\nfunc break1() { BREAKDEMO1: for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { break BREAKDEMO1 } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } fmt.Println(\u0026#34;...\u0026#34;) } continue(继续下次循环) continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。\n在 continue语句后添加标签时，表示开始标签对应的循环。例如：\nfunc continue1() { forloop1: for i := 0; i \u0026lt; 5; i++ { // forloop2: \tfor j := 0; j \u0026lt; 5; j++ { if i == 2 \u0026amp;\u0026amp; j == 2 { continue forloop1 } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } } ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"\u003cp\u003e流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。\u003c/p\u003e\n\u003cp\u003eGo语言中最常用的流程控制有\u003ccode\u003eif\u003c/code\u003e和\u003ccode\u003efor\u003c/code\u003e，而\u003ccode\u003eswitch\u003c/code\u003e和\u003ccode\u003egoto\u003c/code\u003e主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。\u003c/p\u003e","title":"Go语言基础之流程控制"},{"content":"运算符用于在程序运行时执行数学或逻辑运算。\nGo 语言内置的运算符有五类：\n 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符  算数运算符    运算符 描述     + 相加   - 相减   * 相乘   / 相除   % 求余    注意： ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符。\n关系运算符    运算符 描述     == 检查两个值是否相等，如果相等返回 True 否则返回 False。   != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   \u0026gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   \u0026gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。   \u0026lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   \u0026lt;= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。    逻辑运算符    运算符 描述     \u0026amp;\u0026amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。   || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。   ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。    位运算符 位运算符对整数在内存中的二进制位进行操作。\n   运算符 描述     \u0026amp; 参与运算的两数各对应的二进位相与。 （两位均为1才为1）   | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）   ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）   \u0026laquo; 左移n位就是乘以2的n次方。 “a\u0026laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。   \u0026raquo; 右移n位就是除以2的n次方。 “a\u0026raquo;b”是把a的各二进位全部右移b位。    赋值运算符    运算符 描述     = 简单的赋值运算符，将一个表达式的值赋给一个左值   += 相加后再赋值   -= 相减后再赋值   *= 相乘后再赋值   /= 相除后再赋值   %= 求余后再赋值   \u0026laquo;= 左移后赋值   \u0026raquo;= 右移后赋值   \u0026amp;= 按位与后赋值   |= 按位或后赋值   ^= 按位异或后赋值   ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"\u003cp\u003e运算符用于在程序运行时执行数学或逻辑运算。\u003c/p\u003e","title":"Go语言基础之运算符"},{"content":"Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。\n基本数据类型 整型 整数分为以下两个大类：\n按长度分为：int8，int16，int64\n对应的无符号整型：uint16，uint32，uint64\n其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。\n特殊整型    类型 描述     uint 32位操作系统上就是uint32，64位操作系统上就是uint64   int 32位操作系统上就是int32，64位操作系统上就是int64   uintptr 无符号整型，用于存放一个指针    浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。\n打印浮点数时，可以使用fmt包配合动词%f，代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Printf(\u0026#34;%f\\n\u0026#34;, math.Pi) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, math.Pi) } 复数 complex64和complex128\n具体用法如下：\nvar c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。\n注意：\n 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。  字符串 Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(\u0026quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：\ns1 := \u0026#34;hello\u0026#34; s2 := \u0026#34;你好\u0026#34; 转义字符    \\r 回车符（返回行首）     \\n 换行符（直接跳到下一行的同列位置）   \\t 制表符   \\' 单引号   \\\u0026quot; 双引号   \\\\ 反斜杠    例如，我们要打印Windows平台的文件路径\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;str := \\\u0026#34;c:\\\\Code\\\\lesson1\\\\go.exe\\\u0026#34;\u0026#34;) } 多行字符串 Go语言中要定义一个多行字符串时，就必须使用反引号字符：\ns1 := `第一行 第二行 第三行 ` fmt.Println(s1) 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。\n字符串的常用操作    len(str) 求长度     + 或 fmt.Sprintf 拼接字符串   strings.Split 分割   strings.contains 判断是否包含   strings.HasPrefix,strings.HasSuffix 前缀/后缀判断   strings.Index(),strings.LastIndex() 子串出现的位置    byte和rune类型 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（'）包裹起来，如：\nvar a := \u0026#39;中\u0026#39; var b := \u0026#39;x\u0026#39; Go 语言的字符有以下两种：\n uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。 rune类型，代表一个 UTF-8字符。  当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。\n如下，可以知道rune和byte的区别：\n// 遍历字符串 func traversalString() { s := \u0026#34;GO你好\u0026#34; for i := 0; i \u0026lt; len(s); i++ { //byte \tfmt.Printf(\u0026#34;%v(%c) \u0026#34;, s[i], s[i]) } fmt.Println() for _, r := range s { //rune \tfmt.Printf(\u0026#34;%v(%c) \u0026#34;, r, r) } fmt.Println() } 这是我们的输出结果\n71(G) 79(O) 228(ä) 189(½) 160( ) 229(å) 165(¥) 189(½) 71(G) 79(O) 20320(你) 22909(好) 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。\n字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。\n修改字符串 要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。\nfunc changeString() { s1 := \u0026#34;big\u0026#34; // 强制类型转换 \tbyteS1 := []byte(s1) byteS1[0] = \u0026#39;p\u0026#39; fmt.Println(string(byteS1)) s2 := \u0026#34;白萝卜\u0026#34; runeS2 := []rune(s2) runeS2[0] = \u0026#39;红\u0026#39; fmt.Println(string(runeS2)) } 类型转化 强制类型转换的基本语法如下：\nT(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等\n比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型\nfunc sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 \tc = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"\u003cp\u003eGo语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。\u003c/p\u003e","title":"Go语言基础之基本数据类型"},{"content":"变量和常量是编程中必不可少的部分，也是很好理解的一部分。\n标识符与关键字 标识符 关于Go语言中的命名规则，与C类似。Go语言中标识符由字母、数字和_(下划线)组成，并且只能以字母和_开头。 例如aaa,_ ,_123,a123\n关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。且不能将关键字和保留字作为变量名\n//25个关键字 break default func interface select case defer go map struct chan const continue else fallthrough if for goto package range import return switch type var //37个保留字 Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 变量 变量类型 变量的功能是存储数据，不同类型的变量存储不同类型的数据。\n常见变量的数据类型有：整型、浮点型、布尔型等。\nGo语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。\n变量声明 Go语言声明变量的格式为:\nvar 变量名 变量类型 例如：\nvar name string var age int var isOK bool 当然，在Go语言中，可以批量声明变量\nvar( a string b int c bool d float32 ) 变量初始化 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。\n当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：\nvar 变量名 类型 = 值 例如：\nvar name string = \u0026#34;Q1mi\u0026#34; var age int = 18 同样，也支持多个变量初始化\nvar name, age = \u0026#34;Q1mi\u0026#34;, 20 {% note info, 类型推导 %}\n有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。\nvar name = \u0026#34;Q1mi\u0026#34; var age = 18 {% note info, 短变量声明 %}\n在函数内部，可以使用更简略的:=方式声明并初始化变量。\npackage main import \u0026#34;fmt\u0026#34; // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m \tfmt.Println(m, n) } {% note info, 匿名变量 %} 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量。 匿名变量用一个下划线_表示。\n例如：\nfunc test() (int, string) { return 10, \u0026#34;hahaha\u0026#34; } func main() { x, _ := test() _, y := test() fmt.Println(\u0026#34;x=\u0026#34;, x) fmt.Println(\u0026#34;y=\u0026#34;, y) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。\n注意事项：\n 函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。  常量 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把ar换成了const，常量在定义的时候必须赋值。\nconst pi = 3.1415 const e = 2.7182 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。\n多个常量也可以一起声明：\nconst ( pi = 3.1415 e = 2.7182 ) const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。\n例如：\nconst ( n1 = 100 n2 n3 ) ","permalink":"https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","summary":"\u003cp\u003e变量和常量是编程中必不可少的部分，也是很好理解的一部分。\u003c/p\u003e","title":"Go语言基础之变量与常量"},{"content":"引入 例题hdu1097\n这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\n{% folding green, 点击展开 %}\nlong long fastPower(long long base, long long power){ long long ans = 1; for(int i = 0; i \u0026lt; power; i++){ ans *=base; } return ans % 10; } {%endfolding%}\n那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？\nint fastPower(long long base, long long power){ int ans = 1; base %= 10; for(int i = 0; i \u0026lt; power; i++){ ans *= base; if(ans \u0026gt; 9) ans %= 10; } return ans; } 结果同样，如果数据过大，还是会超时。\n快速幂 {% folding green, 取模的运算法则 %}\n$(a+b) mod M = (amodM + bmodM)modM$\n$(a-b)modM = (amodM - bmodM)modM$\n$(a*b)modM = (amodM * bmodM)modM$\n{% endfolding %}\n 入门 快速幂算法可以高效快速的算出$a^n$。\n下面举一个例子\n如果计算$2^{10}$\n$2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\n尽量将指数变小，如下\n$2^{10} = (2*2)^5 = 4^5$\n此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。\n那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样\n$2^{10} = 4^4*4^1$\n将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作：\n$2^{10} = 16^2*4^1$\n将指数再次缩小一半\n$2^{10} = 256^1*4^1$\n此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，得到的结果是变化过程中所有指数为奇数时的底数的乘积\n初步实现 用代码实现上面的算法：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) { power -= 1; result = result * base % 10; power /= 2; base = base * base % 10; } else { power /= 2; base = base * base % 10; } } return result % 10; } 优化 1.由于if、else中有重复语句\npower /= 2; base = base * base % 10; 2.且在整形运算中\npower -=1; power /=2; 可以压缩成下面一句\npower /=2;  于是代码就可以压缩成以下这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) result = result * base % 10; power /= 2; base = base * base % 10; } return result % 10; } 再次优化 在C/C++中可以利用更快位运算来代替一些计算，例如\npower % 2 == 1; power \u0026amp; 1 == 1;//位运算 power /=2; power \u0026gt;\u0026gt;= 1;//位运算 于是代码就变成了这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power \u0026amp; 1) result = result * base % 10; power \u0026gt;\u0026gt;= 1; base = base * base % 10; } return result % 10; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/","summary":"\u003ch2 id=\"引入\"\u003e引入\u003c/h2\u003e\n\u003cp\u003e例题\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1097\"\u003ehdu1097\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\u003c/p\u003e\n\u003cp\u003e{% folding green, 点击展开 %}\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efastPower\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e base, \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e power){\n    \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e power; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n        ans \u003cspan style=\"color:#f92672\"\u003e*=\u003c/span\u003ebase;\n    }\n    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e{%endfolding%}\u003c/p\u003e","title":"快速幂"},{"content":"STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\n容器 使用容器时要在头文件中引入\n序列式容器 序列的元素的位置是由进入容器的时间和地点决定的\nvector vector简单点说就是一个动态数组，vector实现动态增长，当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间。\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; void PrintVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //初始化 void test01() { vector\u0026lt;int\u0026gt; v1; //默认构造  int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v2(arr, arr + sizeof(arr) / sizeof(int)); vector\u0026lt;int\u0026gt; v3(v2.begin(), v2.end()); vector\u0026lt;int\u0026gt; v4(v3); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //常用赋值操作 void test02() { int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); //成员方法  vector\u0026lt;int\u0026gt; v2; v2.assign(v1.begin(), v1.end()); //重载=  vector\u0026lt;int\u0026gt; v3; v3 = v2; int arr1[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v4(arr1, arr1 + sizeof(arr1) / sizeof(int)); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); cout \u0026lt;\u0026lt; \u0026#34;---------------\u0026#34; \u0026lt;\u0026lt; endl; //交换  v4.swap(v1); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //大小操作 void test03() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; if (v1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } PrintVector(v1); v1.resize(2); PrintVector(v1); v1.resize(6, 1); //不写默认零  PrintVector(v1); for (int i = 0; i \u0026lt; 10000; i++) { v1.push_back(i); } cout \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; //长度、大小  cout \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; //容量 } //vector存取数据 void test04() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;front: \u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; //第一个元素  cout \u0026lt;\u0026lt; \u0026#34;back: \u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; //最后一个元素 } //插入和删除 void test05() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(20); //头插法  v.insert(v.begin(), 30); //尾插法  v.insert(v.end(), 40); PrintVector(v); v.insert(v.begin() + 2, 100); //插到第二个位置  //vector支持随机访问  //支持数组下标，一般都支持随机访问  //迭代器可以直接+-操作  PrintVector(v); //删除  v.erase(v.begin()); PrintVector(v); v.erase(v.begin() + 1, v.end()); PrintVector(v); v.clear(); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } //巧用swap缩减空间 void test06() { //vector添加元素 自动增长 那么，删除元素的时候，会自动减少吗  vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; //收缩空间  vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; PrintVector(v); } void test07() { //reserve预留空间 resize区别  int num = 0; int* address = NULL; vector\u0026lt;int\u0026gt; v; v.reserve(100000); //预先分配  for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (address != \u0026amp;v[0]) { num++; } } cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; //如果你知道容器大概需要的空间，预先分配空间，可以减少时间浪费吗，提高程序运行效率 } int main() { //test01();  //test02();  //test03();  //test04();  //test05();  //test06();  test07(); return 0; } deque deque表示双端队列，即可以从前端或者后端这两端进行数据的插入和删除\n 分段连续的内存空间 支持随机访问 指定位置插入，会引起数据移动  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;deque\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; void PrintDeque(deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } //初始化 void test01() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2(10, 5); deque\u0026lt;int\u0026gt; d3(d2.begin(), d2.end()); deque\u0026lt;int\u0026gt; d4(d3); //打印  PrintDeque(d4); cout \u0026lt;\u0026lt; endl; } //赋值、大小操作 void test02() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2; deque\u0026lt;int\u0026gt; d3; d1.assign(10, 5); d2.assign(d1.begin(), d1.end()); //迭代器指定区间赋值  d3 = d2; //等号赋值  d1.swap(d2); //交换两个空间的元素  if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } d1.resize(5); //有十个，后五个扔掉 } //插入和删除 void test03() { deque\u0026lt;int\u0026gt; d1; d1.push_back(100); d1.push_front(200); d1.push_back(300); d1.push_back(400); d1.push_front(500); //500 200 100 300 400  PrintDeque(d1); int val = d1.front(); //拿到第一个数据  d1.pop_front(); //删除第一个，无返回值  val = d1.back(); d1.pop_back(); //删除最后一个元素 } int main() { //test01();  //test02();  test03(); return 0; } list  双向链表 链表是由一系列节点组成的，节点包括两个域，一个数据域，一个指针域。 链表内存是非连续的，添加删除元素 时间复杂度是常数项 不需要移动元素 链表需要额外空间保留节点关系 不支持随机访问，故不能使用算法提供的sort()来进行排序，但可以调用其成员方法  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;using namespace std; //初始化 void test01() { list\u0026lt;int\u0026gt; l1; list\u0026lt;int\u0026gt; l2(10, 10); list\u0026lt;int\u0026gt; l3(l2); list\u0026lt;int\u0026gt; l4(l3.begin(), l3.end()); //打印  for (list\u0026lt;int\u0026gt;::iterator it = l4.begin(); it != l4.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test02() { list\u0026lt;int\u0026gt; l; l.push_back(100); l.push_front(200); l.insert(l.begin(), 300); l.insert(l.end(), 200); list\u0026lt;int\u0026gt;::iterator it = l.begin(); it++; l.insert(it, 500); //删除  //l.pop_back();  //l.pop_front();  //l.erase(l.begin(), l.end());  l.remove(200); //删除匹配的所有值  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test03() { list\u0026lt;int\u0026gt; l; l.assign(10, 10); list\u0026lt;int\u0026gt; l2; l2 = l; list\u0026lt;int\u0026gt; l3; l3.swap(l); } //反转 void test04() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(i); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.reverse(); //容器元素反转  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } bool Mycompare(int val1, int val2) { return val1 \u0026gt; val2; } //排序 void test05() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(rand() % 10); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.sort(); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小  l.sort(Mycompare); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //算法sort 只支持可随机访问的容器 链表没有  //list的sort是自己的成员函数不是算法 } int main() { //test01();  //test02();  //test04();  test05(); return 0; } queue  先进先出 不提供迭代器，不能遍历，不支持随机访问 push 入队（队尾） pop 出队（队头）  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;queue\u0026gt;using namespace std; void test01() { queue\u0026lt;int\u0026gt; q;//创建队列  q.push(10); q.push(20); q.push(30); q.push(40); cout \u0026lt;\u0026lt; \u0026#34;队尾元素: \u0026#34; \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; //输出顺序 10,20,30,40 \twhile (q.size() \u0026gt; 0){ cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//输出队头 \tq.pop();//删除队头 \t} } int main() { test01(); return 0; } stack  先进后出 push 压栈 pop 出栈 栈不提供迭代器，不能遍历，不支持随机访问，只能通过top从栈顶获取和删除元素  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;stack\u0026gt;using namespace std; void test01(){ //初始化 \tstack\u0026lt;int\u0026gt; s1; stack\u0026lt;int\u0026gt; s2(s1); //stack操作 \ts1.push(10); s1.push(20); s1.push(30); s1.push(100); cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; s1.pop();//删除栈顶元素  cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; //打印栈容器数据 \twhile (!s1.empty()) { cout \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; s1.pop(); } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size:\u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } 关联式容器 容器的规则是固定的，与元素进入容器的时间和地点无关\nset/multiset set表示集合，集合是存储排序键的关联式容器，且每个键值都是唯一的，可以插入或删除但是不能更改\n 以红黑树为底层机制，查找效率非常好 set中不允许重复元素，multiset中允许重复元素 不可通过迭代器改变set元素的值，会破坏set组织  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt;using namespace std; //仿函数 类 class Mycompare { public: bool operator()(int v1, int v2) const { //此处注意，要加const限定符  return v1 \u0026gt; v2; } }; //set容器初始化 void test01() { set\u0026lt;int, Mycompare\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); //自动进行排序，默认从小到大  for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小排序怎么办？ #if 0//赋值 set\u0026lt;int\u0026gt; s2; s2 = s1; //删除 s1.erase(s1.begin()); s1.erase(6); for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; s2.clear(); cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; #endif } //set查找 void test02() { //实值  set\u0026lt;int\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); set\u0026lt;int\u0026gt;::iterator ret = s1.find(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于等于的元素  ret = s1.lower_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于的元素  ret = s1.upper_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //equal_range 返回lower_bound和upper_bound的值  pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, set\u0026lt;int\u0026gt;::iterator\u0026gt; pret = s1.equal_range(4); if (pret.first == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.first \u0026lt;\u0026lt; endl; } if (pret.second == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.second \u0026lt;\u0026lt; endl; } } class Person { public: Person(int id, int age) : id(id), age(age){}; int id; int age; }; class PersonCompare { public: bool operator()(const Person\u0026amp; p1, const Person\u0026amp; p2) const { return p1.age \u0026gt; p2.age; } }; void test03() { set\u0026lt;Person, PersonCompare\u0026gt; sp; Person p1(10, 20), p2(30, 40), p3(50, 60); sp.insert(p1); sp.insert(p2); sp.insert(p3); for (set\u0026lt;Person, PersonCompare\u0026gt;::iterator it = sp.begin(); it != sp.end(); it++) { cout \u0026lt;\u0026lt; (*it).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).age \u0026lt;\u0026lt; endl; } //查找  Person p4(90, 20); set\u0026lt;Person, PersonCompare\u0026gt;::iterator ret = sp.find(p4); //可找到，对应p1，按照age排序就按照age查找  if (ret == sp.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (*ret).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*ret).age \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对组 将两个值合并成一个值\n#define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;using namespace std; void test01() { pair\u0026lt;int, int\u0026gt; pair1(10, 20); cout \u0026lt;\u0026lt; pair1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair1.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair2 = make_pair(10, \u0026#34;aaa\u0026#34;); cout \u0026lt;\u0026lt; pair2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair2.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair3 = pair2; cout \u0026lt;\u0026lt; pair3.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair3.second \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } map/multimap  map与set区别，map具有键值和实值 所有元素根据键值自动排序 pair的第一个元素成为键值，第二个元素成为实值 map也是以红黑树为底层实现机制 不可以通过map的迭代器修改map键值，键值关系到容器内元素的排列顺序，任意改变键值会破坏容器的排列规则，但是可以改变实值 multimap允许相同键值存在，map不允许  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; //map初始化 void test01() { //map容器模板参数：第一个参数key的类型，第二个参数value的类型  map\u0026lt;int, int\u0026gt; m; //插入数据 pair.first 对应key，pair.second 对应value  //第一种  pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, bool\u0026gt; ret = m.insert(pair\u0026lt;int, int\u0026gt;(10, 10)); //放入匿名对象  if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第二种  ret = m.insert(make_pair(10, 20)); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第三种  m.insert(map\u0026lt;int, int\u0026gt;::value_type(30, 30)); //第四种  m[40] = 40; m[10] = 20; //如果key不存在，创建pair并插入  //如果key存在，修改value实值  //打印  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;m[60] = \u0026#34; \u0026lt;\u0026lt; m[60] \u0026lt;\u0026lt; endl; //访问一个不存再的key，那么map会将这个key插入到map中，对应的value默认为零  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } } class MyKey { public: MyKey(int index, int id) : index(index), id(id) {} int index; int id; }; struct mycompare { bool operator()(MyKey key1, MyKey key2) const { return key1.index \u0026gt; key2.index; } }; void test02() { map\u0026lt;MyKey, int, mycompare\u0026gt; m; //需要排序，自定义类型，给定一个排序方法  m.insert(make_pair(MyKey(1, 2), 2)); m.insert(make_pair(MyKey(3, 4), 2)); for (map\u0026lt;MyKey, int, mycompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; it-\u0026gt;first.index \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first.id \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } //equal_range void test03() { map\u0026lt;int, int\u0026gt; m; m.insert(make_pair(1, 4)); m.insert(make_pair(2, 5)); m.insert(make_pair(3, 6)); pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, map\u0026lt;int, int\u0026gt;::iterator\u0026gt; ret = m.equal_range(2); if (ret.first-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到lower_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } if (ret.second-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到upper_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对比    容器 vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言：是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快   元素安插移除 尾端 头尾两端 任何位置 - - - -    迭代器 可以理解为指针，对指针的操作基本可以对迭代器操作，但实际上，迭代器是一个类，这个类封装了一个指针\n算法 通过有限的步骤解决问题的方法\n","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/stl/","summary":"\u003cp\u003eSTL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\u003c/p\u003e","title":"STL"},{"content":"“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\n并查集可以总结为三句话：\n “并”的意思是把两个有某些关系的结点并到一起 “查”的意思是查找一个结点的根节点 “并”的时候需要用到“查”  初始化 int father[len];//此数组定义在全局  void Init(int n){ for (int i = 0; i \u0026lt; len; ++i) {//len为结点总数 \tfather[i] = i; } } 查 初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点）\n假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.\n如图即是对应关系\n//查（非递归算法） int FindRoot(int x){ r = x; while(r != father[r]){//自己是自己的爹即是找到了根结点  r = father[r]; } return r; } //递归算法 int FindRoot(int x){ return x == father[x] ? x : FindRoot(father[x]); } 并 如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作；\n相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作\n//并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(x != y){ parent[y] = x; } } 例题 hdu1213\n问题描述 今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。 此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。\n例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上 所以伊格纳修斯至少需要 2 张桌子。\n输入 输入以表示测试用例数的整数 T（1\u0026lt;=T\u0026lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1\u0026lt;=N，M\u0026lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。\n输出 对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。\n示例输入 2 5 3 1 2 2 3 4 5 5 1 2 5 示例输出 2 4 这道题用一句话概括就是在一张桌子上，每个人都要有认识的人\n代码 #include\u0026lt;stdio.h\u0026gt; int father[1001]; int find(int x) { return father[x] == x ? x : find(father[x]); } void merge (int x, int y) { x = find(x); y = find(y); if (x != y) { a[x] = y; } } int main(int argc, char const *argv[]) { int t, m, n, x, y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } for (int i = 0; i \u0026lt; m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); merge(x, y); } for (int i = 1; i \u0026lt;= n; ++i) { if (father[i] == i) { cnt++; } } printf(\u0026#34;%d\\n\u0026#34;, cnt); } return 0; } 优化 合并的优化 如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免\n不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度\n初始化代码如下\nint father[len]; int height[len]; for(int i = 0; i \u0026lt; len; i++){ father[i] = i; height[i] = 1;//初始深度为1 } //并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(height[x] == height[y]){//此处无需判断x，y根结点是否一致 \theight[x] = height[x] + 1; father[y] = x; } else if(height[x] \u0026gt; height [y]){ father[y] = x; } else { father[x] = y; } } 查询的优化 //对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。 //这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果 int find (int x){ if(x != parent[x]){ father[x] = find(father[x]); } return father[x]; } 此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并\n但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下：\nint Find(int x){ int r = x; while(father[r] != r){//找到根结点 \tr = father[r]; } int i = x; int j; while(i != r){//循环修改这条路径上的根结点 \tj = father[i];//j记录元素i此时的父亲 \tfather[i] = r;//将i的父亲改为根结点 \ti = j;//i记录为要“查询”的结点  } return r; } 经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$\n总结  并查集的思想很精妙，用一个数组表示了整片森林 优化的关键在于记录每棵树的结点数量，根据结点关系合并 ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6%e6%9f%a5%e9%9b%86.jpg\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\u003c/p\u003e","title":"并查集"},{"content":"树的遍历 上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。\n以下是树的非递归遍历方法：\n偷个懒用一下C++写，头文件要加上\n#include\u0026lt;stack\u0026gt;先序遍历 //先序遍历 void PreorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;先序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; while(t || !s.empty()){ while(t){ cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//拿到这个结点就直接打印 \ts.push(t); t = t-\u0026gt;left; } if(!s.empty()){ t = s.top(); s.pop();\tt = t-\u0026gt;right; } } cout \u0026lt;\u0026lt; endl; } 中序遍历 //中序非递归遍历 void InorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;中序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; while(t || !s.empty()){ while(t){ s.push(t); t = t-\u0026gt;left; } if(!s.empty()){ t = s.top(); s.pop(); cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//遍历完左子树后再打印 \tt = t-\u0026gt;right; } } cout \u0026lt;\u0026lt; endl; } 后序遍历 //后序非递归遍历 void PostorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;后序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; stack\u0026lt;PTree\u0026gt; s2; while(t || !s.empty()){ while(t){ s.push(t); s2.push(t); t = t-\u0026gt;right; } if(!s.empty()){ t = s.top(); s.pop(); t = t-\u0026gt;left; } } while(!s2.empty()){ t = s2.top(); s2.pop(); cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 后序遍历与先序遍历的顺序相反，那么可以先遍历右子树，也就是说将先序遍历的顺序逆过来压入s2中，，然后再根据栈的后进先出的特点，一一出栈。\n","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/","summary":"\u003ch3 id=\"树的遍历\"\u003e树的遍历\u003c/h3\u003e\n\u003cp\u003e上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。\u003c/p\u003e\n\u003cp\u003e以下是树的非递归遍历方法：\u003c/p\u003e","title":"树（二）"},{"content":"树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。\n对于非空树：\n1.有且仅有一个称之为根的结点。\n2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。\n基本术语  结点的度（Degree）：结点的子树个数 树的度：树的所有结点最大的度 叶结点（Leaf）：度为0的结点 父结点（Parent）：有子树的结点是其子树的根结点的父结点 子结点（Child）：若A结点是B结点的父结点，则称B结点为A结点的子结点；子结点也称孩子结点 兄弟结点（Sibling）：具有同一父结点的个节点彼此是兄弟结点 路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，n3\u0026hellip;nk。路径所包含边的个数为路径的长度 祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点 子孙节点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙 结点的层次（Level）：规定根结点在第一层，其它任意节点层数是父结点层数加一 树的深度（Depth）：树中所有结点中的最大层次  二叉树 二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。\n性质 1.二叉树的第i层的最大节点数为2.深度为k的二叉树最大结点数为3.二叉树的终端节点数为n0，度数为2 的结点数为n2，则n0 = n2 +1\n特殊的,\n如果一个深度为 k 的二叉树，正好有 个结点，那么这棵树就被称为满二叉树。\n如图所示：\n如果一个二叉树，只有当第 i 层已经达到了的最大值以后，才能往第 i + 1 层自左向右地添加结点，这棵树就被称为完全二叉树。\n那么，根据二叉树的性质二可得，具有n个结点的完全二叉树的深度为 $$ [log_2(n)]+1 $$\n如图所示：\n二叉树的建立 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt; typedef struct Tree { int data; struct Tree *left; struct Tree *right; } BiTree, *PTree;  //创造一个结点 PTree CreatNode(int value) { PTree p = (PTree)malloc(sizeof(BiTree)); p-\u0026gt;data = value; p-\u0026gt;left = p-\u0026gt;right = NULL; return p; } //插入结点且排序，不存在有相同值的结点 PTree AddNode(int value, PTree p) { if (p == NULL) { return CreatNode(value); } if (value == p-\u0026gt;data) { return p; } if (value \u0026lt; p-\u0026gt;data) { if (p-\u0026gt;left == NULL) { p-\u0026gt;left = CreatNode(value); return p-\u0026gt;left; } else { return AddNode(value, p-\u0026gt;left); } } else { if (p-\u0026gt;right == NULL) { p-\u0026gt;right = CreatNode(value); return p-\u0026gt;right; } else { return AddNode(value, p-\u0026gt;right); } } } 遍历二叉树 递归遍历左子树、根节点、递归遍历右子树\n先序遍历 输出根节点，递归遍历左子树，在递归遍历右子树\nvoid Preorder(PTree p) { if (p != NULL) { printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); Preorder(p-\u0026gt;left); Preorder(p-\u0026gt;right); } } 中序遍历 递归遍历左子树，输出根节点，在递归遍历右子树\nvoid Midorder(PTree p) { if (p != NULL) { Midorder(p-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); Midorder(p-\u0026gt;right); } } 后序遍历 递归遍历左子树，再递归遍历右子树，输出根节点\nvoid Postorder(PTree p) { if (p != NULL) { Postorder(p-\u0026gt;left); Postorder(p-\u0026gt;right); printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); } } 求二叉树的深度 int TreeHeight(PTree p) { int l, r; if (p == NULL) { return 0; } else { l = TreeHeight(p-\u0026gt;left); r = TreeHeight(p-\u0026gt;right); return (l \u0026gt; r ? l : r) + 1; } }  int main(int argc, char const *argv[]) {//测试 \tint value; PTree p = NULL; printf(\u0026#34;Please enter 10 numbers:\u0026#34;); for (int i = 0; i \u0026lt; 10; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;value); if (p == NULL) { p = CreatNode(value); } else { AddNode(value, p); } } Preorder(p); printf(\u0026#34;\\n\u0026#34;); Midorder(p); printf(\u0026#34;\\n\u0026#34;); Postorder(p); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;The depth of the binary tree is：%d\\n\u0026#34;, TreeHeight(p)); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/","summary":"\u003cp\u003e树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。\u003c/p\u003e\n\u003cp\u003e对于非空树：\u003c/p\u003e\n\u003cp\u003e1.有且仅有一个称之为根的结点。\u003c/p\u003e\n\u003cp\u003e2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。\u003c/p\u003e","title":"树（一）"},{"content":"引入 栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。\n顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。\n栈 定义 栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图\n线性表有两种存储形式，顺序表储存和链表储存。\n顺序栈 #include\u0026lt;stdlib.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Stack{ elem* base;//栈基 \telem* top;//栈顶 \tint stacksize; //栈的容量 }Stack; 创建一个栈 Status CreatStack(Stack* s){ s-\u0026gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base; s-\u0026gt;stacksize = MAXSIZE; return OK; } 入栈 Status PushStack(Stack* s, elem e){ if(s-\u0026gt;top - s-\u0026gt;base \u0026gt;= s-\u0026gt;stacksize){ s-\u0026gt;base = (elem*)realloc(s-\u0026gt;base, sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base + s-\u0026gt;stacksize; s-\u0026gt;stacksize +=MAXSIZE;\t} *(s-\u0026gt;top) = e; s-\u0026gt;top++; return OK; } 出栈 Status PopStack(Stack*s,elem *e){ if(s-\u0026gt;top == s-\u0026gt;base) return ERROR; *e = *--(s-\u0026gt;top); return OK; } 清空 Status CleanStack(Stack* s){ s-\u0026gt;top = s-\u0026gt;base; return OK; } 销毁 Status DestroyStack(Stack* s){ free(s-\u0026gt;base); s-\u0026gt;top = s-\u0026gt;base = NULL; s-\u0026gt;stacksize = 0; return OK; } 获取当前容量 int GetSize(Stack* s){ return s-\u0026gt;stacksize; } 链表栈 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Node//定义链表结构 { elem data;//数据域 \tstruct Node* next;//指针域 }Node, * LNode; typedef struct Stack { LNode top; LNode base; }Stack,*Pstack; 创建一个栈 Pstack CreatStack(){ Pstack stack = (Pstack)malloc(sizeof(Stack)); if(stack == NULL){ return NULL; } stack-\u0026gt;top = stack-\u0026gt;base = NULL; return stack; } 入栈 Status PushStack(Pstack *stack, elem e){ Node* p = (LNode)malloc(sizeof(Node)); if(p == NULL){ return ERROR; } p-\u0026gt;data = e; p-\u0026gt;next = (*stack)-\u0026gt;top; (*stack)-\u0026gt;top = p; return OK; } 出栈 Status PopStack(Pstack *stack){ Node* p = (*stack)-\u0026gt;top; if(p == (*stack)-\u0026gt;base){ printf(\u0026#34;栈已空\u0026#34;); return ERROR; } (*stack)-\u0026gt;top = p-\u0026gt;next; printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); free(p); return OK; } 判断是否为空 Status IsEmptyStack(Pstack stack){ return (stack-\u0026gt;top == stack-\u0026gt;base); } 清空 Status CleanStack(Pstack *stack){ Node*p = (*stack)-\u0026gt;top; while(p){ (*stack)-\u0026gt;top = p-\u0026gt;next; free(p); p = (*stack)-\u0026gt;top; } return OK; } 销毁 Status DestroyStack(Pstack *stack){ CleanStack(stack); free(*stack); return OK; } void test(){//测试 \tPstack stack = CreatStack(); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); for (int i = 0; i \u0026lt; 10; ++i){ PushStack(\u0026amp;stack, i); } printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); /*出栈*/ // for (int i = 0; i \u0026lt; 10; ++i){ \t// PopStack(\u0026amp;stack); \t// } \t// printf(\u0026#34;%\\n\u0026#34;); \t// printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); \t/*清空*/ CleanStack(\u0026amp;stack); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); printf(\u0026#34;%p\\n\u0026#34;,stack); DestroyStack(\u0026amp;stack); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); printf(\u0026#34;%p\\n\u0026#34;,stack); } 栈与递归 递归：函数自己调用自己\n 函数定义是递归的——斐波那契数列 数据结构是递归的——单链表、树 问题解法是递归的——汉诺塔、  函数的调用 函数被调用之前，\n 系统需要将实参以及返回地址传递给被调用的函数进行保存 将被调用的函数的局部变量分配到储存区 将控制转移到被调用的函数的入口  从被调用函数返回到调用函数之前，\n 保存被调用函数的计算结果 释放被调用函数中的数据区 依照被调用函数的保存的返回地址将控制转移至此  队列 定义 队列也是一种重要的线性结构。与栈相同，实现一个队列也需要顺序表或者链表作为基础。但是与栈不同的是，队列是一种先进先出（FIFO）的线性表。其要求所有的数据从队列的一段进入，从队列的另一端离开。在队列中，允许插入数据的一端叫做队尾（rear），允许数据离开的一端叫做队头（front）。如图所示\n链队列 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct QNode { elem data;\t//数据域 \tstruct QNode*next;\t//指针域 } QNode, *PNode; typedef struct { PNode front;\t//队头指针 \tPNode rear;\t//队尾指针 } LinkQueue; 创建一个队列 Status CreatQueue(LinkQueue *q) { q-\u0026gt;front = q-\u0026gt;rear = (PNode)malloc(sizeof(QNode)); if (q-\u0026gt;front == NULL) { return ERROR; } q-\u0026gt;front-\u0026gt;next = NULL; return OK; } 入队 Status PushQueue(LinkQueue *q, elem e) { QNode *p = (PNode)malloc(sizeof(QNode)); if (p == NULL) { return ERROR; } p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return OK; } 出队 Status PopQueue(LinkQueue *q) { if (q-\u0026gt;front == q-\u0026gt;rear) { return ERROR; } QNode* p = q-\u0026gt;front-\u0026gt;next; printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if (q-\u0026gt;rear == p) q-\u0026gt;rear = q-\u0026gt;front; return OK; } 销毁 Status DestroyQueue(LinkQueue *q) { while (q-\u0026gt;front) { q-\u0026gt;rear = q-\u0026gt;front-\u0026gt;next; free(q-\u0026gt;front); q-\u0026gt;front = q-\u0026gt;rear; } return OK; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"引入 栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。\n顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。\n栈 定义 栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图\n线性表有两种存储形式，顺序表储存和链表储存。\n顺序栈 #include\u0026lt;stdlib.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Stack{ elem* base;//栈基 \telem* top;//栈顶 \tint stacksize; //栈的容量 }Stack; 创建一个栈 Status CreatStack(Stack* s){ s-\u0026gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base; s-\u0026gt;stacksize = MAXSIZE; return OK; } 入栈 Status PushStack(Stack* s, elem e){ if(s-\u0026gt;top - s-\u0026gt;base \u0026gt;= s-\u0026gt;stacksize){ s-\u0026gt;base = (elem*)realloc(s-\u0026gt;base, sizeof(elem) * MAXSIZE); if(!","title":"栈和队列"},{"content":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。\n每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。\n在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。\n头指针和头节点 基本概念 头指针 通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。\n头节点 在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。\n[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。\n空链表 单链表 引入头结点的优势 链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。\n优势1：第一个位置的插入删除特别方便 若使用头结点，则第1个位置的插入和删除都是对p—\u0026gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：\n插入操作如下  p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s;  删除操作如下  p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q);   若没有头结点，在第1个位置插入或删除时，需要动头指针。\n插入操作如下  判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。  删除操作如下  判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—\u0026gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q); return PtrL  优势2：统一空表和非空表的处理 若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。\n若不使用头结点，当表非空时，头指针指向第1个结点的地址，即LNode类型，但是对于空表，头指针指向的是NULL*，此时空表和非空表的操作是不一致的。\n链表的建立 有头结点链表的建立 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct LNode{ elem data; //数据域  struct LNode* next; //指针域 }Node, *List;  List HeadCreatList(int n){//带头结点_头插法  Node *s; List head = (List)malloc(sizeof(Node));//生成头结点  head-\u0026gt;next = NULL; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; s-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = s;//头结点的指针域next指向s结点，使得s成为结点  } return head; } List TailCreatList(int n){//带头结点_尾插法  Node *s, *r; List head = (List)malloc(sizeof(Node)); head-\u0026gt;next = NULL; r = head; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; r-\u0026gt;next = s; r = s; } if(r-\u0026gt;next != NULL){ r-\u0026gt;next = NULL; } return head; }  下面这个是建立头结点与建立链表分离\nList CreatHNode(){//建立头结点  Node *s, *r; List head = (List)malloc(sizeof(Node)); head-\u0026gt;next = NULL; return head; } Status HeadList(List head, int n){//头插法  Node *s; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; s-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = s;//头结点的指针域next指向s结点，使得s成为结点  } return OK; } Status TailList(List head, int n){//尾插法  Node *s, *r; r = head; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; r-\u0026gt;next = s; r = s; } if(r-\u0026gt;next != NULL){ r-\u0026gt;next = NULL; } return OK; } 为了方便测试，先写出遍历并打印链表的函数\nStatus PrintList(List head){//打印链表数据  Node *t = head-\u0026gt;next; while (t != NULL){ printf(\u0026#34;%d \u0026#34;,t-\u0026gt;data); t = t-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); return OK; } void test(){//测试  List head; //head = HeadCreatList(10);  head = TailCreatList(10); //head = CreatHNode();  //HeadList(head, 10);  //TailList(head, 10);  PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 无头结点链表的建立 List HeadCreatList(int n){//头插法 \tList head = NULL; Node *p; while(n--){ p = (List)malloc(sizeof(Node)); p-\u0026gt;data = n; if(head == NULL){ p-\u0026gt;next = NULL; head = p; } else{ p-\u0026gt;next = head; head = p; } } return head; } List TailCreatList(int n){//尾插法 \tList head = NULL; Node *p, *q; while(n--){ p = (List)malloc(sizeof(Node)); p-\u0026gt;data = n; if(head == NULL){ head = p; } else{ q-\u0026gt;next = p; } p-\u0026gt;next = NULL; q = p; } return head; } 为了测试，先写出打印链表的函数\nStatus PrintList(List head){//打印链表元素 \tif(head == NULL){ return ERROR; } Node *t = head; while(t != NULL){ printf(\u0026#34;%d\u0026#34;, t-\u0026gt;data);\tt = t-\u0026gt;next; } printf(\u0026#34;%d\u0026#34;); return OK; } void test(){//测试 \tList head; //head = HeadCreatList(10); \thead = TailCreatList(10); PrintList(head); return ; } 链表的各个功能的实现（有头结点） 上面介绍了有无头结点对于功能实现的影响，接下来先使用有头结点的链表进行\n链表元素的添加 //链表添加元素（插头） Status HeadInsertList(List head,Node a){ Node *p = (List)malloc(sizeof(Node)); p-\u0026gt;data = a.data; p-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = p; return OK; } //链表添加元素（插尾） Status TailInsertList(List head,Node a){ Node *p, *t, *s; t = head-\u0026gt;next; p = (List)malloc(sizeof(Node)); p-\u0026gt;data = a.data; while(t!= NULL){ s = t; t = t-\u0026gt;next; } s-\u0026gt;next = p; p-\u0026gt;next = NULL; return OK; } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); //HeadInsertList(head, a);  TailInsertList(head, a); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的插入 //链表的插入（插在之前） Status InsertIndexFront(List head,int i){ Node *p, *q, *r; int j = 0; p = head; while(p \u0026amp;\u0026amp; j \u0026lt; i){ r = p; p = p-\u0026gt;next; j++; } if(!p || j\u0026gt;i){ return ERROR; } q = (List)malloc(sizeof(Node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q-\u0026gt;data); q-\u0026gt;next = p; r-\u0026gt;next = q; return OK; } //链表的插入（插在之后） Status InsertIndexBack(List head,int i){ Node *p,*q; int j = 0; p = head; while(p \u0026amp;\u0026amp; j \u0026lt; i){ p = p-\u0026gt;next; j++; } if(!p || j \u0026gt; i){ return ERROR; } q = (List)malloc(sizeof(Node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q-\u0026gt;data); q-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = q; return OK; } oid test(){//测试  List head; head = HeadCreatList(10); PrintList(head); InsertIndexFront(head,2); //InsertIndexBack(head,2);  PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的查找 //链表元素的查找 elem GetElem(List head, int index){//按序号查找  int j; Node* p; p = head-\u0026gt;next; //p指向第一个数据结点  j = 1; //j为计数器  while (p \u0026amp;\u0026amp; j \u0026lt; index ){ //顺着链表向后扫描，直到p指向第i个元素或p为空  p=p-\u0026gt;next; //p指向下一个结点  j++; //计数器j相应加1  } if (!p || j \u0026gt; index) return -1; //i值不合法i＞n或i\u0026lt;=0  return p-\u0026gt;data;//返回第i个结点的数据域  } elem GetIndex(List head, int e) {//按值查找  //在带头结点的单链表L中查找值为e的元素  Node* p; int index = 0; p = head-\u0026gt;next; while (p \u0026amp;\u0026amp; p-\u0026gt;data!=e){ //顺链域向后扫描，直到p为空或p所指结点的数据域等于e  p=p-\u0026gt;next; //p指向下一个结点  ++index; } if(!p) return -1; //查找失败p为NULL  return index; } void test(){ List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); printf(\u0026#34;%d\\n\u0026#34;,GetElem(head,6)); printf(\u0026#34;%d\\n\u0026#34;,GetIndex(head,6)); system(\u0026#34;pause\u0026#34;); return; } 链表元素的删除 Status DeleteList(List head, int index) {//单链表的删除  //在带头结点的单链表L中，删除第i个位置  Node *p, *q; int j; p = head; j = 0; while((p-\u0026gt;next)\u0026amp;\u0026amp;(j \u0026lt; index - 1)) {//查找第i-1个结点，p指向该结点  p=p-\u0026gt;next; j++; } if (!(p-\u0026gt;next)||(j \u0026gt; index - 1))//当i\u0026gt;n或i\u0026lt;1时，删除位置不合理  return ERROR; q = p-\u0026gt;next; //临时保存被删结点的地址以备释放空间  p-\u0026gt;next = q-\u0026gt;next; //改变删除结点前驱结点的指针域  free(q); //释放被删除结点的空间  return OK; } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); DeleteList(head,4); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的修改 //链表元素的修改 Status ReverseElem(List head, int index,int e){ int j; Node* p; p = head-\u0026gt;next; //p指向第一个数据结点  j = 1; //j为计数器  while (p \u0026amp;\u0026amp; j \u0026lt; index ){ //顺着链表向后扫描，直到p指向第i个元素或p为空  p=p-\u0026gt;next; //p指向下一个结点  j++; //计数器j相应加1  } if (!p || j \u0026gt; index) return ERROR; //i值不合法i＞n或i\u0026lt;=0  p-\u0026gt;data = e; return OK;//返回第i个结点的数据域 } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); ReverseElem(head,4,999); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的清空 //清空链表 Status ClearList(List head) { Node*p,*q; if(head == NULL) return ERROR; p = head-\u0026gt;next; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } head-\u0026gt;next=NULL; return OK; } 链表元素的排序 Status SwapElem(int *i, int *j){//交换数据  int temp = *i; *i = *j; *j = temp; return OK; } void SortList(List head){//冒泡排序  Node* p = NULL; Node* q = NULL; Node* t = NULL; if(head-\u0026gt;next == NULL){ return ; } for ( p = head-\u0026gt;next; p != NULL; p = p-\u0026gt;next){ for ( q = head-\u0026gt;next; q-\u0026gt;next != NULL; q = q-\u0026gt;next){ if(q-\u0026gt;data \u0026gt; q-\u0026gt;next-\u0026gt;data){ SwapElem(\u0026amp;q-\u0026gt;data, \u0026amp;q-\u0026gt;next-\u0026gt;data); } } } } 无头结点链表的功能实现就不在此赘述，所有源码都在Github ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/","summary":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。\n每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。\n在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。\n头指针和头节点 基本概念 头指针 通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。\n头节点 在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。\n[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。\n空链表 单链表 引入头结点的优势 链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。\n优势1：第一个位置的插入删除特别方便 若使用头结点，则第1个位置的插入和删除都是对p—\u0026gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：\n插入操作如下  p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s;  删除操作如下  p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q);   若没有头结点，在第1个位置插入或删除时，需要动头指针。\n插入操作如下  判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。  删除操作如下  判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—\u0026gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q); return PtrL  优势2：统一空表和非空表的处理 若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。","title":"单链表"},{"content":"概念 具有 一对一 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）\n#include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;time.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int Status; typedef int elem; typedef struct Sqlist{ elem *e;//存储空间的及地址  int length;//长度 }Sqlist; 功能的实现 顺序表的初始化 //数组的初始化 Status InitArray(Sqlist *L){ if(L-\u0026gt;e) {//判断指针是否为空  free(L-\u0026gt;e); L-\u0026gt;e = NULL; } L-\u0026gt;e = (elem*)malloc(sizeof(int) * MAXSIZE);//申请capacity大小的空间  if(L-\u0026gt;e == NULL){ printf(\u0026#34;内存分配失败!\\n\u0026#34;);//判断内存分配是否成功  exit(0); } L-\u0026gt;length = 0; return OK; } 元素的添加 //添加元素 Status PushBackArray(Sqlist *L,elem value){ if(L-\u0026gt;e == NULL){ printf(\u0026#34;请初始化顺序表\\n\u0026#34;); return ERROR; } if(L-\u0026gt;length == MAXSIZE) { return ERROR; } L-\u0026gt;e[L-\u0026gt;length] = value; ++L-\u0026gt;length; return OK; } 元素的插入 //插入 Status InsertArray(Sqlist *L,int index,elem value){ if(index \u0026gt; L-\u0026gt;length +1 || index \u0026lt; 1){ return ERROR; } for (int i = L-\u0026gt;length; i \u0026gt;= index; i--) { L-\u0026gt;e[i] = L-\u0026gt;e[i - 1]; } L-\u0026gt;e[index] = value; ++L-\u0026gt;length; return OK; } 元素的查找 //根据位置查找 elem FindByIndex(Sqlist* L,int index){ return L-\u0026gt;e[index]; } //根据值查找 Status FindByValue(Sqlist* L,elem value){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ if(L-\u0026gt;e[i] == value){ return i; } } return -1; } 元素的删除 //根据值删除 Status RemoveByValue(Sqlist* L,elem value){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ if(L-\u0026gt;e[i] == value){ for (; i \u0026lt; L-\u0026gt;length; i++) { L-\u0026gt;e[i - 1] = L-\u0026gt;e[i]; } --L-\u0026gt;length; return OK; } } } //根据位置删除 Status RemoveByIndex(Sqlist* L,int index){ if (index \u0026gt; L-\u0026gt;length + 1 || index \u0026lt; 1) { return ERROR; } for (int i = index; i \u0026lt; L-\u0026gt;length; i++) { L-\u0026gt;e[i - 1] = L-\u0026gt;e[i]; } --L-\u0026gt;length; return OK; } 元素的清空 //清空 Status CleanArray(Sqlist *L){ if(L-\u0026gt;e == NULL) { printf(\u0026#34;未初始化\\n\u0026#34;); return ERROR; } L-\u0026gt;length = 0; return OK; } 线性表的销毁 //销毁 Status FreeArray(Sqlist* L){ if(L-\u0026gt;e != NULL){ free(L-\u0026gt;e); L-\u0026gt;e = NULL; } L-\u0026gt;length = 0; return OK; } 获取当前长度 //长度 int GetLength(Sqlist* L){ if(L-\u0026gt;e == NULL) return -1; return L-\u0026gt;length; } 判断是否为空 //判断是否为空 Status IsEmptyArray(Sqlist *L){ return L-\u0026gt;length = 0; } 顺序表的合并 //合并 Status CombineArray(Sqlist *L1,Sqlist *L2){ if (L1-\u0026gt;length + L2-\u0026gt;length \u0026gt; MAXSIZE) { printf(\u0026#34;空间不足，合并失败\\n\u0026#34;); return ERROR; } for (int i = 0; i \u0026lt; L2-\u0026gt;length; i++) { L1-\u0026gt;e[L1-\u0026gt;length + i] = L2-\u0026gt;e[i]; } L1-\u0026gt;length +=L2-\u0026gt;length; free(L2-\u0026gt;e); L2-\u0026gt;length = 0; return OK; } 顺序表的打印 //打印 void PrintArray(Sqlist* L){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ printf(\u0026#34;%d \u0026#34;,L-\u0026gt;e[i]); } printf(\u0026#34;\\n\u0026#34;); } void test(){//测试  Sqlist L,L2; /******************************/ /********初始化及添加元素********/ /******************************/ InitArray(\u0026amp;L);//初始化顺序表  InitArray(\u0026amp;L2); //srand(time(NULL));  for(int i = 0; i \u0026lt; 10; i++){//赋值  PushBackArray(\u0026amp;L,i); PushBackArray(\u0026amp;L2,i); } printf(\u0026#34;初始化...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /************插入元素***********/ /******************************/ InsertArray(\u0026amp;L,5,100);//插入元素  printf(\u0026#34;插入元素...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /************查找元素***********/ /******************************/ printf(\u0026#34;查找元素...\\n\u0026#34;); printf(\u0026#34;%d \u0026#34;,FindByIndex(\u0026amp;L,10));//根据位置查找  printf(\u0026#34;%d \u0026#34;,FindByValue(\u0026amp;L,4));//根据值查找  /******************************/ /************删除元素***********/ /******************************/ RemoveByIndex(\u0026amp;L,3);//根据位置删除  RemoveByValue(\u0026amp;L,9);//根据值删除  printf(\u0026#34;删除元素...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********合并顺序表**********/ /******************************/ CombineArray(\u0026amp;L,\u0026amp;L2);//合并  printf(\u0026#34;合并顺序表...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********清空顺序表**********/ /******************************/ CleanArray(\u0026amp;L);//清空  printf(\u0026#34;清空顺序表...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********销毁顺序表**********/ /******************************/ FreeArray(\u0026amp;L);//销毁  printf(\u0026#34;销毁顺序表...\\n\u0026#34;); printf(\u0026#34;%d\u0026#34;,PushBackArray(\u0026amp;L,1)); } int main(){ test(); system(\u0026#34;pause\u0026#34;); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","summary":"\u003ch3 id=\"概念\"\u003e概念\u003c/h3\u003e\n\u003cp\u003e具有 \u003cem\u003e一对一\u003c/em\u003e 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define MAXSIZE 100\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define OK 1\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define ERROR 0\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Status;\n\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e elem;\n\n\n\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e Sqlist{\n    elem \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ee;\u003cspan style=\"color:#75715e\"\u003e//存储空间的及地址\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e length;\u003cspan style=\"color:#75715e\"\u003e//长度\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}Sqlist;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"顺序表"},{"content":"数据 所有能够输入到计算机中的去的描述客观事物的符号\n数据元素 数据的基本单位，也称结点或记录\n数据结构 相互之间存在一种或多种特定关系的数据元素的集合\n逻辑结构和存储结构 逻辑结构 数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。\n1.集合 数据元素间除同属于一个集合外，无其他关系 集合中的元素是离散的、无序的、相互之间没有关系的\n2.线性结构 一个对一个  线性表 栈 队列 线性结构像是珠子穿在一根线上，不会分叉，有且只有唯一的开始和结束  3.树形结构 一个对多个 树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支。树枝和树枝之间是不相交的。\n 树  4.图形结构 图形结构就像我们经常见到的地图，任何一个结点都可能和其它结点有关系，就像一张错综复杂的网。\n存储结构 存储结构是数据元素及其关系在计算机中的存储方式。\n1.顺序结构 顺序存储在计算机内的存储位置是连续的，可以快速定位第几个元素的问题。中间不允许有空，所以插入、删除时需要移动大量元素。\n2.链式结构 链式存储就像一个铁链子，一环扣一环才能连在一起。每个结点除了数据域，还有一个指针域，记录下一个元素的存储地址。\n3.散列机构 4.索引结构 算法复杂性 时间复杂度 程序运行所需的时间\n 常数阶 O(1) O(n) O(n²) O(log(n))-二分查找 O(nlogn)-快排  递归时间复杂度 O(T * depth) T是每一次递归的时间复杂度\n最好最坏情况时间复杂度 平均时间复杂度 空间复杂度 程序运行所需的空间\n主要分为两部分：\n 固定部分：指令空间、数据空间（静态空间） 可变空间：动态分配的空间  S(n) = O(f(n))\n","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003ch3 id=\"数据\"\u003e数据\u003c/h3\u003e\n\u003cp\u003e所有能够输入到计算机中的去的描述客观事物的符号\u003c/p\u003e\n\u003ch3 id=\"数据元素\"\u003e数据元素\u003c/h3\u003e\n\u003cp\u003e数据的基本单位，也称结点或记录\u003c/p\u003e\n\u003ch3 id=\"数据结构\"\u003e数据结构\u003c/h3\u003e\n\u003cp\u003e相互之间存在一种或多种特定关系的数据元素的集合\u003c/p\u003e","title":"数据结构概括"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]