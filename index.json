[{"content":"做题笔记。\n2021.12.12 23:15 \u0026ndash; 2021.12.13 01:15\nA. Life of a Flower 题意 给花浇水，纯模拟，有以下要求：\n 连续两天不浇水，花会死。 如果浇水，花长高1cm。 连续两天浇水，花长高5cm而非1cm。  思路 纯模拟，依次处理每天的浇水情况就可以。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define int long long #define lson 2 * i #define rson 2 * i + 1 #define LS l, mid, lson #define RS mid + 1, r, rson #define UP(i, x, y) for (int i = x; i \u0026lt; y; i++) #define DOWN(i, x, y) for (int i = x; i \u0026gt; y; i--) #define MS(a, x) memset(a, x, sizeof(a)) #define GCD(x, y) __gcd(x, y) #define INF 0x3f3f3f3f #define EPS 1e-8 #define MOD 1e9 + 7 const int N = 1e5 + 5; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } /*********Solve**********/ vector\u0026lt;int\u0026gt; v; void solve() { int n = read(); v.clear(); UP(i, 0, n) { v.push_back(read()); } int sum = 1 + v[0]; UP(i, 1, n) { if (!v[i] \u0026amp;\u0026amp; !v[i - 1]) { printf(\u0026#34;-1\\n\u0026#34;); return; } if (v[i]) { if (v[i - 1]) { sum += 5; } else { sum += 1; } } } cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } main() { // ios::sync_with_stdio(0);  int t = read(); // int t = 1;  while (t--) { solve(); } return 0; }   B. Array Eversion 题意 给出数组a，进行以下操作：\n令$x=a_n$，进行变换，使得x左侧的所有元素都小于x，右侧的所有元素都大于x，并且不能改变元素的相对位置。\n进行k次操作之后，数组将不会改变。\n求最小的k。\n思路 先以这个样例为例进行分析(2,5,1,4,3)，变换一次之后(2,1,3,5,4)，再进行一次变换(2,1,3,4,5)，此时无需再次进行变换。可以发现，如果最后一位并不是最大值时，则可以继续进行变换。\n既然每次都要求以数组的最后一个数为基准，那可以从后往前遍历，不断寻找符合条件的x，如果a[i]\u0026gt;x，则说明又可以进行一次变换。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define int long long #define lson 2 * i #define rson 2 * i + 1 #define LS l, mid, lson #define RS mid + 1, r, rson #define UP(i, x, y) for (int i = x; i \u0026lt; y; i++) #define DOWN(i, x, y) for (int i = x; i \u0026gt; y; i--) #define MS(a, x) memset(a, x, sizeof(a)) #define GCD(x, y) __gcd(x, y) #define INF 0x3f3f3f3f #define EPS 1e-8 #define MOD 1e9 + 7 const int N = 1e5 + 5; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } /*********Solve**********/ vector\u0026lt;int\u0026gt; v; void solve() { int n = read(); v.clear(); UP(i, 0, n) { v.push_back(read()); } int ans = 0; int x = v[n - 1]; DOWN(i, n - 1, -1) { if (v[i] \u0026gt; x) { ans++; x = v[i]; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } main() { // ios::sync_with_stdio(0);  int t = read(); // int t = 1;  while (t--) { solve(); } return 0; }   C. Minimize Distance 题意 在一条坐标轴上搬运货物，n为需要送货的地点，k为一次可以携带的货物数量，每次都是从原点出发，送完最后一次货物无需回到原点，求最小路程。\n思路 由于给出的坐标有正有负，都是从原点出发，所以可以将正负两边拆成两次来考虑，求出总和之后，再将正负两边最大的一个坐标减去。\n模拟貌似有点问题，上DP。\n考虑x\u0026gt;0的情况，将坐标升序排序，设$dp_i$为送完前i个点的最小路程，则有转移方程$dp_i=dp_{i-k}+2*x_i$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define int long long #define lson 2 * i #define rson 2 * i + 1 #define LS l, mid, lson #define RS mid + 1, r, rson #define UP(i, x, y) for (int i = x; i \u0026lt; y; i++) #define DOWN(i, x, y) for (int i = x; i \u0026gt; y; i--) #define MS(a, x) memset(a, x, sizeof(a)) #define GCD(x, y) __gcd(x, y) #define INF 0x3f3f3f3f #define EPS 1e-8 #define MOD 1e9 + 7 const int N = 1e5 + 5; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } /*********Solve**********/ multiset\u0026lt;int\u0026gt; v1; multiset\u0026lt;int\u0026gt; v2; void solve() { int n = read(), k = read(); v1.clear(), v2.clear(); int m = 0; UP(i, 0, n) { int temp = read(); if (temp \u0026gt;= 0) v1.insert(temp); else v2.insert(abs(temp)); m = max(m, abs(temp)); } int sum = 0; auto count = [\u0026amp;](multiset\u0026lt;int\u0026gt; v) { int sz = v.size(); int dp[sz + 1]; dp[0] = 0; UP(i, 1, sz + 1) { dp[i] = (i - k \u0026gt; 0 ? dp[i - k] : 0) + 2 * (*v.begin()); v.erase(v.begin()); } sum += dp[sz]; }; count(v1), count(v2); cout \u0026lt;\u0026lt; sum - m \u0026lt;\u0026lt; endl; } main() { // ios::sync_with_stdio(0);  int t = read(); // int t = 1;  while (t--) { solve(); } return 0; }   ","permalink":"https://www.niuwx.cn/posts/algorithm/codeforces-round-#759-div.-2/","summary":"\u003cp\u003e做题笔记。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2021.12.12 23:15  \u0026ndash;  2021.12.13  01:15\u003c/strong\u003e\u003c/p\u003e","title":"Codeforces Round #759 (Div. 2)"},{"content":"做题笔记。\n2021.12.01 22:35 \u0026ndash; 2021.12.02 0.30\nA. Long Comparison 题意 给出两个数字，这两个数字都遵循特定的格式，在$x$末尾追加$p$个0，比较这两个数的大小。\n思路 固定x的长度，比较p即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define INF 0x3f3f3f3f #define int long long #define maxn 1e5 + 5  int x[3]; int p[3]; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } void read(int i) { x[i] = read(), p[i] = read(); while (x[i] \u0026lt; 1e6) { x[i] *= 10; p[i]--; } } void solve() { read(1); read(2); if (p[1] \u0026lt; p[2]) { cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; } else if (p[1] \u0026gt; p[2]) { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; } else { if (x[1] \u0026lt; x[2]) cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026#34; \u0026lt;\u0026lt; endl; else if (x[1] \u0026gt; x[2]) cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; endl; } } main() { int t = read(); while (t--) { solve(); } return 0; }   B. Absent Remainder 题意 给出数组元素数量和一个数组，输出[n/2]组a[i],a[j]，需满足：\n $a[i] \\ne a[j]$ $a_i\\mod a_j \\ne a_i(i = 1\u0026hellip;n)$  思路 排序之后找到最小元素，其余元素对其取模不可能等于数组中其他元素。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define INF 0x3f3f3f3f #define int long long #define maxn 1e5 + 5  int read() { int x; cin \u0026gt;\u0026gt; x; return x; } void solve() { int n = read(); vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; n; i++) v.push_back(read()); sort(v.begin(), v.end()); int cnt = 0; for (int i = 1; i \u0026lt; v.size(); i++) { cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; v[0] \u0026lt;\u0026lt; endl; if (++cnt == n / 2) return; } } main() { int t = read(); while (t--) { solve(); } return 0; }   C. Poisoned Dagger 题意 恶龙有h滴血，勇士丢出匕首攻击恶龙，匕首不会直接对恶龙造成伤害，但是有中毒效果，在接下来的harm秒内，恶龙每秒掉1滴血。中毒效果不会叠加。\n例如：k=4，勇士在2，4，10秒时攻击恶龙(10滴血)。第2秒，第3秒各掉一滴血，到了第4秒，效果刷新，每秒掉一滴血到第7秒\n，第8秒，第9秒不掉血，从第10秒开始掉血，一直到第 13秒，恶龙死亡。\n给出勇士攻击次数以及攻击的时间点，恶龙的血量，求最小的harm。\n思路 二分。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define INF 0x3f3f3f3f #define int long long #define maxn 1e5 + 5  int n; int h; vector\u0026lt;int\u0026gt; v; int read() { int x; cin \u0026gt;\u0026gt; x; return x; } bool judge(int mid) { int sum = mid; for (int i = 0; i \u0026lt; v.size(); i++) { sum += min(v[i], mid); } return sum \u0026gt;= h; } void solve() { n = read(), h = read(); v.clear(); vector\u0026lt;int\u0026gt; w; for (int i = 0; i \u0026lt; n; i++) { w.push_back(read()); if (i) v.push_back(w[i] - w[i - 1]); } int l = 1, r = 1e18; while (l + 1 \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (judge(mid)) r = mid; else l = mid; } if (judge(l)) cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; } main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { solve(); } return 0; }   ","permalink":"https://www.niuwx.cn/posts/algorithm/educational-codeforces-round-118-rated-for-div.-2/","summary":"\u003cp\u003e做题笔记。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2021.12.01 22:35  \u0026ndash;  2021.12.02  0.30\u003c/strong\u003e\u003c/p\u003e","title":"Educational Codeforces Round 118 (Rated for Div. 2)"},{"content":"做题笔记。\n2021.11.28 22:35 \u0026ndash; 2021.11.29 1:00\n第一次参加Codeforces的比赛，太菜了\u0026hellip;\nA. Divide and Multiply 题意 据说是500分的题，难度不是很大。大概题意是给一组数，每次操作可以将一个数（必须是偶数）除2，同时将另一个数乘2，求执行最佳操作之后数组和的最大值。\n思路  找到数组元素a[i]因式分解后2的个数$t_i$，$a[i] /= 2*t_i$，处理之后得到了2的个数和t，且所有数组元素都为奇数。 找到处理后的所有数组元素的最大值，乘$2^t$即可得到最大项，加上其余数组元素即可得到最大数组和。  代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 25; int n; ll arr[maxn]; ll fast(ll a, ll base, ll power) { ll ans = a; while (power) { if (power \u0026amp; 1) ans *= base; base *= base; power \u0026gt;\u0026gt;= 1; } return ans; } int main(int argc, char const *argv[]) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int max = 0; ll power = 0; ll ans = 0; //long long 防爆  for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); while (arr[i] % 2 == 0) { arr[i] /= 2; power++; } if (arr[i] \u0026gt; arr[max]) max = i; ans += arr[i]; } ans += fast(arr[max], 2, power) - arr[max];//猥琐一点加了快速幂防止超时  cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   B. William the Vigilant 题意 给一个字符串s，只包含字符a、b、c，再给定一个数字q，接下来给出q组操作(pos,c)，每次操作将字符串s中第pos个字符变成给出的字符c，然后输出改变后的字符串还需要最少修改几个字符使得这个字符串没有子串abc。\n思路 这题暴力遍历会超时。可以提前统计字串数量，每一次操作分情况讨论abc字串的数量变化。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int N = 1e5 + 5; int n, q; string s; int pos; char c; int ans; void init() { ans = 0; for (int i = 0; i \u0026lt; n; i++) if (i + 2 \u0026lt; n \u0026amp;\u0026amp; s[i] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[i + 2] == \u0026#39;c\u0026#39;) ans++; } void find() { pos = pos - 1; if (s[pos] == \u0026#39;a\u0026#39;) { if (s[pos + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos + 2] == \u0026#39;c\u0026#39;) if (c != \u0026#39;a\u0026#39;) ans--; if (c == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;c\u0026#39;) ans++; if (c == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; s[pos - 2] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;b\u0026#39;) ans++; } if (s[pos] == \u0026#39;b\u0026#39;) { if (s[pos - 1] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;c\u0026#39;) if (c != \u0026#39;b\u0026#39;) ans--; if (c == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos + 2] == \u0026#39;c\u0026#39;) ans++; if (c == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; s[pos - 2] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;b\u0026#39;) ans++; } if (s[pos] == \u0026#39;c\u0026#39;) { if (s[pos - 2] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;b\u0026#39;) if (c != \u0026#39;c\u0026#39;) ans--; if (c == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos + 2] == \u0026#39;c\u0026#39;) ans++; if (c == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;c\u0026#39;) ans++; } s[pos] = c; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void solve() { scanf(\u0026#34;%d %c\u0026#34;, \u0026amp;pos, \u0026amp;c); find(); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); cin \u0026gt;\u0026gt; s; init(); while (q--) { solve(); } return 0; }   C. Complex Market Analysis 题意 题目比较好理解，给定n, e和一个含n个元素的数组。\n(i,k)需要满足以下条件：\n $1\u0026lt;=i,k$ $i+e*k\u0026lt;=n$ $a_i \\cdot a_{i+e} \\cdot a_{i+2e} \\cdot\u0026hellip; \\cdot a_{i+ke}$ 是一个质数。  求出满足条件的(i,k)的对数。\n思路 考虑到第三个条件的限制，需要满足多项式的每一项有且只有一个质数，其他项都为1。刚开始做就是暴力遍历，但是超时，需要继续剪枝。考虑到有且只有一个质数，那么可以从质数下手，去找满足条件的1，这样消耗就会小很多。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 1e6 + 5; int n, e; int arr[maxn]; int prime[maxn]; void isprime() { for (int i = 1; i \u0026lt; maxn; i++) prime[i] = 1; prime[1] = 0; for (int i = 2; i \u0026lt; maxn; i++) { if (prime[i] == 1) for (int j = 2; j * i \u0026lt; maxn; j++) { prime[i * j] = 0; } } } void solve() { ll cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { //******************************  if (prime[arr[i]] == 1) { //找到质数  ll l = 0, r = 0; for (int t = i + e; t \u0026lt;= n; t += e) {//向右找1  if (arr[t] == 1) r++; else break; } for (int t = i - e; t \u0026gt;= 1; t -= e) {//向左找1  if (arr[t] == 1) l++; else break; } cnt += l + r + l * r; //统计答案  } //******************************  } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } int main() { isprime();//数据范围1e6，质数筛打表节约判断时间  int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;e); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } solve(); } return 0; }   统计答案这一步，这个质数左边有l个1，右边有r个1。\n 只考虑左边及质数，共l种情况。 只考虑质数及右边，共r种情况。 考虑左边+质数+右边，共l*r种情况。  D. Social Network 题意 共n个人，d个关系对(a,b)，每个关系对可以介绍a和b两个人认识， 每次介绍之后输出熟人最多的数量。\n题目有个坑点，在分析第二个样例的时候可以发现第四次操作，1、4连接之后，答案明明应该是3，但是正确答案却是4。\n题目中还有一句话需要注意：\n即如果1、4已经认识，那么就把1或4介绍给另一个大连通块认识。\n思路 并查集，先检查是否在同一连通块，如果在同一连通块，那就与另一个大连通块连通。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 1005; int n, d; int parent[maxn]; int temp[maxn]; int sz[maxn]; void init() { for (int i = 1; i \u0026lt;= n; i++) { parent[i] = i; sz[i] = 1; } } int find(int x) { return x == parent[x] ? x : parent[x] = find(parent[x]); } bool merge(int x, int y) { x = find(x); y = find(y); if (x != y) { parent[x] = y; sz[y] += sz[x]; return true; } return false; } int main(int argc, char const *argv[]) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;d); init(); int cnt = 1;//大连通块数量  for (int i = 0, x, y; i \u0026lt; d; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (!merge(x, y)) cnt++; vector\u0026lt;int\u0026gt; temp; for (int i = 1; i \u0026lt;= n; i++) if (parent[i] == i) temp.push_back(sz[i]); sort(temp.rbegin(), temp.rend()); cout \u0026lt;\u0026lt; accumulate(temp.begin(), temp.begin() + cnt, 0) - 1 \u0026lt;\u0026lt; endl; } return 0; }   ","permalink":"https://www.niuwx.cn/posts/algorithm/deltix-round-autumn-2021-div.-1-+-div.-2/","summary":"\u003cp\u003e做题笔记。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2021.11.28 22:35  \u0026ndash;  2021.11.29  1:00\u003c/strong\u003e\u003c/p\u003e","title":"Deltix Round, Autumn 2021 (Div. 1 + Div. 2)"},{"content":"本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\n简单示例 应用代码 以这段简单的go web代码为例进行介绍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, HandleHello) server := \u0026amp;http.Server{ Addr: \u0026#34;:9090\u0026#34;, } fmt.Println(\u0026#34;Server startup...\u0026#34;) if err := server.ListenAndServe(); err != nil { fmt.Printf(\u0026#34;Server startup failed, err:%v\\n\u0026#34;, err) } } func HandleHello(w http.ResponseWriter, _ *http.Request) { w.Write([]byte(\u0026#34;Hello World\u0026#34;)) }   编写Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  FROMgolang:alpine# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .# 声明服务端口EXPOSE9090# 启动容器时运行的命令CMD [\u0026#34;/app\u0026#34;]  构建镜像 使用命令构建镜像。\n1  docker build . -t goweb   使用镜像 1  docker run -p 9090:9090 --name goweb-app goweb   使用-p来映射端口，这里容器中的应用需要在9090端口上运行，将其映射到主机的9090端口。也可以将其映射到其他端口，例如-p 8080:9090。\n分段构建 在编译Go程序之后，我们得到了一个可执行的二进制文件，在最终的镜像中我们是不需要go编译器的，只需要一个可以运行二进制文件的容器即可。所以可以通过分段构建，第一步编译出二进制可执行文件，第二步将该可执行文件放进可以运行的环境即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  FROMgolang:alpine AS builder# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .#################### 最终的小镜像###################FROMscratch# 从builder镜像中把/app 拷贝到当前目录COPY --from=builder /build/app /# 需要运行的命令ENTRYPOINT [\u0026#34;/app\u0026#34;]  通过分段构建，我们就得到了一个体积非常小的镜像。\n静态资源的拷贝 如果需要部署的程序还需要用到静态资源，那么还需要将静态资源拷贝到镜像中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  FROMgolang:alpine AS builder# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .#################### 最终的小镜像###################FROMscratchCOPY /templates /templatesCOPY /static /static# 从builder镜像中把/app 拷贝到当前目录COPY --from=builder /build/app /# 需要运行的命令ENTRYPOINT [\u0026#34;/app\u0026#34;]  ","permalink":"https://www.niuwx.cn/posts/go/docker_go/","summary":"\u003cp\u003e本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\u003c/p\u003e","title":"Docker部署Go Web应用"},{"content":"本文以Oh-my-zsh为例，Oh-my-post同样适用。\n如图，使用Windows Terminal连接服务器使用Zsh命令行时，会出现乱码，导致主题无法正常显示。\n解决方法 安装Nerd Fonts，下载喜欢的字体然后右键选择“为所有用户安装”，打开Windows Terminal修改settings.json中的\u0026quot;fontFace\u0026quot;项为Nerd字体即可，注意要更改为其显示的正式名称。\n","permalink":"https://www.niuwx.cn/posts/zsh/zsh/","summary":"\u003cp\u003e本文以Oh-my-zsh为例，Oh-my-post同样适用。\u003c/p\u003e","title":"Windows oh-my-zsh 命令行出现乱码的原因及解决办法"},{"content":"This is a test for hugo.\n1 2 Test\n1 2 3 4 5 6 7  package main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;Hello World\u0026#34;) }   ","permalink":"https://www.niuwx.cn/posts/hello-test/","summary":"\u003cp\u003e\u003cstrong\u003eThis is a test for hugo.\u003c/strong\u003e\u003c/p\u003e","title":"Hello Test"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]