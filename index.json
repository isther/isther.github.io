[{"content":"初识进程和线程 认识进程 在Linux系统中，每一个进程都有自己的ID，就如同人的身份证一样。Linux中有一个数据类型pid_t，它定义了进程的ID。\nfork() 首先看下如何创建新的进程，这里需要用到fork()函数，其返回值类型为pid_t。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/unistd.h\u0026gt;void get_pid() {  pid_t pid = fork();  if (pid \u0026lt; 0) {  printf(\u0026#34;fork error\\n\u0026#34;);  exit(1);  } else if (pid \u0026gt; 0) {  printf(\u0026#34;parent: the pid is %d\\n\u0026#34;, pid);  while (1)  ;  } else {  printf(\u0026#34;child: this pid is %d\\n\u0026#34;, pid);  while (1)  ;  } } int main() {  get_pid();  return 0; }   执行结果：\n1 2  parent: the pid is 20580 child: this pid is 0   执行结果中有两条输出，分别是父进程和子进程。\n通过命令行执行htop找到对应的进程，我们可以发现父子进程都有其特定的pid，那么为什么程序会输出0呢？\n实际上，在调用fork()函数之后，程序创建了一个子进程，程序本身成为了父进程。\n而fork()的返回值代表什么意义呢？\n 负数：创建子进程失败。 零：在子进程中，fork()返回0 正数：在父进程中，fork()返回子进程的pid  至此，以上的疑惑也就迎刃而解了，在这里介绍两个进程相关的函数：\n getpid()：获取当前进程的pid getppid()：获取当前进程的父进程的pid  接下来再看这段程序：\n增加了一个全局变量和一个函数内部的局部变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/unistd.h\u0026gt;int global_var = 2; void get_pid() {  pid_t pid = fork();  int var = 5;  if (pid \u0026lt; 0) {  printf(\u0026#34;fork error\\n\u0026#34;);  exit(1);  } else if (pid \u0026gt; 0) {  printf(\u0026#34;parent: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var);  exit(0);  } else {  global_var--;  var++;  printf(\u0026#34;child: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var);   exit(0);  } }  int main() {  get_pid();  return 0; }   执行结果：\n1 2  parent: this pid is 22982, global_var = 2, var = 5 child: this pid is 0, global_var = 1, var = 6   在子进程中，global_var与var分别执行的加减操作，但是在父进程中，这两个变量的值都未发生改变，这是为什么呢？\n原因在于：执行fork()函数时，子进程复制了父进程的所有资源，包括内存等等。因此，父子进程属于不同的内存空间，那么子进程中变量发生改变时，父进程中的变量必然不会改变。\nvfork() 除了fork()函数，还有一个vfork()函数，同样是系统调用函数，用来创建子进程。但是这二者是有区别的：vfork()函数在创建子进程时，父子进程共享地址空间。因此子进程中修改的全局变量在父进程中也会被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;sys/unistd.h\u0026gt;int global_var = 2; void get_pid() {  pid_t pid = vfork();  int var = 5;  printf(\u0026#34;pid = %d\\n\u0026#34;, getpid());  printf(\u0026#34;global_var = %d, var = %d\\n\u0026#34;, global_var, var);  if (pid \u0026lt; 0) {  printf(\u0026#34;fork error\\n\u0026#34;);  exit(1);  } else if (pid \u0026gt; 0) {  printf(\u0026#34;parent: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var);  exit(0);  } else {  global_var--;  var++;  printf(\u0026#34;child: this pid is %d, global_var = %d, var = %d\\n\u0026#34;, pid, global_var, var);  exit(0);  } }  int main() {  get_pid();  return 0; }   执行结果：\n1 2 3 4 5 6  pid = 25371 global_var = 2, var = 5 child: this pid is 0, global_var = 1, var = 6 pid = 25370 global_var = 1, var = 5 parent: this pid is 25371, global_var = 1, var = 5   execv() 在fork()与vfork()中，子进程与父进程都运行同样的代码。如果需要子进程执行不同的操作，就要用到execv()函数了\n1 2 3 4 5 6 7  //parent.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;int main(int argc, char* argv[]) {  execv(\u0026#34;child\u0026#34;, argv);  return 0; }   1 2 3 4 5 6 7 8 9 10  //child.c #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]) {  puts(\u0026#34;welcome!\u0026#34;);  for (int i = 0; i \u0026lt; argc; i++) {  puts(argv[i]);  }  return 0; }   分别编译两个c文件，执行parent.c编译得到的可执行文件：./parent 1 2 3。\n执行结果：\n1 2 3 4 5  welcome! ./parent 1 2 3   进程等待 进程等待就是同步父子进程。可以通过调用wait()函数来实现。\nwait()函数的工作原理是首先判断子进程是否存在， 如果创建失败，子进程不存在，那么就直接退出进程，并提示相关错误信息。如果创建成功，wait()函数将父进程挂起，知道子进程结束，并返回结束的状态和最后结束的子进程的pid。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;wait.h\u0026gt; void exit_s(int status) {  if (WIFEXITED(status)) {  printf(\u0026#34;normal exist, status = %d\\n\u0026#34;, WEXITSTATUS(status));  } else if (WIFSIGNALED(status)) {  printf(\u0026#34;signal exit! status = %d\\n\u0026#34;, WTERMSIG(status));  } }  void wait_test() {  pid_t pid_a;  int status;  int ret;   pid_a = fork();  if (pid_a \u0026lt; 0) {  printf(\u0026#34;child process error\\n\u0026#34;);  exit(0);  } else if (pid_a \u0026gt; 0) {  printf(\u0026#34;the pid of parent is %d\\n\u0026#34;, getpid());  printf(\u0026#34;wait for child ...\\n\u0026#34;);  int pid_child = wait(\u0026amp;status);  if (pid_child \u0026gt; 0) {  printf(\u0026#34;i catch a child process with pid of %d\\n\u0026#34;, pid_child);  }  exit_s(status);  } else {  printf(\u0026#34;the pid of child is %d\\n\u0026#34;, getpid());  sleep(3);  exit(2);  } }  int main() {  wait_test();  return 0; }   执行结果：\n1 2 3 4 5  the pid of parent is 46045 wait for child ... the pid of child is 46046 i catch a child process with pid of 46046 normal exist, status = 2   在子进程中调用sleep()函数，睡眠3秒，只有子进程完成睡眠，才能正常退出并被父进程捕捉到。在此期间父进程会继续等待下去。在wait函数中会将子进程的状态保存到status中。\n在处理status的exit_s()函数中，调用了几个宏：\n WIFEXITED：当子进程正常退出时，返回真值 WEXITSTATUS：返回子进程正常退出时的状态 WTERMSIG：用于子进程被信号终止的情况  如果在程序执行过程中子进程异常退出，会是怎样的情况呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;wait.h\u0026gt; void exit_s(int status) {  if (WIFEXITED(status)) {  printf(\u0026#34;normal exist, status = %d\\n\u0026#34;, WEXITSTATUS(status));  } else if (WIFSIGNALED(status)) {  printf(\u0026#34;signal exit! status = %d\\n\u0026#34;, WTERMSIG(status));  } }  void wait_test() {  pid_t pid_a;  int status;  int ret;   pid_a = fork();  if (pid_a \u0026lt; 0) {  printf(\u0026#34;child process error\\n\u0026#34;);  exit(0);  } else if (pid_a \u0026gt; 0) {  printf(\u0026#34;the pid of parent is %d\\n\u0026#34;, getpid());  printf(\u0026#34;wait child ...\\n\u0026#34;);  int pid_child = wait(\u0026amp;status);  if (pid_child \u0026gt; 0) {  printf(\u0026#34;i catch a child process with pid of %d\\n\u0026#34;, pid_child);  }  exit_s(status);  } else {  printf(\u0026#34;the pid of child is %d\\n\u0026#34;, getpid());  // sleep(3);  pid_t pid = getpid();  kill(pid, 9);  exit(2);  } }  int main() {  wait_test();  return 0; }   执行结果：\n1 2 3 4 5  the pid of parent is 46749 wait child ... the pid of child is 46750 i catch a child process with pid of 46750 signal exit! status = 9   线程 需要先了解一下进程和线程的区别：\n 进程是资源分配的最小单位，每个进程都占有独立内存空间。 线程是程序执行的最小单位，多个线程共享同一个内存空间。 一个进程由几个线程组成，线程与同属一个进程的其他线程共享当前进程拥有的全部资源。  那么，线程有哪些优势呢？\n 线程不需要额外的内存申请 线程共享进程内的数据，访问数据方便，而进程则需要通过通信的方式进行。  在linux下，进程使用ps命令查看，线程则通过top命令来查看。还可以通过top -p pid来查看某个进程内的线程。\n先看一个创建进程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include \u0026lt;pthread.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; void *thread1(void) {  int i;  for (int i = 0; i \u0026lt; 5; i++) {  printf(\u0026#34;this is the first thread\\n\u0026#34;);  sleep(1);  } }  void *thread2(void) {  int i;  for (int i = 0; i \u0026lt; 5; i++) {  printf(\u0026#34;this is the second thread\\n\u0026#34;);  sleep(1);  } }  int main() {  int ret = 0;  pthread_t id1, id2;  pthread_create(\u0026amp;id1, NULL, (void *)thread1, NULL);  pthread_create(\u0026amp;id2, NULL, (void *)thread2, NULL);  pthread_join(id1, NULL);  pthread_join(id2, NULL);  return 0; }   在这里，thread1和thread2两个函数分别属于不同的线程。\npthread_t是线程的id。\npthread_create()是创建线程的函数，参数分别是：参数id，线程属性，线程运行函数的起始地址，运行函数的参数。\n注意，由于pthread并非Linux系统的默认库，而是POSIX线程库，所以在编译的时候需要加上-lpthread来显式链接该库：gcc -g main.c -lpthread。\n执行结果：\n1 2 3 4 5 6 7 8 9 10  this is the first thread this is the second thread this is the first thread this is the second thread this is the first thread this is the second thread this is the first thread this is the second thread this is the first thread this is the second thread   进程间通信 进程间的通信包括管道、共享内存、信号量通信、消息队列、套借口(socket)和全双工管道通信。\n管道 管道顾名思义，就如同水管一样，当水从水管的一端流向另一端的时候，水流是单方向的。某一时刻只能从单方向传递数据，不能双向传递，这种就是半双工模式。半双工模式只能一端写数据，一端读数据，先来看一个半双工的例子：\n 在父进程中通过pipe()函数创建一个管道，得到管道读端ppe[0]，写端ppe[1]。 在父进程中调用fork()产生一个子进程 在子进程中关闭ppe[0]，往ppe[1]中写入数据，在父进程中关闭ppe[1]，从ppe[0]中读取数据。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;wait.h\u0026gt; int pipe_test() {  int ppe[2];   if (pipe(ppe) == -1) {  perror(\u0026#34;not create a new process!\\n\u0026#34;);  return 1;  }   int pid = fork();  if (pid == 0) {  close(ppe[0]);  printf(\u0026#34;child process send message\\n\u0026#34;);   char *message = \u0026#34;happy new year!\\n\u0026#34;;  write(ppe[1], message, strlen(message));  } else {  close(ppe[1]);  sleep(2);  printf(\u0026#34;parent process receive message\\n\u0026#34;);  char message[100];  int line = read(ppe[0], message, 100);  write(STDOUT_FILENO, message, line);  wait(NULL);  exit(0);  }  return 0; }  int main() {  pipe_test();  return 0; }   执行结果：\n1 2 3  child process send message parent process receive message happy new year!   上面这个例子演示了单向通信，如果我们需要双向通信：父进程在读的同时也给子进程写。要实现这样的功能，就必须建立两个管道：一个管道从父进程流向子进程，一个管道从子进程流向父进程。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;wait.h\u0026gt; int pipe_test() {  int ppea[2], ppeb[2];   if (pipe(ppea) == -1 || pipe(ppeb) == -1) {  perror(\u0026#34;not create a new process!\\n\u0026#34;);  return 1;  }   int pid = fork();  if (pid \u0026lt; 0) {  perror(\u0026#34;not create a new process !\u0026#34;);  return 1;  } else if (pid == 0) {  close(ppea[0]);  printf(\u0026#34;child process send message\\n\u0026#34;);  char *message_send = \u0026#34;happy new year!\\n\u0026#34;;  write(ppea[1], message_send, strlen(message_send));   sleep(2);   close(ppeb[1]);  printf(\u0026#34;child process receive message\\n\u0026#34;);  char message_receive[100];  int line = read(ppeb[0], message_receive, 100);  write(STDOUT_FILENO, message_receive, line);  exit(0);  } else {  close(ppea[1]);  sleep(2);  printf(\u0026#34;parent process receive message\\n\u0026#34;);  char message_receive[100];  int line = read(ppea[0], message_receive, 100);  write(STDOUT_FILENO, message_receive, line);   close(ppeb[0]);  printf(\u0026#34;parent process send message\\n\u0026#34;);  char *message_send = \u0026#34;happy new year my child!\\n\u0026#34;;  write(ppeb[1], message_send, strlen(message_send));  exit(0);  }  return 0; }  int main() {  pipe_test();  return 0; }   执行结果：\n1 2 3 4 5 6  child process send message parent process receive message happy new year! parent process send message child process receive message happy new year my child!   命令管道 上个部分介绍了管道，然而管道只能在有关联的进程中进行通信，也就是父子进程之间。那如果不相关的两个进程间也需要进行通信，这里就需要用到命令管道了，通常称为FIFO。通过这个名称可以知道命令管道遵循先进先出的原则，与数据结构中的队列类似。\n创建一个命令管道有两种方法：\n 通过shell命令创建 通过函数创建命名管道  shell命令创建命名管道  首先通过mkfifo创建一个管道文件test：mkfifo test 通过cat ./test查看，此时，管道文件中没有任何数据 打开另一个终端，向FIFO中写入数据：echo \u0026quot;hello fifo\u0026quot; \u0026gt; ./test 再次通过cat ./test查看，将会得到之前写入的数据。  函数创建命名管道 下面通过c来实现命令管道：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //write.c #include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int mkfifo_write() {  int ppe = open(\u0026#34;./fifo\u0026#34;, O_RDWR);  printf(\u0026#34;write the message:\\n\u0026#34;);   char* message = \u0026#34;hello world\\n\u0026#34;;  write(ppe, message, strlen(message));  close(ppe); }  int main() {  mkfifo_write();  return 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //read.c #include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int mkfifo_read() {  char message[100];   int ppe = open(\u0026#34;./fifo\u0026#34;, O_RDWR);  printf(\u0026#34;read the message:\\n\u0026#34;);  int line = read(ppe, message, 100);  close(ppe);  write(STDOUT_FILENO, message, line); }  int main(int argc, char* argv[]) {  mkfifo_read();  return 0; }   编译后，开启两个终端，一个终端先执行./read，另一个终端再执行./write，第一个终端中就会显示发出的信息。\n","permalink":"https://www.niuwx.cn/posts/linux/linux_c_1/","summary":"\u003ch2 id=\"初识进程和线程\"\u003e初识进程和线程\u003c/h2\u003e\n\u003ch3 id=\"认识进程\"\u003e认识进程\u003c/h3\u003e\n\u003cp\u003e在Linux系统中，每一个进程都有自己的ID，就如同人的身份证一样。Linux中有一个数据类型pid_t，它定义了进程的ID。\u003c/p\u003e","title":"Linux C之进程"},{"content":"前段时间换了系统，开始使用Manjaro，但是驱动问题搞得很头疼，在这里记录一下解决双显卡(amd+nvidia)的显示问题。\n由于Manjaro自带了mhwd，所以下载驱动还是很方便的。但是下载了video-hybrid-amd-nvidia-prime之后，外界显示器会时常卡顿，切换到video-nvidia之后，笔记本的显示器又亮不了。\n需要使用optimus-manager。\n官方文档\n安装：yay -S optimus-manager\n配置：\n  sudo vim /etc/sddm.conf，找到DisplayCommand和DisplayStopCommand，行首加#注释。\n  sudo vim /etc/optimus-manager/optimus-manager.conf，添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [amd] DRI=3 driver=modesetting tearfree=  [intel] DRI=3 accel= driver=modesetting modeset=yes tearfree=  [nvidia] DPI=96 PAT=yes allow_external_gpus=no dynamic_power_management=no ignore_abi=no modeset=yes options=overclocking  [optimus] auto_logout=yes pci_power_control=no pci_remove=no pci_reset=no startup_auto_battery_mode=integrated startup_auto_extpower_mode=nvidia startup_mode=nvidia switching=none     sudo vim /etc/default/grub，在GRUB_CMDLINE_LINUX_DEFAULT中增加nvidia-drm.modeset=1。\n  grub-mkconfig \u0026amp;\u0026amp; update-grub\n  PS:启用外接显示器后若KDE无法使用桌面动画，建议安装optimus-manager-qt：yay -S optimus-manager-qt。\n","permalink":"https://www.niuwx.cn/posts/other/manjaro_amd_nvidia/","summary":"前段时间换了系统，开始使用Manjaro，但是驱动问题搞得很头疼，在这里记录一下解决双显卡(amd+nvidia)的显示问题。\n由于Manjaro自带了mhwd，所以下载驱动还是很方便的。但是下载了video-hybrid-amd-nvidia-prime之后，外界显示器会时常卡顿，切换到video-nvidia之后，笔记本的显示器又亮不了。\n需要使用optimus-manager。\n官方文档\n安装：yay -S optimus-manager\n配置：\n  sudo vim /etc/sddm.conf，找到DisplayCommand和DisplayStopCommand，行首加#注释。\n  sudo vim /etc/optimus-manager/optimus-manager.conf，添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  [amd] DRI=3 driver=modesetting tearfree=  [intel] DRI=3 accel= driver=modesetting modeset=yes tearfree=  [nvidia] DPI=96 PAT=yes allow_external_gpus=no dynamic_power_management=no ignore_abi=no modeset=yes options=overclocking  [optimus] auto_logout=yes pci_power_control=no pci_remove=no pci_reset=no startup_auto_battery_mode=integrated startup_auto_extpower_mode=nvidia startup_mode=nvidia switching=none     sudo vim /etc/default/grub，在GRUB_CMDLINE_LINUX_DEFAULT中增加nvidia-drm.","title":"Manjaro下双显卡笔记本配置"},{"content":"本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\n简单示例 应用代码 以这段简单的go web代码为例进行介绍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;net/http\u0026#34; )  func main() { \thttp.HandleFunc(\u0026#34;/\u0026#34;, HandleHello) \tserver := \u0026amp;http.Server{ \tAddr: \u0026#34;:9090\u0026#34;, \t}  fmt.Println(\u0026#34;Server startup...\u0026#34;) \tif err := server.ListenAndServe(); err != nil { \tfmt.Printf(\u0026#34;Server startup failed, err:%v\\n\u0026#34;, err) \t} }  func HandleHello(w http.ResponseWriter, _ *http.Request) { \tw.Write([]byte(\u0026#34;Hello World\u0026#34;)) }   编写Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  FROMgolang:alpine# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64  # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .# 声明服务端口EXPOSE9090# 启动容器时运行的命令CMD [\u0026#34;/app\u0026#34;]  构建镜像 使用命令构建镜像。\n1  docker build . -t goweb   使用镜像 1  docker run -p 9090:9090 --name goweb-app goweb   使用-p来映射端口，这里容器中的应用需要在9090端口上运行，将其映射到主机的9090端口。也可以将其映射到其他端口，例如-p 8080:9090。\n分段构建 在编译Go程序之后，我们得到了一个可执行的二进制文件，在最终的镜像中我们是不需要go编译器的，只需要一个可以运行二进制文件的容器即可。所以可以通过分段构建，第一步编译出二进制可执行文件，第二步将该可执行文件放进可以运行的环境即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  FROMgolang:alpine AS builder# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64  # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .#################### 最终的小镜像###################FROMscratch# 从builder镜像中把/app 拷贝到当前目录COPY --from=builder /build/app /# 需要运行的命令ENTRYPOINT [\u0026#34;/app\u0026#34;]  通过分段构建，我们就得到了一个体积非常小的镜像。\n静态资源的拷贝 如果需要部署的程序还需要用到静态资源，那么还需要将静态资源拷贝到镜像中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  FROMgolang:alpine AS builder# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64  # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .#################### 最终的小镜像###################FROMscratchCOPY /templates /templatesCOPY /static /static# 从builder镜像中把/app 拷贝到当前目录COPY --from=builder /build/app /# 需要运行的命令ENTRYPOINT [\u0026#34;/app\u0026#34;]  ","permalink":"https://www.niuwx.cn/posts/go/docker_go/","summary":"\u003cp\u003e本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\u003c/p\u003e","title":"Docker部署Go Web应用"},{"content":"本文以Oh-my-zsh为例，Oh-my-post同样适用。\n如图，使用Windows Terminal连接服务器使用Zsh命令行时，会出现乱码，导致主题无法正常显示。\n解决方法 安装Nerd Fonts，下载喜欢的字体然后右键选择“为所有用户安装”，打开Windows Terminal修改settings.json中的\u0026quot;fontFace\u0026quot;项为Nerd字体即可，注意要更改为其显示的正式名称。\n","permalink":"https://www.niuwx.cn/posts/other/zsh/","summary":"\u003cp\u003e本文以Oh-my-zsh为例，Oh-my-post同样适用。\u003c/p\u003e","title":"Windows oh-my-zsh 命令行出现乱码的原因及解决办法"},{"content":"This is a test for hugo.\n1 2 Test\n1 2 3 4 5 6 7  package main  import \u0026#34;fmt\u0026#34;  func main(){  fmt.Println(\u0026#34;Hello World\u0026#34;) }   ","permalink":"https://www.niuwx.cn/posts/hello-test/","summary":"\u003cp\u003e\u003cstrong\u003eThis is a test for hugo.\u003c/strong\u003e\u003c/p\u003e","title":"Hello Test"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]