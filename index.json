[{"content":"这篇文章将介绍图论中的拓扑排序。\n什么是拓扑排序？ 对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。\n拓扑排序  入度：指向v的边的个数叫做v的入度。 出度：v指向的点的个数叫做v的出度。  如果一个点的入度是0，那么说明这个点是起点（起点不止一个）。如果一个点的出度为0，那么说明这个点排在最后。\n举例说明：\n如图所示，这是一个有向无环图，其指向顺序为a,(b,c),d,e,则abcde和acbde都是这个图的拓扑排序。\n很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。\n拓扑排序的实现 DFS和BFS都可以实现拓扑排序。\nBFS实现拓扑排序 这种算法也叫做Kahn算法\n继续使用上面的例子进行说明\nBFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。\n无前驱的顶点优先就是顺着找，a的入度为0，则其为起点，a入队；\na出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；\n目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；\nb出队，b指向d，d入度减一，d入度为零，入队；\nd出队，d指向e，e入度减一，e入度为零，入队；\ne出队，无后续结点，结束。\n由上述过程可得拓扑排序为acbde。\n时间复杂度 假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。\n代码实现如下：\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int T, n, m, u, v; int deg[N]; int vis[N]; int dest[N]; vector\u0026lt;int\u0026gt; g[N]; queue\u0026lt;int\u0026gt; q; bool toposort() { //将入度为零的点放入队列  for (int i = 1; i \u0026lt;= n; i++) { if (!deg[i]) { vis[i] = 1; q.push(i); } } int num = 0; while (!q.empty()) { int now = q.front(); q.pop(); dest[num++] = now; for (auto to : g[now]) { if (vis[to]) //判断该节点是否在队列中  continue; else { deg[to]--; //入度减一  if (!deg[to]) { //判断入度是否为零  q.push(to); //入队  vis[to] = 1; //标记其在队列中  } } } } if (num == n) return true; else return false; } int main(int argc, char const *argv[]) { memset(deg, 0, sizeof(deg)); memset(vis, 0, sizeof(vis)); memset(dest, 0, sizeof(dest)); for (int i = 1; i \u0026lt;= N; i++) g[i].clear(); while (!q.empty()) q.pop(); //以上为初始化  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); //读入  g[u].push_back(v); deg[v]++; //统计入度  } if (toposort()) {//如果可以生成拓扑排序  for (int i = 0; i \u0026lt; n; i++) //输出结果  printf(\u0026#34;%d%c\u0026#34;, dest[i], i == n ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } else printf(\u0026#34;NO\\n\u0026#34;); return 0; } //测试数据 //有向有环图 2 1 1 3 3 4 4 2 //有向无环图 1 2 1 3 3 4 2 4 4 5 DFS实现拓扑排序 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; int n, u, v; int c[N]; // 标志数组 vector\u0026lt;int\u0026gt; G[N]; // vector 实现的邻接表 vector\u0026lt;int\u0026gt; topo; // 拓扑排序后的节点  bool dfs(int u) { c[u] = -1; for (int v : G[u]) { if (c[v] \u0026lt; 0) return false; else if (!c[v]) if (!dfs(v)) return false; } c[u] = 1; topo.push_back(u); return true; } bool toposort() { topo.clear(); memset(c, 0, sizeof(c)); for (int u = 0; u \u0026lt; n; u++) if (!c[u]) if (!dfs(u)) return false; reverse(topo.begin(), topo.end()); return true; } int main(int argc, char const *argv[]) { return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","summary":"\u003cp\u003e这篇文章将介绍图论中的拓扑排序。\u003c/p\u003e","title":"拓扑排序"},{"content":"C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\n存储 高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出\n头文件及全局变量 #include \u0026lt;bits/stdc++.h\u0026gt;static const int LEN = 1004; int a[LEN], b[LEN], c[LEN], d[LEN]; int flag; 清空 void clean(int temp[]) { for (int i = 0; i \u0026lt; LEN; ++i) temp[i] = 0; } 存储 void read(int temp[]) { static char s[LEN + 1]; scanf(\u0026#34;%s\u0026#34;, s); clean(temp); int len = strlen(s); for (int i = 0; i \u0026lt; len; ++i) { temp[len - 1 - i] = s[i] - \u0026#39;0\u0026#39;; } } 输出 void print(int a[]) { int i; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (; i \u0026gt;= 0; i--) putchar(a[i] + \u0026#39;0\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } 这样就完成了对于数据的存储与输出\n加法 高精度加法其实就是按照竖式加法法则来计算\n从低位开始相加，满十则向高一位进一，本位取余\n{% note info, 这里使用十进制，也可以使用其他更大的进制，如1000进制 %}\n//高精度加法 void add(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] = a[i] + b[i]; if (c[i] \u0026gt; 9) {//判断是否满十  c[i] -= 10; c[i + 1] += 1; } } } 减法 高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。\n因为要考虑到小数减大数的情况，所以用此函数来判断\nbool compare(int a[], int b[]) { int i, j; for (i = LEN - 1; i \u0026gt;= 1; --i) if (a[i] != 0) break; for (j = LEN - 1; j \u0026gt;= 1; --j) if (b[j] != 0) break; if (i \u0026gt; j) { return 0; } else if (i \u0026lt; j) { return 1; } else { for (int p = i; p \u0026gt;= 0; --p) { if (a[p] == b[p]) continue; if (a[p] \u0026gt; b[p]) return 0; else return 1; } } return 0; } //高精度减法 void sub(int* a, int* b, int* c) { flag = compare(a, b);//判断是否是小数减大数  if (flag) {//如果是  putchar(\u0026#39;-\u0026#39;);//则输出负号  sub(b, a, c);//按照大数减小数计算  flag = 0; return; } clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { c[i] += a[i] - b[i]; if (c[i] \u0026lt; 0) { c[i] += 10; c[i + 1] -= 1; } } } 乘法 高精度*低精度 如果是高精度与低精度相乘的话，就没必要使用高精度乘法\nvoid mul(int a[], int b, int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; ++i) { c[i] += a[i] * b;//每位都乘低精度  if (c[i] \u0026gt; 9) { c[i + 1] += c[i] / 10; c[i] %= 10; } } } 高精度*高精度 高精度与高精度相乘也是模拟了手写计算乘法的方式\n//高精度乘法 void mul(int a[], int b[], int c[]) { clean(c); for (int i = 0; i \u0026lt; LEN - 1; i++) { // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和  for (int j = 0; j \u0026lt;= i; j++) { c[i] += a[j] * b[i - j]; } if (c[i] \u0026gt; 9) { c[i + 1] = c[i] / 10; c[i] %= 10; } } } 除法 //判断长度 inline bool greater_eq(int a[], int b[], int last_dg, int len) { if (a[last_dg + len] != 0) return true; for (int i = len - 1; i \u0026gt;= 0; --i) { if (a[last_dg + i] \u0026gt; b[i]) return true; if (a[last_dg + i] \u0026lt; b[i]) return false; } return true; } //高精度除法 void div(int a[], int b[], int c[], int d[]) { clean(c); clean(d); int la, lb; for (la = LEN - 1; la \u0026gt; 0; --la) if (a[la - 1] != 0) break; for (lb = LEN - 1; lb \u0026gt; 0; --lb) if (b[lb - 1] != 0) break; if (lb == 0) { puts(\u0026#34;除数为零，错误\u0026#34;); return; } for (int i = 0; i \u0026lt; la; ++i) d[i] = a[i]; for (int i = la - lb; i \u0026gt;= 0; --i) { while (greater_eq(d, b, i, lb)) { for (int j = 0; j \u0026lt; lb; ++j) { d[i + j] -= b[j]; if (d[i + j] \u0026lt; 0) { d[i + j + 1] -= 1; d[i + j] += 10; } } c[i] += 1; } } } 测试 int main() { flag = 0; read(a); read(b); add(a, b, c); print(c); sub(a, b, c); print(c); mul(a, b, c); print(c); div(a, b, c, d); print(c); print(d); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/","summary":"\u003cp\u003eC/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题\u003c/p\u003e","title":"高精度计算"},{"content":"引入 例题hdu1097\n这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\n{% folding green, 点击展开 %}\nlong long fastPower(long long base, long long power){ long long ans = 1; for(int i = 0; i \u0026lt; power; i++){ ans *=base; } return ans % 10; } {%endfolding%}\n那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？\nint fastPower(long long base, long long power){ int ans = 1; base %= 10; for(int i = 0; i \u0026lt; power; i++){ ans *= base; if(ans \u0026gt; 9) ans %= 10; } return ans; } 结果同样，如果数据过大，还是会超时。\n快速幂 {% folding green, 取模的运算法则 %}\n$(a+b) mod M = (amodM + bmodM)modM$\n$(a-b)modM = (amodM - bmodM)modM$\n$(a*b)modM = (amodM * bmodM)modM$\n{% endfolding %}\n 入门 快速幂算法可以高效快速的算出$a^n$。\n下面举一个例子\n如果计算$2^{10}$\n$2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2\n尽量将指数变小，如下\n$2^{10} = (2*2)^5 = 4^5$\n此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。\n那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样\n$2^{10} = 4^4*4^1$\n将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作：\n$2^{10} = 16^2*4^1$\n将指数再次缩小一半\n$2^{10} = 256^1*4^1$\n此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，得到的结果是变化过程中所有指数为奇数时的底数的乘积\n初步实现 用代码实现上面的算法：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) { power -= 1; result = result * base % 10; power /= 2; base = base * base % 10; } else { power /= 2; base = base * base % 10; } } return result % 10; } 优化 1.由于if、else中有重复语句\npower /= 2; base = base * base % 10; 2.且在整形运算中\npower -=1; power /=2; 可以压缩成下面一句\npower /=2;  于是代码就可以压缩成以下这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power % 2) result = result * base % 10; power /= 2; base = base * base % 10; } return result % 10; } 再次优化 在C/C++中可以利用更快位运算来代替一些计算，例如\npower % 2 == 1; power \u0026amp; 1 == 1;//位运算 power /=2; power \u0026gt;\u0026gt;= 1;//位运算 于是代码就变成了这样：\nlong long fastPower(long long base, long long power) { long long result = 1; while (power) { if (power \u0026amp; 1) result = result * base % 10; power \u0026gt;\u0026gt;= 1; base = base * base % 10; } return result % 10; } ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/","summary":"\u003ch2 id=\"引入\"\u003e引入\u003c/h2\u003e\n\u003cp\u003e例题\u003ca href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1097\"\u003ehdu1097\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法\u003c/p\u003e\n\u003cp\u003e{% folding green, 点击展开 %}\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efastPower\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e base, \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e power){\n    \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;\n    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e power; i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e){\n        ans \u003cspan style=\"color:#f92672\"\u003e*=\u003c/span\u003ebase;\n    }\n    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e ans \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e{%endfolding%}\u003c/p\u003e","title":"快速幂"},{"content":"STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\n容器 使用容器时要在头文件中引入\n序列式容器 序列的元素的位置是由进入容器的时间和地点决定的\nvector vector简单点说就是一个动态数组，vector实现动态增长，当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间。\n#define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; void PrintVector(vector\u0026lt;int\u0026gt;\u0026amp; v) { for (vector\u0026lt;int\u0026gt;::iterator it = v.begin(); it != v.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //初始化 void test01() { vector\u0026lt;int\u0026gt; v1; //默认构造  int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v2(arr, arr + sizeof(arr) / sizeof(int)); vector\u0026lt;int\u0026gt; v3(v2.begin(), v2.end()); vector\u0026lt;int\u0026gt; v4(v3); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //常用赋值操作 void test02() { int arr[] = {10, 20, 30, 40}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); //成员方法  vector\u0026lt;int\u0026gt; v2; v2.assign(v1.begin(), v1.end()); //重载=  vector\u0026lt;int\u0026gt; v3; v3 = v2; int arr1[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v4(arr1, arr1 + sizeof(arr1) / sizeof(int)); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); cout \u0026lt;\u0026lt; \u0026#34;---------------\u0026#34; \u0026lt;\u0026lt; endl; //交换  v4.swap(v1); PrintVector(v1); PrintVector(v2); PrintVector(v3); PrintVector(v4); } //大小操作 void test03() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; if (v1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } PrintVector(v1); v1.resize(2); PrintVector(v1); v1.resize(6, 1); //不写默认零  PrintVector(v1); for (int i = 0; i \u0026lt; 10000; i++) { v1.push_back(i); } cout \u0026lt;\u0026lt; v1.size() \u0026lt;\u0026lt; endl; //长度、大小  cout \u0026lt;\u0026lt; v1.capacity() \u0026lt;\u0026lt; endl; //容量 } //vector存取数据 void test04() { int arr[] = {100, 200, 300, 400}; vector\u0026lt;int\u0026gt; v1(arr, arr + sizeof(arr) / sizeof(int)); for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;-----------\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; v1.size(); i++) { cout \u0026lt;\u0026lt; v1.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;front: \u0026#34; \u0026lt;\u0026lt; v1.front() \u0026lt;\u0026lt; endl; //第一个元素  cout \u0026lt;\u0026lt; \u0026#34;back: \u0026#34; \u0026lt;\u0026lt; v1.back() \u0026lt;\u0026lt; endl; //最后一个元素 } //插入和删除 void test05() { vector\u0026lt;int\u0026gt; v; v.push_back(10); v.push_back(20); //头插法  v.insert(v.begin(), 30); //尾插法  v.insert(v.end(), 40); PrintVector(v); v.insert(v.begin() + 2, 100); //插到第二个位置  //vector支持随机访问  //支持数组下标，一般都支持随机访问  //迭代器可以直接+-操作  PrintVector(v); //删除  v.erase(v.begin()); PrintVector(v); v.erase(v.begin() + 1, v.end()); PrintVector(v); v.clear(); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; } //巧用swap缩减空间 void test06() { //vector添加元素 自动增长 那么，删除元素的时候，会自动减少吗  vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); } cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; v.resize(10); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; //收缩空间  vector\u0026lt;int\u0026gt;(v).swap(v); cout \u0026lt;\u0026lt; \u0026#34;----------\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity() \u0026lt;\u0026lt; endl; PrintVector(v); } void test07() { //reserve预留空间 resize区别  int num = 0; int* address = NULL; vector\u0026lt;int\u0026gt; v; v.reserve(100000); //预先分配  for (int i = 0; i \u0026lt; 100000; i++) { v.push_back(i); if (address != \u0026amp;v[0]) { num++; } } cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; //如果你知道容器大概需要的空间，预先分配空间，可以减少时间浪费吗，提高程序运行效率 } int main() { //test01();  //test02();  //test03();  //test04();  //test05();  //test06();  test07(); return 0; } deque deque表示双端队列，即可以从前端或者后端这两端进行数据的插入和删除\n 分段连续的内存空间 支持随机访问 指定位置插入，会引起数据移动  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;deque\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; void PrintDeque(deque\u0026lt;int\u0026gt;\u0026amp; d) { for (deque\u0026lt;int\u0026gt;::iterator it = d.begin(); it != d.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } //初始化 void test01() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2(10, 5); deque\u0026lt;int\u0026gt; d3(d2.begin(), d2.end()); deque\u0026lt;int\u0026gt; d4(d3); //打印  PrintDeque(d4); cout \u0026lt;\u0026lt; endl; } //赋值、大小操作 void test02() { deque\u0026lt;int\u0026gt; d1; deque\u0026lt;int\u0026gt; d2; deque\u0026lt;int\u0026gt; d3; d1.assign(10, 5); d2.assign(d1.begin(), d1.end()); //迭代器指定区间赋值  d3 = d2; //等号赋值  d1.swap(d2); //交换两个空间的元素  if (d1.empty()) { cout \u0026lt;\u0026lt; \u0026#34;空\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;不空\u0026#34; \u0026lt;\u0026lt; endl; } d1.resize(5); //有十个，后五个扔掉 } //插入和删除 void test03() { deque\u0026lt;int\u0026gt; d1; d1.push_back(100); d1.push_front(200); d1.push_back(300); d1.push_back(400); d1.push_front(500); //500 200 100 300 400  PrintDeque(d1); int val = d1.front(); //拿到第一个数据  d1.pop_front(); //删除第一个，无返回值  val = d1.back(); d1.pop_back(); //删除最后一个元素 } int main() { //test01();  //test02();  test03(); return 0; } list  双向链表 链表是由一系列节点组成的，节点包括两个域，一个数据域，一个指针域。 链表内存是非连续的，添加删除元素 时间复杂度是常数项 不需要移动元素 链表需要额外空间保留节点关系 不支持随机访问，故不能使用算法提供的sort()来进行排序，但可以调用其成员方法  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;list\u0026gt;using namespace std; //初始化 void test01() { list\u0026lt;int\u0026gt; l1; list\u0026lt;int\u0026gt; l2(10, 10); list\u0026lt;int\u0026gt; l3(l2); list\u0026lt;int\u0026gt; l4(l3.begin(), l3.end()); //打印  for (list\u0026lt;int\u0026gt;::iterator it = l4.begin(); it != l4.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //插入和删除 void test02() { list\u0026lt;int\u0026gt; l; l.push_back(100); l.push_front(200); l.insert(l.begin(), 300); l.insert(l.end(), 200); list\u0026lt;int\u0026gt;::iterator it = l.begin(); it++; l.insert(it, 500); //删除  //l.pop_back();  //l.pop_front();  //l.erase(l.begin(), l.end());  l.remove(200); //删除匹配的所有值  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } //赋值操作 void test03() { list\u0026lt;int\u0026gt; l; l.assign(10, 10); list\u0026lt;int\u0026gt; l2; l2 = l; list\u0026lt;int\u0026gt; l3; l3.swap(l); } //反转 void test04() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(i); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.reverse(); //容器元素反转  for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } bool Mycompare(int val1, int val2) { return val1 \u0026gt; val2; } //排序 void test05() { list\u0026lt;int\u0026gt; l; for (int i = 0; i \u0026lt; 10; i++) { l.push_back(rand() % 10); } for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; l.sort(); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小  l.sort(Mycompare); for (list\u0026lt;int\u0026gt;::iterator it = l.begin(); it != l.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //算法sort 只支持可随机访问的容器 链表没有  //list的sort是自己的成员函数不是算法 } int main() { //test01();  //test02();  //test04();  test05(); return 0; } queue  先进先出 不提供迭代器，不能遍历，不支持随机访问 push 入队（队尾） pop 出队（队头）  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;queue\u0026gt;using namespace std; void test01() { queue\u0026lt;int\u0026gt; q;//创建队列  q.push(10); q.push(20); q.push(30); q.push(40); cout \u0026lt;\u0026lt; \u0026#34;队尾元素: \u0026#34; \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; //输出顺序 10,20,30,40 \twhile (q.size() \u0026gt; 0){ cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//输出队头 \tq.pop();//删除队头 \t} } int main() { test01(); return 0; } stack  先进后出 push 压栈 pop 出栈 栈不提供迭代器，不能遍历，不支持随机访问，只能通过top从栈顶获取和删除元素  #define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;#include\u0026lt;stack\u0026gt;using namespace std; void test01(){ //初始化 \tstack\u0026lt;int\u0026gt; s1; stack\u0026lt;int\u0026gt; s2(s1); //stack操作 \ts1.push(10); s1.push(20); s1.push(30); s1.push(100); cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; s1.pop();//删除栈顶元素  cout \u0026lt;\u0026lt; \u0026#34;栈顶元素：\u0026#34; \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; endl; //打印栈容器数据 \twhile (!s1.empty()) { cout \u0026lt;\u0026lt; s1.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; s1.pop(); } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size:\u0026#34; \u0026lt;\u0026lt; s1.size() \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } 关联式容器 容器的规则是固定的，与元素进入容器的时间和地点无关\nset/multiset set表示集合，集合是存储排序键的关联式容器，且每个键值都是唯一的，可以插入或删除但是不能更改\n 以红黑树为底层机制，查找效率非常好 set中不允许重复元素，multiset中允许重复元素 不可通过迭代器改变set元素的值，会破坏set组织  #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;iostream\u0026gt;#include \u0026lt;set\u0026gt;using namespace std; //仿函数 类 class Mycompare { public: bool operator()(int v1, int v2) const { //此处注意，要加const限定符  return v1 \u0026gt; v2; } }; //set容器初始化 void test01() { set\u0026lt;int, Mycompare\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); //自动进行排序，默认从小到大  for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; //从大到小排序怎么办？ #if 0//赋值 set\u0026lt;int\u0026gt; s2; s2 = s1; //删除 s1.erase(s1.begin()); s1.erase(6); for (set\u0026lt;int\u0026gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; s2.clear(); cout \u0026lt;\u0026lt; \u0026#34;size = \u0026#34; \u0026lt;\u0026lt; s2.size() \u0026lt;\u0026lt; endl; #endif } //set查找 void test02() { //实值  set\u0026lt;int\u0026gt; s1; s1.insert(8); s1.insert(10); s1.insert(4); s1.insert(6); s1.insert(5); s1.insert(1); s1.insert(3); s1.insert(2); set\u0026lt;int\u0026gt;::iterator ret = s1.find(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于等于的元素  ret = s1.lower_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //找到第一个大于的元素  ret = s1.upper_bound(4); if (ret == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; *ret \u0026lt;\u0026lt; endl; } //equal_range 返回lower_bound和upper_bound的值  pair\u0026lt;set\u0026lt;int\u0026gt;::iterator, set\u0026lt;int\u0026gt;::iterator\u0026gt; pret = s1.equal_range(4); if (pret.first == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.first \u0026lt;\u0026lt; endl; } if (pret.second == s1.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *pret.second \u0026lt;\u0026lt; endl; } } class Person { public: Person(int id, int age) : id(id), age(age){}; int id; int age; }; class PersonCompare { public: bool operator()(const Person\u0026amp; p1, const Person\u0026amp; p2) const { return p1.age \u0026gt; p2.age; } }; void test03() { set\u0026lt;Person, PersonCompare\u0026gt; sp; Person p1(10, 20), p2(30, 40), p3(50, 60); sp.insert(p1); sp.insert(p2); sp.insert(p3); for (set\u0026lt;Person, PersonCompare\u0026gt;::iterator it = sp.begin(); it != sp.end(); it++) { cout \u0026lt;\u0026lt; (*it).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).age \u0026lt;\u0026lt; endl; } //查找  Person p4(90, 20); set\u0026lt;Person, PersonCompare\u0026gt;::iterator ret = sp.find(p4); //可找到，对应p1，按照age排序就按照age查找  if (ret == sp.end()) { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;找到\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; (*ret).id \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*ret).age \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对组 将两个值合并成一个值\n#define _CRT_SECURE_NO_WARNINGS #include\u0026lt;iostream\u0026gt;using namespace std; void test01() { pair\u0026lt;int, int\u0026gt; pair1(10, 20); cout \u0026lt;\u0026lt; pair1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair1.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair2 = make_pair(10, \u0026#34;aaa\u0026#34;); cout \u0026lt;\u0026lt; pair2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair2.second \u0026lt;\u0026lt; endl; pair\u0026lt;int, string\u0026gt; pair3 = pair2; cout \u0026lt;\u0026lt; pair3.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pair3.second \u0026lt;\u0026lt; endl; } int main() { test01(); return 0; } map/multimap  map与set区别，map具有键值和实值 所有元素根据键值自动排序 pair的第一个元素成为键值，第二个元素成为实值 map也是以红黑树为底层实现机制 不可以通过map的迭代器修改map键值，键值关系到容器内元素的排列顺序，任意改变键值会破坏容器的排列规则，但是可以改变实值 multimap允许相同键值存在，map不允许  #include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; //map初始化 void test01() { //map容器模板参数：第一个参数key的类型，第二个参数value的类型  map\u0026lt;int, int\u0026gt; m; //插入数据 pair.first 对应key，pair.second 对应value  //第一种  pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, bool\u0026gt; ret = m.insert(pair\u0026lt;int, int\u0026gt;(10, 10)); //放入匿名对象  if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第一次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第二种  ret = m.insert(make_pair(10, 20)); if (ret.second) { cout \u0026lt;\u0026lt; \u0026#34;第二次插入成功\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;插入失败\u0026#34; \u0026lt;\u0026lt; endl; } //第三种  m.insert(map\u0026lt;int, int\u0026gt;::value_type(30, 30)); //第四种  m[40] = 40; m[10] = 20; //如果key不存在，创建pair并插入  //如果key存在，修改value实值  //打印  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;m[60] = \u0026#34; \u0026lt;\u0026lt; m[60] \u0026lt;\u0026lt; endl; //访问一个不存再的key，那么map会将这个key插入到map中，对应的value默认为零  for (map\u0026lt;int, int\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { //*it取出来一个pair  cout \u0026lt;\u0026lt; \u0026#34;key = \u0026#34; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34;, value = \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } } class MyKey { public: MyKey(int index, int id) : index(index), id(id) {} int index; int id; }; struct mycompare { bool operator()(MyKey key1, MyKey key2) const { return key1.index \u0026gt; key2.index; } }; void test02() { map\u0026lt;MyKey, int, mycompare\u0026gt; m; //需要排序，自定义类型，给定一个排序方法  m.insert(make_pair(MyKey(1, 2), 2)); m.insert(make_pair(MyKey(3, 4), 2)); for (map\u0026lt;MyKey, int, mycompare\u0026gt;::iterator it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; it-\u0026gt;first.index \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first.id \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; } } //equal_range void test03() { map\u0026lt;int, int\u0026gt; m; m.insert(make_pair(1, 4)); m.insert(make_pair(2, 5)); m.insert(make_pair(3, 6)); pair\u0026lt;map\u0026lt;int, int\u0026gt;::iterator, map\u0026lt;int, int\u0026gt;::iterator\u0026gt; ret = m.equal_range(2); if (ret.first-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到lower_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } if (ret.second-\u0026gt;second) { cout \u0026lt;\u0026lt; \u0026#34;找到upper_bound\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没有找到\u0026#34; \u0026lt;\u0026lt; endl; } } int main() { //test01();  //test02();  test03(); return 0; } 对比    容器 vector deque list set multiset map multimap     典型内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树   可随机存取 是 是 否 否 否 对key而言：是 否   元素搜寻速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快   元素安插移除 尾端 头尾两端 任何位置 - - - -    迭代器 可以理解为指针，对指针的操作基本可以对迭代器操作，但实际上，迭代器是一个类，这个类封装了一个指针\n算法 通过有限的步骤解决问题的方法\n","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/stl/","summary":"\u003cp\u003eSTL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）\u003c/p\u003e","title":"STL"},{"content":"“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\n并查集可以总结为三句话：\n “并”的意思是把两个有某些关系的结点并到一起 “查”的意思是查找一个结点的根节点 “并”的时候需要用到“查”  初始化 int father[len];//此数组定义在全局  void Init(int n){ for (int i = 0; i \u0026lt; len; ++i) {//len为结点总数 \tfather[i] = i; } } 查 初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点）\n假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.\n如图即是对应关系\n//查（非递归算法） int FindRoot(int x){ r = x; while(r != father[r]){//自己是自己的爹即是找到了根结点  r = father[r]; } return r; } //递归算法 int FindRoot(int x){ return x == father[x] ? x : FindRoot(father[x]); } 并 如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作；\n相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作\n//并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(x != y){ parent[y] = x; } } 例题 hdu1213\n问题描述 今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。 此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。\n例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上 所以伊格纳修斯至少需要 2 张桌子。\n输入 输入以表示测试用例数的整数 T（1\u0026lt;=T\u0026lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1\u0026lt;=N，M\u0026lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。\n输出 对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。\n示例输入 2 5 3 1 2 2 3 4 5 5 1 2 5 示例输出 2 4 这道题用一句话概括就是在一张桌子上，每个人都要有认识的人\n代码 #include\u0026lt;stdio.h\u0026gt; int father[1001]; int find(int x) { return father[x] == x ? x : find(father[x]); } void merge (int x, int y) { x = find(x); y = find(y); if (x != y) { a[x] = y; } } int main(int argc, char const *argv[]) { int t, m, n, x, y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { father[i] = i; } for (int i = 0; i \u0026lt; m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); merge(x, y); } for (int i = 1; i \u0026lt;= n; ++i) { if (father[i] == i) { cnt++; } } printf(\u0026#34;%d\\n\u0026#34;, cnt); } return 0; } 优化 合并的优化 如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免\n不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度\n初始化代码如下\nint father[len]; int height[len]; for(int i = 0; i \u0026lt; len; i++){ father[i] = i; height[i] = 1;//初始深度为1 } //并 void merge(int x, int y){ x = FindRoot(x); y = FindRoot(y); if(height[x] == height[y]){//此处无需判断x，y根结点是否一致 \theight[x] = height[x] + 1; father[y] = x; } else if(height[x] \u0026gt; height [y]){ father[y] = x; } else { father[x] = y; } } 查询的优化 //对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。 //这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果 int find (int x){ if(x != parent[x]){ father[x] = find(father[x]); } return father[x]; } 此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并\n但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下：\nint Find(int x){ int r = x; while(father[r] != r){//找到根结点 \tr = father[r]; } int i = x; int j; while(i != r){//循环修改这条路径上的根结点 \tj = father[i];//j记录元素i此时的父亲 \tfather[i] = r;//将i的父亲改为根结点 \ti = j;//i记录为要“查询”的结点  } return r; } 经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$\n总结  并查集的思想很精妙，用一个数组表示了整片森林 优化的关键在于记录每棵树的结点数量，根据结点关系合并 ","permalink":"https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6%e6%9f%a5%e9%9b%86.jpg\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e“你只看见我渺小的身躯，却没有看到我心中的广阔森林”\u003c/p\u003e","title":"并查集"},{"content":"树的遍历 上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。\n以下是树的非递归遍历方法：\n偷个懒用一下C++写，头文件要加上\n#include\u0026lt;stack\u0026gt;先序遍历 //先序遍历 void PreorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;先序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; while(t || !s.empty()){ while(t){ cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//拿到这个结点就直接打印 \ts.push(t); t = t-\u0026gt;left; } if(!s.empty()){ t = s.top(); s.pop();\tt = t-\u0026gt;right; } } cout \u0026lt;\u0026lt; endl; } 中序遍历 //中序非递归遍历 void InorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;中序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; while(t || !s.empty()){ while(t){ s.push(t); t = t-\u0026gt;left; } if(!s.empty()){ t = s.top(); s.pop(); cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;;//遍历完左子树后再打印 \tt = t-\u0026gt;right; } } cout \u0026lt;\u0026lt; endl; } 后序遍历 //后序非递归遍历 void PostorderNoneSecu(PTree T) { cout\u0026lt;\u0026lt;\u0026#34;后序非递归遍历\u0026#34;\u0026lt;\u0026lt;endl; PTree t = T; stack\u0026lt;PTree\u0026gt; s; stack\u0026lt;PTree\u0026gt; s2; while(t || !s.empty()){ while(t){ s.push(t); s2.push(t); t = t-\u0026gt;right; } if(!s.empty()){ t = s.top(); s.pop(); t = t-\u0026gt;left; } } while(!s2.empty()){ t = s2.top(); s2.pop(); cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 后序遍历与先序遍历的顺序相反，那么可以先遍历右子树，也就是说将先序遍历的顺序逆过来压入s2中，，然后再根据栈的后进先出的特点，一一出栈。\n","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/","summary":"\u003ch3 id=\"树的遍历\"\u003e树的遍历\u003c/h3\u003e\n\u003cp\u003e上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。\u003c/p\u003e\n\u003cp\u003e以下是树的非递归遍历方法：\u003c/p\u003e","title":"树（二）"},{"content":"树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。\n对于非空树：\n1.有且仅有一个称之为根的结点。\n2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。\n基本术语  结点的度（Degree）：结点的子树个数 树的度：树的所有结点最大的度 叶结点（Leaf）：度为0的结点 父结点（Parent）：有子树的结点是其子树的根结点的父结点 子结点（Child）：若A结点是B结点的父结点，则称B结点为A结点的子结点；子结点也称孩子结点 兄弟结点（Sibling）：具有同一父结点的个节点彼此是兄弟结点 路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，n3\u0026hellip;nk。路径所包含边的个数为路径的长度 祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点 子孙节点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙 结点的层次（Level）：规定根结点在第一层，其它任意节点层数是父结点层数加一 树的深度（Depth）：树中所有结点中的最大层次  二叉树 二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。\n性质 1.二叉树的第i层的最大节点数为2.深度为k的二叉树最大结点数为3.二叉树的终端节点数为n0，度数为2 的结点数为n2，则n0 = n2 +1\n特殊的,\n如果一个深度为 k 的二叉树，正好有 个结点，那么这棵树就被称为满二叉树。\n如图所示：\n如果一个二叉树，只有当第 i 层已经达到了的最大值以后，才能往第 i + 1 层自左向右地添加结点，这棵树就被称为完全二叉树。\n那么，根据二叉树的性质二可得，具有n个结点的完全二叉树的深度为 $$ [log_2(n)]+1 $$\n如图所示：\n二叉树的建立 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt; typedef struct Tree { int data; struct Tree *left; struct Tree *right; } BiTree, *PTree;  //创造一个结点 PTree CreatNode(int value) { PTree p = (PTree)malloc(sizeof(BiTree)); p-\u0026gt;data = value; p-\u0026gt;left = p-\u0026gt;right = NULL; return p; } //插入结点且排序，不存在有相同值的结点 PTree AddNode(int value, PTree p) { if (p == NULL) { return CreatNode(value); } if (value == p-\u0026gt;data) { return p; } if (value \u0026lt; p-\u0026gt;data) { if (p-\u0026gt;left == NULL) { p-\u0026gt;left = CreatNode(value); return p-\u0026gt;left; } else { return AddNode(value, p-\u0026gt;left); } } else { if (p-\u0026gt;right == NULL) { p-\u0026gt;right = CreatNode(value); return p-\u0026gt;right; } else { return AddNode(value, p-\u0026gt;right); } } } 遍历二叉树 递归遍历左子树、根节点、递归遍历右子树\n先序遍历 输出根节点，递归遍历左子树，在递归遍历右子树\nvoid Preorder(PTree p) { if (p != NULL) { printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); Preorder(p-\u0026gt;left); Preorder(p-\u0026gt;right); } } 中序遍历 递归遍历左子树，输出根节点，在递归遍历右子树\nvoid Midorder(PTree p) { if (p != NULL) { Midorder(p-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); Midorder(p-\u0026gt;right); } } 后序遍历 递归遍历左子树，再递归遍历右子树，输出根节点\nvoid Postorder(PTree p) { if (p != NULL) { Postorder(p-\u0026gt;left); Postorder(p-\u0026gt;right); printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); } } 求二叉树的深度 int TreeHeight(PTree p) { int l, r; if (p == NULL) { return 0; } else { l = TreeHeight(p-\u0026gt;left); r = TreeHeight(p-\u0026gt;right); return (l \u0026gt; r ? l : r) + 1; } }  int main(int argc, char const *argv[]) {//测试 \tint value; PTree p = NULL; printf(\u0026#34;Please enter 10 numbers:\u0026#34;); for (int i = 0; i \u0026lt; 10; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;value); if (p == NULL) { p = CreatNode(value); } else { AddNode(value, p); } } Preorder(p); printf(\u0026#34;\\n\u0026#34;); Midorder(p); printf(\u0026#34;\\n\u0026#34;); Postorder(p); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;The depth of the binary tree is：%d\\n\u0026#34;, TreeHeight(p)); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/","summary":"\u003cp\u003e树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。\u003c/p\u003e\n\u003cp\u003e对于非空树：\u003c/p\u003e\n\u003cp\u003e1.有且仅有一个称之为根的结点。\u003c/p\u003e\n\u003cp\u003e2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。\u003c/p\u003e","title":"树（一）"},{"content":"引入 栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。\n顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。\n栈 定义 栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图\n线性表有两种存储形式，顺序表储存和链表储存。\n顺序栈 #include\u0026lt;stdlib.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Stack{ elem* base;//栈基 \telem* top;//栈顶 \tint stacksize; //栈的容量 }Stack; 创建一个栈 Status CreatStack(Stack* s){ s-\u0026gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base; s-\u0026gt;stacksize = MAXSIZE; return OK; } 入栈 Status PushStack(Stack* s, elem e){ if(s-\u0026gt;top - s-\u0026gt;base \u0026gt;= s-\u0026gt;stacksize){ s-\u0026gt;base = (elem*)realloc(s-\u0026gt;base, sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base + s-\u0026gt;stacksize; s-\u0026gt;stacksize +=MAXSIZE;\t} *(s-\u0026gt;top) = e; s-\u0026gt;top++; return OK; } 出栈 Status PopStack(Stack*s,elem *e){ if(s-\u0026gt;top == s-\u0026gt;base) return ERROR; *e = *--(s-\u0026gt;top); return OK; } 清空 Status CleanStack(Stack* s){ s-\u0026gt;top = s-\u0026gt;base; return OK; } 销毁 Status DestroyStack(Stack* s){ free(s-\u0026gt;base); s-\u0026gt;top = s-\u0026gt;base = NULL; s-\u0026gt;stacksize = 0; return OK; } 获取当前容量 int GetSize(Stack* s){ return s-\u0026gt;stacksize; } 链表栈 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Node//定义链表结构 { elem data;//数据域 \tstruct Node* next;//指针域 }Node, * LNode; typedef struct Stack { LNode top; LNode base; }Stack,*Pstack; 创建一个栈 Pstack CreatStack(){ Pstack stack = (Pstack)malloc(sizeof(Stack)); if(stack == NULL){ return NULL; } stack-\u0026gt;top = stack-\u0026gt;base = NULL; return stack; } 入栈 Status PushStack(Pstack *stack, elem e){ Node* p = (LNode)malloc(sizeof(Node)); if(p == NULL){ return ERROR; } p-\u0026gt;data = e; p-\u0026gt;next = (*stack)-\u0026gt;top; (*stack)-\u0026gt;top = p; return OK; } 出栈 Status PopStack(Pstack *stack){ Node* p = (*stack)-\u0026gt;top; if(p == (*stack)-\u0026gt;base){ printf(\u0026#34;栈已空\u0026#34;); return ERROR; } (*stack)-\u0026gt;top = p-\u0026gt;next; printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); free(p); return OK; } 判断是否为空 Status IsEmptyStack(Pstack stack){ return (stack-\u0026gt;top == stack-\u0026gt;base); } 清空 Status CleanStack(Pstack *stack){ Node*p = (*stack)-\u0026gt;top; while(p){ (*stack)-\u0026gt;top = p-\u0026gt;next; free(p); p = (*stack)-\u0026gt;top; } return OK; } 销毁 Status DestroyStack(Pstack *stack){ CleanStack(stack); free(*stack); return OK; } void test(){//测试 \tPstack stack = CreatStack(); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); for (int i = 0; i \u0026lt; 10; ++i){ PushStack(\u0026amp;stack, i); } printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); /*出栈*/ // for (int i = 0; i \u0026lt; 10; ++i){ \t// PopStack(\u0026amp;stack); \t// } \t// printf(\u0026#34;%\\n\u0026#34;); \t// printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); \t/*清空*/ CleanStack(\u0026amp;stack); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); printf(\u0026#34;%p\\n\u0026#34;,stack); DestroyStack(\u0026amp;stack); printf(\u0026#34;%d\\n\u0026#34;, IsEmptyStack(stack)); printf(\u0026#34;%p\\n\u0026#34;,stack); } 栈与递归 递归：函数自己调用自己\n 函数定义是递归的——斐波那契数列 数据结构是递归的——单链表、树 问题解法是递归的——汉诺塔、  函数的调用 函数被调用之前，\n 系统需要将实参以及返回地址传递给被调用的函数进行保存 将被调用的函数的局部变量分配到储存区 将控制转移到被调用的函数的入口  从被调用函数返回到调用函数之前，\n 保存被调用函数的计算结果 释放被调用函数中的数据区 依照被调用函数的保存的返回地址将控制转移至此  队列 定义 队列也是一种重要的线性结构。与栈相同，实现一个队列也需要顺序表或者链表作为基础。但是与栈不同的是，队列是一种先进先出（FIFO）的线性表。其要求所有的数据从队列的一段进入，从队列的另一端离开。在队列中，允许插入数据的一端叫做队尾（rear），允许数据离开的一端叫做队头（front）。如图所示\n链队列 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct QNode { elem data;\t//数据域 \tstruct QNode*next;\t//指针域 } QNode, *PNode; typedef struct { PNode front;\t//队头指针 \tPNode rear;\t//队尾指针 } LinkQueue; 创建一个队列 Status CreatQueue(LinkQueue *q) { q-\u0026gt;front = q-\u0026gt;rear = (PNode)malloc(sizeof(QNode)); if (q-\u0026gt;front == NULL) { return ERROR; } q-\u0026gt;front-\u0026gt;next = NULL; return OK; } 入队 Status PushQueue(LinkQueue *q, elem e) { QNode *p = (PNode)malloc(sizeof(QNode)); if (p == NULL) { return ERROR; } p-\u0026gt;data = e; p-\u0026gt;next = NULL; q-\u0026gt;rear-\u0026gt;next = p; q-\u0026gt;rear = p; return OK; } 出队 Status PopQueue(LinkQueue *q) { if (q-\u0026gt;front == q-\u0026gt;rear) { return ERROR; } QNode* p = q-\u0026gt;front-\u0026gt;next; printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; if (q-\u0026gt;rear == p) q-\u0026gt;rear = q-\u0026gt;front; return OK; } 销毁 Status DestroyQueue(LinkQueue *q) { while (q-\u0026gt;front) { q-\u0026gt;rear = q-\u0026gt;front-\u0026gt;next; free(q-\u0026gt;front); q-\u0026gt;front = q-\u0026gt;rear; } return OK; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"引入 栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。\n顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。\n栈 定义 栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图\n线性表有两种存储形式，顺序表储存和链表储存。\n顺序栈 #include\u0026lt;stdlib.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct Stack{ elem* base;//栈基 \telem* top;//栈顶 \tint stacksize; //栈的容量 }Stack; 创建一个栈 Status CreatStack(Stack* s){ s-\u0026gt;base = (elem*)malloc(sizeof(elem) * MAXSIZE); if(!s-\u0026gt;base) return ERROR; s-\u0026gt;top = s-\u0026gt;base; s-\u0026gt;stacksize = MAXSIZE; return OK; } 入栈 Status PushStack(Stack* s, elem e){ if(s-\u0026gt;top - s-\u0026gt;base \u0026gt;= s-\u0026gt;stacksize){ s-\u0026gt;base = (elem*)realloc(s-\u0026gt;base, sizeof(elem) * MAXSIZE); if(!","title":"栈和队列"},{"content":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。\n每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。\n在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。\n头指针和头节点 基本概念 头指针 通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。\n头节点 在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。\n[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。\n空链表 单链表 引入头结点的优势 链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。\n优势1：第一个位置的插入删除特别方便 若使用头结点，则第1个位置的插入和删除都是对p—\u0026gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：\n插入操作如下  p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s;  删除操作如下  p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q);   若没有头结点，在第1个位置插入或删除时，需要动头指针。\n插入操作如下  判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。  删除操作如下  判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—\u0026gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q); return PtrL  优势2：统一空表和非空表的处理 若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。\n若不使用头结点，当表非空时，头指针指向第1个结点的地址，即LNode类型，但是对于空表，头指针指向的是NULL*，此时空表和非空表的操作是不一致的。\n链表的建立 有头结点链表的建立 #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#define OK 1 #define ERROR 0 typedef int elem; typedef int Status; typedef struct LNode{ elem data; //数据域  struct LNode* next; //指针域 }Node, *List;  List HeadCreatList(int n){//带头结点_头插法  Node *s; List head = (List)malloc(sizeof(Node));//生成头结点  head-\u0026gt;next = NULL; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; s-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = s;//头结点的指针域next指向s结点，使得s成为结点  } return head; } List TailCreatList(int n){//带头结点_尾插法  Node *s, *r; List head = (List)malloc(sizeof(Node)); head-\u0026gt;next = NULL; r = head; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; r-\u0026gt;next = s; r = s; } if(r-\u0026gt;next != NULL){ r-\u0026gt;next = NULL; } return head; }  下面这个是建立头结点与建立链表分离\nList CreatHNode(){//建立头结点  Node *s, *r; List head = (List)malloc(sizeof(Node)); head-\u0026gt;next = NULL; return head; } Status HeadList(List head, int n){//头插法  Node *s; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; s-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = s;//头结点的指针域next指向s结点，使得s成为结点  } return OK; } Status TailList(List head, int n){//尾插法  Node *s, *r; r = head; for (int i = 0; i \u0026lt; n; i++){ s = (List)malloc(sizeof(Node)); s-\u0026gt;data = i; r-\u0026gt;next = s; r = s; } if(r-\u0026gt;next != NULL){ r-\u0026gt;next = NULL; } return OK; } 为了方便测试，先写出遍历并打印链表的函数\nStatus PrintList(List head){//打印链表数据  Node *t = head-\u0026gt;next; while (t != NULL){ printf(\u0026#34;%d \u0026#34;,t-\u0026gt;data); t = t-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); return OK; } void test(){//测试  List head; //head = HeadCreatList(10);  head = TailCreatList(10); //head = CreatHNode();  //HeadList(head, 10);  //TailList(head, 10);  PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 无头结点链表的建立 List HeadCreatList(int n){//头插法 \tList head = NULL; Node *p; while(n--){ p = (List)malloc(sizeof(Node)); p-\u0026gt;data = n; if(head == NULL){ p-\u0026gt;next = NULL; head = p; } else{ p-\u0026gt;next = head; head = p; } } return head; } List TailCreatList(int n){//尾插法 \tList head = NULL; Node *p, *q; while(n--){ p = (List)malloc(sizeof(Node)); p-\u0026gt;data = n; if(head == NULL){ head = p; } else{ q-\u0026gt;next = p; } p-\u0026gt;next = NULL; q = p; } return head; } 为了测试，先写出打印链表的函数\nStatus PrintList(List head){//打印链表元素 \tif(head == NULL){ return ERROR; } Node *t = head; while(t != NULL){ printf(\u0026#34;%d\u0026#34;, t-\u0026gt;data);\tt = t-\u0026gt;next; } printf(\u0026#34;%d\u0026#34;); return OK; } void test(){//测试 \tList head; //head = HeadCreatList(10); \thead = TailCreatList(10); PrintList(head); return ; } 链表的各个功能的实现（有头结点） 上面介绍了有无头结点对于功能实现的影响，接下来先使用有头结点的链表进行\n链表元素的添加 //链表添加元素（插头） Status HeadInsertList(List head,Node a){ Node *p = (List)malloc(sizeof(Node)); p-\u0026gt;data = a.data; p-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = p; return OK; } //链表添加元素（插尾） Status TailInsertList(List head,Node a){ Node *p, *t, *s; t = head-\u0026gt;next; p = (List)malloc(sizeof(Node)); p-\u0026gt;data = a.data; while(t!= NULL){ s = t; t = t-\u0026gt;next; } s-\u0026gt;next = p; p-\u0026gt;next = NULL; return OK; } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); //HeadInsertList(head, a);  TailInsertList(head, a); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的插入 //链表的插入（插在之前） Status InsertIndexFront(List head,int i){ Node *p, *q, *r; int j = 0; p = head; while(p \u0026amp;\u0026amp; j \u0026lt; i){ r = p; p = p-\u0026gt;next; j++; } if(!p || j\u0026gt;i){ return ERROR; } q = (List)malloc(sizeof(Node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q-\u0026gt;data); q-\u0026gt;next = p; r-\u0026gt;next = q; return OK; } //链表的插入（插在之后） Status InsertIndexBack(List head,int i){ Node *p,*q; int j = 0; p = head; while(p \u0026amp;\u0026amp; j \u0026lt; i){ p = p-\u0026gt;next; j++; } if(!p || j \u0026gt; i){ return ERROR; } q = (List)malloc(sizeof(Node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q-\u0026gt;data); q-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = q; return OK; } oid test(){//测试  List head; head = HeadCreatList(10); PrintList(head); InsertIndexFront(head,2); //InsertIndexBack(head,2);  PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的查找 //链表元素的查找 elem GetElem(List head, int index){//按序号查找  int j; Node* p; p = head-\u0026gt;next; //p指向第一个数据结点  j = 1; //j为计数器  while (p \u0026amp;\u0026amp; j \u0026lt; index ){ //顺着链表向后扫描，直到p指向第i个元素或p为空  p=p-\u0026gt;next; //p指向下一个结点  j++; //计数器j相应加1  } if (!p || j \u0026gt; index) return -1; //i值不合法i＞n或i\u0026lt;=0  return p-\u0026gt;data;//返回第i个结点的数据域  } elem GetIndex(List head, int e) {//按值查找  //在带头结点的单链表L中查找值为e的元素  Node* p; int index = 0; p = head-\u0026gt;next; while (p \u0026amp;\u0026amp; p-\u0026gt;data!=e){ //顺链域向后扫描，直到p为空或p所指结点的数据域等于e  p=p-\u0026gt;next; //p指向下一个结点  ++index; } if(!p) return -1; //查找失败p为NULL  return index; } void test(){ List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); printf(\u0026#34;%d\\n\u0026#34;,GetElem(head,6)); printf(\u0026#34;%d\\n\u0026#34;,GetIndex(head,6)); system(\u0026#34;pause\u0026#34;); return; } 链表元素的删除 Status DeleteList(List head, int index) {//单链表的删除  //在带头结点的单链表L中，删除第i个位置  Node *p, *q; int j; p = head; j = 0; while((p-\u0026gt;next)\u0026amp;\u0026amp;(j \u0026lt; index - 1)) {//查找第i-1个结点，p指向该结点  p=p-\u0026gt;next; j++; } if (!(p-\u0026gt;next)||(j \u0026gt; index - 1))//当i\u0026gt;n或i\u0026lt;1时，删除位置不合理  return ERROR; q = p-\u0026gt;next; //临时保存被删结点的地址以备释放空间  p-\u0026gt;next = q-\u0026gt;next; //改变删除结点前驱结点的指针域  free(q); //释放被删除结点的空间  return OK; } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); DeleteList(head,4); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的修改 //链表元素的修改 Status ReverseElem(List head, int index,int e){ int j; Node* p; p = head-\u0026gt;next; //p指向第一个数据结点  j = 1; //j为计数器  while (p \u0026amp;\u0026amp; j \u0026lt; index ){ //顺着链表向后扫描，直到p指向第i个元素或p为空  p=p-\u0026gt;next; //p指向下一个结点  j++; //计数器j相应加1  } if (!p || j \u0026gt; index) return ERROR; //i值不合法i＞n或i\u0026lt;=0  p-\u0026gt;data = e; return OK;//返回第i个结点的数据域 } void test(){//测试  List head; Node a; a.data = 666; head = HeadCreatList(10); PrintList(head); ReverseElem(head,4,999); PrintList(head); system(\u0026#34;pause\u0026#34;); return; } 链表元素的清空 //清空链表 Status ClearList(List head) { Node*p,*q; if(head == NULL) return ERROR; p = head-\u0026gt;next; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } head-\u0026gt;next=NULL; return OK; } 链表元素的排序 Status SwapElem(int *i, int *j){//交换数据  int temp = *i; *i = *j; *j = temp; return OK; } void SortList(List head){//冒泡排序  Node* p = NULL; Node* q = NULL; Node* t = NULL; if(head-\u0026gt;next == NULL){ return ; } for ( p = head-\u0026gt;next; p != NULL; p = p-\u0026gt;next){ for ( q = head-\u0026gt;next; q-\u0026gt;next != NULL; q = q-\u0026gt;next){ if(q-\u0026gt;data \u0026gt; q-\u0026gt;next-\u0026gt;data){ SwapElem(\u0026amp;q-\u0026gt;data, \u0026amp;q-\u0026gt;next-\u0026gt;data); } } } } 无头结点链表的功能实现就不在此赘述，所有源码都在Github ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/","summary":"链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。\n每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。\n在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为随机存取方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为顺序存取方式。\n头指针和头节点 基本概念 头指针 通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。\n头节点 在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。\n[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。\n空链表 单链表 引入头结点的优势 链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。\n优势1：第一个位置的插入删除特别方便 若使用头结点，则第1个位置的插入和删除都是对p—\u0026gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：\n插入操作如下  p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s;  删除操作如下  p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q);   若没有头结点，在第1个位置插入或删除时，需要动头指针。\n插入操作如下  判断要插入的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让新结点s的next指向头指针PtrL。 return s，此时s作为链表的头指针。此时的更新了链表的头指针。 若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。 让新结点s的next指向p的next，即s—\u0026gt;next = p—\u0026gt;next; 让p—\u0026gt;next指向s，即p—\u0026gt;next = s; return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。  删除操作如下  判断要删除的是否是第1个位置，若是需要特殊处理。 若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—\u0026gt;next； free(s);然后return PtrL 若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。 让临时指针q指向要删除的结点，即q = p—\u0026gt;next； 让p的next指向要删除结点的下一个结点，即p—\u0026gt;next = q—\u0026gt;next； 释放q的空间，即free(q); return PtrL  优势2：统一空表和非空表的处理 若使用头结点，无论表是否为空，头指针都指向头结点，也就是LNode类型*，对于空表和非空表的操作是一致的。","title":"单链表"},{"content":"概念 具有 一对一 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）\n#include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;#include\u0026lt;time.h\u0026gt;#define MAXSIZE 100 #define OK 1 #define ERROR 0 typedef int Status; typedef int elem; typedef struct Sqlist{ elem *e;//存储空间的及地址  int length;//长度 }Sqlist; 功能的实现 顺序表的初始化 //数组的初始化 Status InitArray(Sqlist *L){ if(L-\u0026gt;e) {//判断指针是否为空  free(L-\u0026gt;e); L-\u0026gt;e = NULL; } L-\u0026gt;e = (elem*)malloc(sizeof(int) * MAXSIZE);//申请capacity大小的空间  if(L-\u0026gt;e == NULL){ printf(\u0026#34;内存分配失败!\\n\u0026#34;);//判断内存分配是否成功  exit(0); } L-\u0026gt;length = 0; return OK; } 元素的添加 //添加元素 Status PushBackArray(Sqlist *L,elem value){ if(L-\u0026gt;e == NULL){ printf(\u0026#34;请初始化顺序表\\n\u0026#34;); return ERROR; } if(L-\u0026gt;length == MAXSIZE) { return ERROR; } L-\u0026gt;e[L-\u0026gt;length] = value; ++L-\u0026gt;length; return OK; } 元素的插入 //插入 Status InsertArray(Sqlist *L,int index,elem value){ if(index \u0026gt; L-\u0026gt;length +1 || index \u0026lt; 1){ return ERROR; } for (int i = L-\u0026gt;length; i \u0026gt;= index; i--) { L-\u0026gt;e[i] = L-\u0026gt;e[i - 1]; } L-\u0026gt;e[index] = value; ++L-\u0026gt;length; return OK; } 元素的查找 //根据位置查找 elem FindByIndex(Sqlist* L,int index){ return L-\u0026gt;e[index]; } //根据值查找 Status FindByValue(Sqlist* L,elem value){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ if(L-\u0026gt;e[i] == value){ return i; } } return -1; } 元素的删除 //根据值删除 Status RemoveByValue(Sqlist* L,elem value){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ if(L-\u0026gt;e[i] == value){ for (; i \u0026lt; L-\u0026gt;length; i++) { L-\u0026gt;e[i - 1] = L-\u0026gt;e[i]; } --L-\u0026gt;length; return OK; } } } //根据位置删除 Status RemoveByIndex(Sqlist* L,int index){ if (index \u0026gt; L-\u0026gt;length + 1 || index \u0026lt; 1) { return ERROR; } for (int i = index; i \u0026lt; L-\u0026gt;length; i++) { L-\u0026gt;e[i - 1] = L-\u0026gt;e[i]; } --L-\u0026gt;length; return OK; } 元素的清空 //清空 Status CleanArray(Sqlist *L){ if(L-\u0026gt;e == NULL) { printf(\u0026#34;未初始化\\n\u0026#34;); return ERROR; } L-\u0026gt;length = 0; return OK; } 线性表的销毁 //销毁 Status FreeArray(Sqlist* L){ if(L-\u0026gt;e != NULL){ free(L-\u0026gt;e); L-\u0026gt;e = NULL; } L-\u0026gt;length = 0; return OK; } 获取当前长度 //长度 int GetLength(Sqlist* L){ if(L-\u0026gt;e == NULL) return -1; return L-\u0026gt;length; } 判断是否为空 //判断是否为空 Status IsEmptyArray(Sqlist *L){ return L-\u0026gt;length = 0; } 顺序表的合并 //合并 Status CombineArray(Sqlist *L1,Sqlist *L2){ if (L1-\u0026gt;length + L2-\u0026gt;length \u0026gt; MAXSIZE) { printf(\u0026#34;空间不足，合并失败\\n\u0026#34;); return ERROR; } for (int i = 0; i \u0026lt; L2-\u0026gt;length; i++) { L1-\u0026gt;e[L1-\u0026gt;length + i] = L2-\u0026gt;e[i]; } L1-\u0026gt;length +=L2-\u0026gt;length; free(L2-\u0026gt;e); L2-\u0026gt;length = 0; return OK; } 顺序表的打印 //打印 void PrintArray(Sqlist* L){ for (int i = 0; i \u0026lt; L-\u0026gt;length; i++){ printf(\u0026#34;%d \u0026#34;,L-\u0026gt;e[i]); } printf(\u0026#34;\\n\u0026#34;); } void test(){//测试  Sqlist L,L2; /******************************/ /********初始化及添加元素********/ /******************************/ InitArray(\u0026amp;L);//初始化顺序表  InitArray(\u0026amp;L2); //srand(time(NULL));  for(int i = 0; i \u0026lt; 10; i++){//赋值  PushBackArray(\u0026amp;L,i); PushBackArray(\u0026amp;L2,i); } printf(\u0026#34;初始化...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /************插入元素***********/ /******************************/ InsertArray(\u0026amp;L,5,100);//插入元素  printf(\u0026#34;插入元素...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /************查找元素***********/ /******************************/ printf(\u0026#34;查找元素...\\n\u0026#34;); printf(\u0026#34;%d \u0026#34;,FindByIndex(\u0026amp;L,10));//根据位置查找  printf(\u0026#34;%d \u0026#34;,FindByValue(\u0026amp;L,4));//根据值查找  /******************************/ /************删除元素***********/ /******************************/ RemoveByIndex(\u0026amp;L,3);//根据位置删除  RemoveByValue(\u0026amp;L,9);//根据值删除  printf(\u0026#34;删除元素...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********合并顺序表**********/ /******************************/ CombineArray(\u0026amp;L,\u0026amp;L2);//合并  printf(\u0026#34;合并顺序表...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********清空顺序表**********/ /******************************/ CleanArray(\u0026amp;L);//清空  printf(\u0026#34;清空顺序表...\\n\u0026#34;); PrintArray(\u0026amp;L);//打印  printf(\u0026#34;%d\\n\u0026#34;, GetLength(\u0026amp;L));//获取当前长度  /******************************/ /***********销毁顺序表**********/ /******************************/ FreeArray(\u0026amp;L);//销毁  printf(\u0026#34;销毁顺序表...\\n\u0026#34;); printf(\u0026#34;%d\u0026#34;,PushBackArray(\u0026amp;L,1)); } int main(){ test(); system(\u0026#34;pause\u0026#34;); return 0; } ","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/","summary":"\u003ch3 id=\"概念\"\u003e概念\u003c/h3\u003e\n\u003cp\u003e具有 \u003cem\u003e一对一\u003c/em\u003e 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define MAXSIZE 100\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define OK 1\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#define ERROR 0\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e Status;\n\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e elem;\n\n\n\u003cspan style=\"color:#66d9ef\"\u003etypedef\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e Sqlist{\n    elem \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ee;\u003cspan style=\"color:#75715e\"\u003e//存储空间的及地址\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e length;\u003cspan style=\"color:#75715e\"\u003e//长度\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}Sqlist;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"顺序表"},{"content":"数据 所有能够输入到计算机中的去的描述客观事物的符号\n数据元素 数据的基本单位，也称结点或记录\n数据结构 相互之间存在一种或多种特定关系的数据元素的集合\n逻辑结构和存储结构 逻辑结构 数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。\n1.集合 数据元素间除同属于一个集合外，无其他关系 集合中的元素是离散的、无序的、相互之间没有关系的\n2.线性结构 一个对一个  线性表 栈 队列 线性结构像是珠子穿在一根线上，不会分叉，有且只有唯一的开始和结束  3.树形结构 一个对多个 树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支。树枝和树枝之间是不相交的。\n 树  4.图形结构 图形结构就像我们经常见到的地图，任何一个结点都可能和其它结点有关系，就像一张错综复杂的网。\n存储结构 存储结构是数据元素及其关系在计算机中的存储方式。\n1.顺序结构 顺序存储在计算机内的存储位置是连续的，可以快速定位第几个元素的问题。中间不允许有空，所以插入、删除时需要移动大量元素。\n2.链式结构 链式存储就像一个铁链子，一环扣一环才能连在一起。每个结点除了数据域，还有一个指针域，记录下一个元素的存储地址。\n3.散列机构 4.索引结构 算法复杂性 时间复杂度 程序运行所需的时间\n 常数阶 O(1) O(n) O(n²) O(log(n))-二分查找 O(nlogn)-快排  递归时间复杂度 O(T * depth) T是每一次递归的时间复杂度\n最好最坏情况时间复杂度 平均时间复杂度 空间复杂度 程序运行所需的空间\n主要分为两部分：\n 固定部分：指令空间、数据空间（静态空间） 可变空间：动态分配的空间  S(n) = O(f(n))\n","permalink":"https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"\u003ch3 id=\"数据\"\u003e数据\u003c/h3\u003e\n\u003cp\u003e所有能够输入到计算机中的去的描述客观事物的符号\u003c/p\u003e\n\u003ch3 id=\"数据元素\"\u003e数据元素\u003c/h3\u003e\n\u003cp\u003e数据的基本单位，也称结点或记录\u003c/p\u003e\n\u003ch3 id=\"数据结构\"\u003e数据结构\u003c/h3\u003e\n\u003cp\u003e相互之间存在一种或多种特定关系的数据元素的集合\u003c/p\u003e","title":"数据结构概括"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]