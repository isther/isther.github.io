[{"content":"做题笔记。\n2021.11.28 22:35 \u0026ndash; 2021.11.29 1.00\n第一次参加Codeforces的比赛，太菜了\u0026hellip;\nA. Divide and Multiply 题意 据说是500分的题，难度不是很大。大概题意是给一组数，每次操作可以将一个数（必须是偶数）除2，同时将另一个数乘2，求执行最佳操作之后数组和的最大值。\n思路  找到数组元素a[i]因式分解后2的个数$t_i$，$a[i] /= 2*t_i$，处理之后得到了2的个数和t，且所有数组元素都为奇数。 找到处理后的所有数组元素的最大值，乘$2^t$即可得到最大项，加上其余数组元素即可得到最大数组和。  代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 25; int n; ll arr[maxn]; ll fast(ll a, ll base, ll power) { ll ans = a; while (power) { if (power \u0026amp; 1) ans *= base; base *= base; power \u0026gt;\u0026gt;= 1; } return ans; } int main(int argc, char const *argv[]) { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int max = 0; ll power = 0; ll ans = 0; //long long 防爆  for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); while (arr[i] % 2 == 0) { arr[i] /= 2; power++; } if (arr[i] \u0026gt; arr[max]) max = i; ans += arr[i]; } ans += fast(arr[max], 2, power) - arr[max];//猥琐一点加了快速幂防止超时  cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }   B. William the Vigilant 题意 给一个字符串s，只包含字符a、b、c，再给定一个数字q，接下来给出q组操作(pos,c)，每次操作将字符串s中第pos个字符变成给出的字符c，然后输出改变后的字符串还需要最少修改几个字符使得这个字符串没有子串abc。\n思路 这题暴力遍历会超时。可以提前统计字串数量，每一次操作分情况讨论abc字串的数量变化。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int N = 1e5 + 5; int n, q; string s; int pos; char c; int ans; void init() { ans = 0; for (int i = 0; i \u0026lt; n; i++) if (i + 2 \u0026lt; n \u0026amp;\u0026amp; s[i] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[i + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[i + 2] == \u0026#39;c\u0026#39;) ans++; } void find() { pos = pos - 1; if (s[pos] == \u0026#39;a\u0026#39;) { if (s[pos + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos + 2] == \u0026#39;c\u0026#39;) if (c != \u0026#39;a\u0026#39;) ans--; if (c == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;c\u0026#39;) ans++; if (c == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; s[pos - 2] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;b\u0026#39;) ans++; } if (s[pos] == \u0026#39;b\u0026#39;) { if (s[pos - 1] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;c\u0026#39;) if (c != \u0026#39;b\u0026#39;) ans--; if (c == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos + 2] == \u0026#39;c\u0026#39;) ans++; if (c == \u0026#39;c\u0026#39; \u0026amp;\u0026amp; s[pos - 2] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;b\u0026#39;) ans++; } if (s[pos] == \u0026#39;c\u0026#39;) { if (s[pos - 2] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;b\u0026#39;) if (c != \u0026#39;c\u0026#39;) ans--; if (c == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos + 2] == \u0026#39;c\u0026#39;) ans++; if (c == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; s[pos - 1] == \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[pos + 1] == \u0026#39;c\u0026#39;) ans++; } s[pos] = c; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } void solve() { scanf(\u0026#34;%d %c\u0026#34;, \u0026amp;pos, \u0026amp;c); find(); } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;q); cin \u0026gt;\u0026gt; s; init(); while (q--) { solve(); } return 0; }   C. Complex Market Analysis 题意 题目比较好理解，给定n, e和一个含n个元素的数组。\n(i,k)需要满足以下条件：\n $1\u0026lt;=i,k$ $i+e*k\u0026lt;=n$ $a_i \\cdot a_{i+e} \\cdot a_{i+2e} \\cdot \u0026hellip; \\cdot a_{i+ke}$是一个质数。  求出满足条件的(i,k)的对数。\n思路 考虑到第三个条件的限制，需要满足多项式的每一项有且只有一个质数，其他项都为1。刚开始做就是暴力遍历，但是超时，需要继续剪枝。考虑到有且只有一个质数，那么可以从质数下手，去找满足条件的1，这样消耗就会小很多。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 1e6 + 5; int n, e; int arr[maxn]; int prime[maxn]; void isprime() { for (int i = 1; i \u0026lt; maxn; i++) prime[i] = 1; prime[1] = 0; for (int i = 2; i \u0026lt; maxn; i++) { if (prime[i] == 1) for (int j = 2; j * i \u0026lt; maxn; j++) { prime[i * j] = 0; } } } void solve() { ll cnt = 0; for (int i = 1; i \u0026lt;= n; i++) { //******************************  if (prime[arr[i]] == 1) { //找到质数  ll l = 0, r = 0; for (int t = i + e; t \u0026lt;= n; t += e) {//向右找1  if (arr[t] == 1) r++; else break; } for (int t = i - e; t \u0026gt;= 1; t -= e) {//向左找1  if (arr[t] == 1) l++; else break; } cnt += l + r + l * r; //统计答案  } //******************************  } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } int main() { isprime();//数据范围1e6，质数筛打表节约判断时间  int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;e); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } solve(); } return 0; }   统计答案这一步，这个质数左边有l个1，右边有r个1。\n 只考虑左边及质数，共l种情况。 只考虑质数及右边，共r种情况。 考虑左边+质数+右边，共l*r种情况。  D. Social Network 题意 共n个人，d个关系对(a,b)，每个关系对可以介绍a和b两个人认识， 每次介绍之后输出熟人最多的数量。\n题目有个坑点，在分析第二个样例的时候可以发现第四次操作，1、4连接之后，答案明明应该是3，但是正确答案却是4。\n题目中还有一句话需要注意：\n即如果1、4已经认识，那么就把1或4介绍给另一个大连通块认识。\n思路 并查集，先检查是否在同一连通块，如果在同一连通块，那就与另一个大连通块连通。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 1005; int n, d; int parent[maxn]; int temp[maxn]; int sz[maxn]; void init() { for (int i = 1; i \u0026lt;= n; i++) { parent[i] = i; sz[i] = 1; } } int find(int x) { return x == parent[x] ? x : parent[x] = find(parent[x]); } bool merge(int x, int y) { x = find(x); y = find(y); if (x != y) { parent[x] = y; sz[y] += sz[x]; return true; } return false; } int main(int argc, char const *argv[]) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;d); init(); int cnt = 1;//大连通块数量  for (int i = 0, x, y; i \u0026lt; d; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if (!merge(x, y)) cnt++; vector\u0026lt;int\u0026gt; temp; for (int i = 1; i \u0026lt;= n; i++) if (parent[i] == i) temp.push_back(sz[i]); sort(temp.rbegin(), temp.rend()); cout \u0026lt;\u0026lt; accumulate(temp.begin(), temp.begin() + cnt, 0) - 1 \u0026lt;\u0026lt; endl; } return 0; }   ","permalink":"https://www.niuwx.cn/posts/algorithm/deltix-round-autumn-2021-open-for-everyone-rated-div.-1-+-div.-2/","summary":"\u003cp\u003e做题笔记。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2021.11.28 22:35  \u0026ndash;  2021.11.29  1.00\u003c/strong\u003e\u003c/p\u003e","title":"Deltix Round, Autumn 2021 (open for everyone, rated, Div. 1 + Div. 2)"},{"content":"本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\n简单示例 应用代码 以这段简单的go web代码为例进行介绍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, HandleHello) server := \u0026amp;http.Server{ Addr: \u0026#34;:9090\u0026#34;, } fmt.Println(\u0026#34;Server startup...\u0026#34;) if err := server.ListenAndServe(); err != nil { fmt.Printf(\u0026#34;Server startup failed, err:%v\\n\u0026#34;, err) } } func HandleHello(w http.ResponseWriter, _ *http.Request) { w.Write([]byte(\u0026#34;Hello World\u0026#34;)) }   编写Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  FROMgolang:alpine# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .# 声明服务端口EXPOSE9090# 启动容器时运行的命令CMD [\u0026#34;/app\u0026#34;]  构建镜像 使用命令构建镜像。\n1  docker build . -t goweb   使用镜像 1  docker run -p 9090:9090 --name goweb-app goweb   使用-p来映射端口，这里容器中的应用需要在9090端口上运行，将其映射到主机的9090端口。也可以将其映射到其他端口，例如-p 8080:9090。\n分段构建 在编译Go程序之后，我们得到了一个可执行的二进制文件，在最终的镜像中我们是不需要go编译器的，只需要一个可以运行二进制文件的容器即可。所以可以通过分段构建，第一步编译出二进制可执行文件，第二步将该可执行文件放进可以运行的环境即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  FROMgolang:alpine AS builder# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .#################### 最终的小镜像###################FROMscratch# 从builder镜像中把/app 拷贝到当前目录COPY --from=builder /build/app /# 需要运行的命令ENTRYPOINT [\u0026#34;/app\u0026#34;]  通过分段构建，我们就得到了一个体积非常小的镜像。\n静态资源的拷贝 如果需要部署的程序还需要用到静态资源，那么还需要将静态资源拷贝到镜像中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  FROMgolang:alpine AS builder# 设置镜像环境变量ENV GO111MODULE=on \\  CGO_ENABLED=0 \\  GOOS=linux \\  GOARCH=amd64 # 移动到工作目录：/buildWORKDIR/build# 将本目录下代码复制到容器中COPY . .# 将我们的代码编译成二进制可执行文件appRUN go build -o app .#################### 最终的小镜像###################FROMscratchCOPY /templates /templatesCOPY /static /static# 从builder镜像中把/app 拷贝到当前目录COPY --from=builder /build/app /# 需要运行的命令ENTRYPOINT [\u0026#34;/app\u0026#34;]  ","permalink":"https://www.niuwx.cn/posts/go/docker_go/","summary":"\u003cp\u003e本文介绍了如何在Docker中部署Go Web 应用，包含了镜像构建、分段构建。\u003c/p\u003e","title":"Docker部署Go Web应用"},{"content":"本文以Oh-my-zsh为例，Oh-my-post同样适用。\n如图，使用Windows Terminal连接服务器使用Zsh命令行时，会出现乱码，导致主题无法正常显示。\n解决方法 安装Nerd Fonts，下载喜欢的字体然后右键选择“为所有用户安装”，打开Windows Terminal修改settings.json中的\u0026quot;fontFace\u0026quot;项为Nerd字体即可，注意要更改为其显示的正式名称。\n","permalink":"https://www.niuwx.cn/posts/zsh/zsh/","summary":"\u003cp\u003e本文以Oh-my-zsh为例，Oh-my-post同样适用。\u003c/p\u003e","title":"Windows oh-my-zsh 命令行出现乱码的原因及解决办法"},{"content":"This is a test for hugo.\n1 2 Test\n1 2 3 4 5 6 7  package main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;Hello World\u0026#34;) }   ","permalink":"https://www.niuwx.cn/posts/hello-test/","summary":"\u003cp\u003e\u003cstrong\u003eThis is a test for hugo.\u003c/strong\u003e\u003c/p\u003e","title":"Hello Test"},{"content":"","permalink":"https://www.niuwx.cn/friends/","summary":"","title":""}]