<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ther&#39;s Blog</title>
    <link>https://www.niuwx.cn/</link>
    <description>Recent content on Ther&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 30 Jul 2021 10:02:51 +0800</lastBuildDate><atom:link href="https://www.niuwx.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang学习笔记</title>
      <link>https://www.niuwx.cn/posts/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 13 Mar 2021 10:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Golang学习笔记目录，记录点滴。</description>
      <content:encoded><![CDATA[<p>这里将记录Golang学习的笔记。</p>
<h3 id="go基础">Go基础</h3>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/">Go语言基础之变量与常量</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Go语言基础之基本数据类型</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/">Go语言基础之运算符</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">Go语言基础之流程控制</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/">Go语言基础之数组</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/">Go语言基础之切片</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/">Go语言基础之map</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/">Go语言基础之函数</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/">Go语言基础之指针</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%B8%80%EF%BC%89/">Go语言基础之结构体（一）</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%BA%8C%EF%BC%89/">Go语言基础之结构体（二）</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/">Go语言基础之接口</a></p>
<p><a href="https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/">Go语言基础之并发</a></p>]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL安全管理</title>
      <link>https://www.niuwx.cn/posts/mysql/mysql%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 30 Jul 2021 10:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/mysql%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/</guid>
      <description>简单介绍了一下数据库</description>
      <content:encoded><![CDATA[<p>结构-&gt;执行-&gt;管理-&gt;用户</p>
<h3 id="外键约束">外键约束</h3>
<p><strong>概念</strong>：<code>foreign key</code>，表中<strong>指向外部主键</strong>的字段</p>
<ul>
<li>外键必须要通过语法指定才能称之为外键
<ul>
<li><code>[constraint 外键名] foreign key (当前表字段名) references 外部表(主键字段)</code></li>
</ul>
</li>
<li>外键构成条件
<ul>
<li>外键字段必须与对应表的主键字段类型一致</li>
<li>外键字段本身要求是一个索引（创建外键会自动生成一个索引）</li>
</ul>
</li>
</ul>
<h5 id="示例">示例</h5>
<ol>
<li>
<p>创建专业表和学生表，学生表中的专业id指向专业表id</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 专业表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span> (
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">unique</span>
) <span style="color:#66d9ef">charset</span> utf8;

<span style="color:#75715e"># 学生表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t2</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	c_id <span style="color:#66d9ef">int</span> comment <span style="color:#e6db74">&#39;指向专业表t1的主键&#39;</span>
	<span style="color:#66d9ef">constraint</span> <span style="color:#f92672">`</span>c_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">FOREIGN</span> <span style="color:#66d9ef">KEY</span>(c_id) <span style="color:#66d9ef">REFERENCES</span> <span style="color:#a6e22e">t1</span>(id)
) <span style="color:#66d9ef">charset</span> utf8;
</code></pre></div><p>外键可以不指定名字，系统会自动生成</p>
</li>
</ol>
<h4 id="外键约束-1">外键约束</h4>
<ul>
<li>当表建立外键关系后，外键就会对主表和子表里的数据产生约束效果</li>
<li>外键约束的是写操作（默认操作）
<ul>
<li>新增：子表插入的数据对应的外键必须在主表存在</li>
<li>修改：主表的记录如果在子表存在，那么主表的主键不能修改（其他字段可修改）</li>
<li>删除：主表的记录如果在子表存在，那么主表的主键不能删除</li>
</ul>
</li>
<li>外键约束控制：外键可以定义时控制外键的约束作用
<ul>
<li>控制类型
<ul>
<li><code>on update</code>：父表更新时子表的表现</li>
<li><code>on delete</code>：父表删除时子表的表现</li>
</ul>
</li>
<li>控制方式
<ul>
<li><code>cascade</code>：级联操作，父表操作后自编跟随操作</li>
<li><code>set null</code>：置空操作，父表操作后，子表关联的外键字段置空</li>
<li><code>restrict/no action</code>：严格模式，不允许父表操作（默认）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="示例-1">示例</h5>
<ol>
<li>
<p>子表不能插入主表不存在的数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Tony&#39;</span>,<span style="color:#ae81ff">2</span>);<span style="color:#75715e"># 此时父表中还没有id=2的记录，错误
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;English&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Peny&#39;</span>,<span style="color:#ae81ff">1</span>);
</code></pre></div></li>
<li>
<p>默认的外键产生后，主键不能更新被关联的主键字段或者删除被关联的主键记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div></li>
<li>
<p>限制外键约束，一般使用更新级联，删除置空</p>
<ul>
<li><code>on update cascade</code>：更新级联</li>
<li><code>on delete set null</code>：删除置空</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t3</span>(
    id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
    name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">unique</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t4</span>(
    id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
    name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    c_id <span style="color:#66d9ef">int</span> , <span style="color:#75715e"># 如果允许置空，就不能not null
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">FOREIGN</span> <span style="color:#66d9ef">KEY</span>(c_id) <span style="color:#66d9ef">references</span> <span style="color:#a6e22e">t3</span>(id) <span style="color:#66d9ef">on</span> <span style="color:#66d9ef">update</span> <span style="color:#66d9ef">cascade</span> <span style="color:#66d9ef">on</span> <span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">set</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t3 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Chinese&#39;</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Computer&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t4 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Tony&#39;</span>,<span style="color:#ae81ff">1</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Lily&#39;</span>,<span style="color:#ae81ff">2</span>);
</code></pre></div><ul>
<li>子表依然不允许插入父表不存在的外键</li>
<li>但是可以插入外键为Null的数据</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Lilei&#39;</span>,<span style="color:#ae81ff">3</span>);

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#a6e22e">vlaues</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Lilei&#39;</span>,<span style="color:#66d9ef">null</span>);
</code></pre></div><ul>
<li>父表的更新（主键）会让关联的外键自动级联更新</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> id  <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div></li>
</ol>
<h4 id="外键管理">外键管理</h4>
<ul>
<li>
<p>在表创建后期维护外键</p>
</li>
<li>
<p>新增外键</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">add</span> [<span style="color:#66d9ef">constraint</span> <span style="color:#f92672">`</span><span style="color:#960050;background-color:#1e0010">外键名</span><span style="color:#f92672">`</span>] <span style="color:#66d9ef">foreign</span> <span style="color:#66d9ef">key</span>(<span style="color:#960050;background-color:#1e0010">外键字段</span>) <span style="color:#66d9ef">references</span> <span style="color:#960050;background-color:#1e0010">表名</span>(<span style="color:#960050;background-color:#1e0010">主键</span>) [<span style="color:#66d9ef">on</span> <span style="color:#960050;background-color:#1e0010">外键约束</span>]
</code></pre></div></li>
<li>
<p>删除外键</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">foreign</span> <span style="color:#66d9ef">key</span> <span style="color:#960050;background-color:#1e0010">外键名</span>;
</code></pre></div></li>
<li>
<p>更新外键：先删除后新增</p>
</li>
</ul>
<h3 id="事务安全">事务安全</h3>
<p><strong>事务</strong>：要做的某个事情</p>
<ul>
<li>
<p>计算机中的事务是指某个程序执行单元（写操作）</p>
</li>
<li>
<p>事务安全：当事务执行后，保障事务的执行是有效的，而不会导致数据错乱</p>
</li>
<li>
<p>事务安全通常针对的是一连串的操作（多个事务）而产生的统一结果</p>
</li>
<li>
<p>MySQL中默认的写操作是直接写入的</p>
<ul>
<li>执行写操作SQL</li>
<li>同步到数据表</li>
</ul>
</li>
</ul>
<h5 id="示例-2">示例</h5>
<p>银行转账</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	account <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>,<span style="color:#ae81ff">10000</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Lucy&#39;</span>,<span style="color:#ae81ff">100</span>);

<span style="color:#75715e"># Tom扣钱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">-</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#75715e"># Lucy收钱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">+</span> <span style="color:#ae81ff">1000</span>;
</code></pre></div><ul>
<li>扣钱，收钱两步都成功转账才叫成功</li>
<li>为了保障两步都成功才能叫事务安全</li>
</ul>
<h4 id="事务处理">事务处理</h4>
<ul>
<li>利用手动或者手动方式实现事务管理</li>
<li>自动事务处理：系统默认，操作结束直接同步到数据表（事务关闭状态）
<ul>
<li>系统控制：变量<code>autocommit</code>（值为ON，自动提交）</li>
</ul>
</li>
<li>手动事务处理
<ul>
<li>开启事务：<code>start transaction</code></li>
<li>关闭事务：
<ul>
<li>提交事务：<code>commit</code>，同步到数据表，同时清空日志数据</li>
<li>回滚事务：<code>rollback</code> 只清空日志数据</li>
</ul>
</li>
</ul>
</li>
<li>事务回滚：在长事务执行中，可以在某个已经成功的节点设置回滚点，后续回滚的可以回到某个成功点
<ul>
<li>设置回滚点：<code>savepoint 回滚点名字</code></li>
<li>回滚到回滚点：<code>rollback to 回滚点名字</code></li>
</ul>
</li>
</ul>
<h5 id="示例-3">示例</h5>
<ol>
<li>
<p>手动事务：启用事务转账，成功提交事务</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 开启事务
</span><span style="color:#75715e"></span>start transaction;

<span style="color:#75715e"># Tom扣钱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">-</span> <span style="color:#ae81ff">1000</span>;

<span style="color:#75715e"># Lucy收钱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">+</span> <span style="color:#ae81ff">1000</span>;

<span style="color:#75715e"># 提交事务
</span><span style="color:#75715e"></span>commit;
</code></pre></div></li>
<li>
<p>手动事务：启用事务转账，成功提交事务（回滚点）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 开启事务
</span><span style="color:#75715e"></span>start transaction;

<span style="color:#75715e"># Tom扣钱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">-</span> <span style="color:#ae81ff">1000</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#75715e"># 设置回滚点
</span><span style="color:#75715e"></span>savepoint spl;

<span style="color:#75715e"># Lucy收钱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">+</span> <span style="color:#ae81ff">1000</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#75715e"># 操作失败回到回滚点
</span><span style="color:#75715e"></span>rollback spl;

<span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">-</span> <span style="color:#ae81ff">1000</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;

<span style="color:#75715e"># 提交事务
</span><span style="color:#75715e"></span>commit;
</code></pre></div></li>
<li>
<p>自动事务</p>
<ul>
<li>MySQL默认自动提交事务，事务一旦发生就会立即写入数据表</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;autucommit&#39;</span>;
</code></pre></div><ul>
<li>关闭自动提交事务（当前设置级别用户级：当前用户当此连接有效）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><ul>
<li>手动提交事务</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Liu&#39;</span>,<span style="color:#ae81ff">1000</span>);
commit;
</code></pre></div></li>
</ol>
<h4 id="事务特点">事务特点</h4>
<ul>
<li>ACID四大特性</li>
<li>原子性(Atomicity)：一个事务操作是一个整体，不可拆分，要么都成功，要么都失败</li>
<li>一致性(Consistency)：事务执行之前和执行之后都必须处于一致性状态，数据的完整性没有被破坏（事务逻辑的准确性）</li>
<li>隔离性(Isolation)：事务操作过程中，其他事务不可见</li>
<li>持久性(Durability)：事务一旦提交，结果不可改变</li>
</ul>
<h3 id="预处理">预处理</h3>
<p><strong>预处理</strong>：prepare statement，一种预先编译SQL指令的方式</p>
<ul>
<li>预处理不同于直接处理，是将要执行的SQL指令先发送给服务器编译，然后通过指令执行
<ul>
<li>发送预处理：<code>prepare 预处理名字 from '要执行的SQL指令'</code></li>
<li>执行预处理：<code>execute 预处理名字</code></li>
</ul>
</li>
<li>预处理管理
<ul>
<li>预处理属于会话级别：即当前用户当次连接有效（断开会被服务器清理掉）</li>
<li>删除预处理：<code>deallocate | drop 预处理名字</code></li>
</ul>
</li>
</ul>
<h5 id="示例-4">示例</h5>
<p>查询学生的SQL指令需要重复执行很多次</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 普通操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;

<span style="color:#75715e"># 预处理操作：发送预处理
</span><span style="color:#75715e"></span>prepare pl <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;select * from t1&#39;</span>;

<span style="color:#75715e"># 预处理操作：执行预处理
</span><span style="color:#75715e"></span>execute pl;
 
<span style="color:#75715e"># 删除预处理
</span><span style="color:#75715e"></span>deallocate <span style="color:#f92672">|</span> <span style="color:#66d9ef">drop</span> pl;
</code></pre></div><h4 id="预处理传参">预处理传参</h4>
<ul>
<li>
<p>在执行预处理的时候传入预处理需要的可变数据</p>
</li>
<li>
<p>一般预处理都不会是固定死的SQL指令，而是具有一些数据可变的执行（条件）</p>
<ul>
<li>
<p>可变数据的位置使用占位符<code>?</code>占位</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">prepare <span style="color:#960050;background-color:#1e0010">预处理名字</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;预处理指令  变化部分使用?代替&#39;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>在执行预处理的时候将实际数据传进去代替占位符执行SQL</p>
<ul>
<li>
<p>数据存储到变量（预处理传入的值必须是变量保存的）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span><span style="color:#960050;background-color:#1e0010">变量名</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">值</span>
</code></pre></div></li>
<li>
<p>使用using关键字传参</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">execute <span style="color:#960050;background-color:#1e0010">预处理名字</span> <span style="color:#66d9ef">using</span> <span style="color:#f92672">@</span><span style="color:#960050;background-color:#1e0010">变量名</span>
</code></pre></div></li>
<li>
<p>数据传入的顺序与预处理中占位符的顺序一致</p>
</li>
</ul>
</li>
</ul>
<h5 id="示例-5">示例</h5>
<p>向表中插入数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 准备预处理：涉及参数
</span><span style="color:#75715e"></span>prepare t1 <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">from</span> <span style="color:#e6db74">&#39;insert into t1 values(null,?,?,?,?)&#39;</span>;

<span style="color:#75715e"># 设置变量并传入参数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;药师兜&#39;</span>;
<span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>gender <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;男&#39;</span>;
<span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>;
<span style="color:#66d9ef">set</span> <span style="color:#f92672">@</span>class_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;木叶1班&#39;</span>;

<span style="color:#75715e">#执行预处理
</span><span style="color:#75715e"></span>execute t1 <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">using</span> <span style="color:#f92672">@</span>name,<span style="color:#f92672">@</span>gender,<span style="color:#f92672">@</span>age,<span style="color:#f92672">@@</span>class_name;
</code></pre></div><h3 id="视图">视图</h3>
<p><strong>视图</strong>：view，一种由select指令组成的虚拟表</p>
<ul>
<li>
<p>视图时虚拟表，可以使用表管理（结构管理）</p>
<ul>
<li>为视图提供数据的表叫做基表</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 创建视图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> view <span style="color:#960050;background-color:#1e0010">视图名字</span> <span style="color:#66d9ef">as</span> select指令;

<span style="color:#75715e"># 访问视图：一般都是查询
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*/</span><span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">视图名字</span>;
</code></pre></div><ul>
<li>
<p>视图有结构，但不存储数据</p>
<ul>
<li>结构：select选择的字段</li>
<li>数据：访问视图时执行的select指令</li>
</ul>
</li>
<li>
<p>对外部系统提供数据支撑(保护基表数据)</p>
</li>
</ul>
<h5 id="示例-6">示例</h5>
<ol>
<li>
<p>需要对外提供一个学生详情的数据，经常使用，可以利用视图实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 对外提供数据，要保护数据本身的安全
</span><span style="color:#75715e"># 需要长期使用
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># 创建视图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> view v_student_info <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t2 <span style="color:#66d9ef">using</span>(c_id);

<span style="color:#75715e"># 使用视图：像表一样使用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> v_student_info;
</code></pre></div></li>
<li>
<p>有些复杂的SQL又是经常用到的，如多张表的连表操作：可以利用视图实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 院系表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;语言系&#39;</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;考古系&#39;</span>);

<span style="color:#75715e"># 专业表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t2</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	s_id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> comment <span style="color:#e6db74">&#39;学院id&#39;</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;English&#39;</span>,<span style="color:#ae81ff">1</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Chinese&#39;</span>,<span style="color:#ae81ff">1</span>);

<span style="color:#75715e"># 学生表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t3</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	s_id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> comment <span style="color:#e6db74">&#39;专业id&#39;</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t3 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Lilei&#39;</span>,<span style="color:#ae81ff">2</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Hanmeimei&#39;</span>,<span style="color:#ae81ff">2</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Tony&#39;</span>,<span style="color:#ae81ff">1</span>);


<span style="color:#75715e"># 获取所有学生的明细信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> stu.<span style="color:#f92672">*</span>,sub.name <span style="color:#66d9ef">as</span> sub_name,sub.s_id <span style="color:#66d9ef">as</span> sch_id,sch.name <span style="color:#66d9ef">as</span> sch_name <span style="color:#66d9ef">from</span> t3 <span style="color:#66d9ef">as</span> stu <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t2 sub <span style="color:#66d9ef">on</span> stu.s_id <span style="color:#f92672">=</span> sub.id <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t1 sch <span style="color:#66d9ef">on</span> sub.s_id <span style="color:#f92672">=</span> sch.id;

<span style="color:#75715e"># 以视图保存这类复杂指令，后续可以直接访问视图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> view v_student_detail <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> stu.<span style="color:#f92672">*</span>,sub.name <span style="color:#66d9ef">as</span> sub_name,sub.s_id <span style="color:#66d9ef">as</span> sch_id,sch.name <span style="color:#66d9ef">as</span> sch_name <span style="color:#66d9ef">from</span> t3 <span style="color:#66d9ef">as</span> stu <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t2 sub <span style="color:#66d9ef">on</span> stu.s_id <span style="color:#f92672">=</span> sub.id <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t1 sch <span style="color:#66d9ef">on</span> sub.s_id <span style="color:#f92672">=</span> sch.id;
</code></pre></div></li>
</ol>
<h4 id="视图管理">视图管理</h4>
<ul>
<li>
<p>视图查看：显示视图结构和具体视图信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">tables</span>; <span style="color:#75715e">#查看全部视图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span><span style="color:#f92672">/</span>view <span style="color:#960050;background-color:#1e0010">视图名字</span>; <span style="color:#75715e"># 查看视图创建指令
</span><span style="color:#75715e"></span><span style="color:#66d9ef">desc</span> <span style="color:#960050;background-color:#1e0010">视图名字</span>; <span style="color:#75715e"># 查看视图结构
</span></code></pre></div></li>
<li>
<p>视图修改：更改视图逻辑</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> view <span style="color:#960050;background-color:#1e0010">视图名</span> <span style="color:#66d9ef">as</span> <span style="color:#960050;background-color:#1e0010">新的查询命令</span>;
<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">or</span> <span style="color:#66d9ef">replace</span> view <span style="color:#960050;background-color:#1e0010">视图名</span> <span style="color:#66d9ef">as</span> <span style="color:#960050;background-color:#1e0010">新的查询命令</span> <span style="color:#75715e"># 创建新的或者替换新的
</span></code></pre></div></li>
<li>
<p>删除视图</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">drop</span> view <span style="color:#960050;background-color:#1e0010">视图名</span>;
</code></pre></div></li>
</ul>
<h4 id="视图的数据操作">视图的数据操作</h4>
<ul>
<li>
<p>视图所有的数据操作都是最终对基表的数据操作</p>
</li>
<li>
<p>视图操作条件</p>
<ul>
<li>
<p>多基表视图：不允许操作</p>
</li>
<li>
<p>单基表视图：允许增删改</p>
<ul>
<li>新增条件：视图的字段必须包含基表中所有不允许为空的字段</li>
</ul>
</li>
<li>
<p><code>with check option</code>：操作检查规则</p>
<ul>
<li>默认不需要这个规则（创建视图时指定）：视图操作只要满足前面上述条件即可</li>
<li>增加此规则：视图的数据操作后，必须要保证该视图还能把通过视图操作的数据查出来（否则失败）</li>
</ul>
</li>
</ul>
<h5 id="示例-7">示例</h5>
</li>
</ul>
<ol>
<li>
<p>增加一个单表视图和多表视图</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> view v_student_1 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> s_id,s_name <span style="color:#66d9ef">from</span> t1;
<span style="color:#66d9ef">create</span> view v_student_2 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> s.<span style="color:#f92672">*</span>,c.c_name <span style="color:#66d9ef">from</span> t1 s <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t2 c <span style="color:#66d9ef">using</span>(c_id);
<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">or</span> <span style="color:#66d9ef">replace</span> view v_student_3 <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> c_id <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">check</span> <span style="color:#66d9ef">option</span>;
</code></pre></div></li>
<li>
<p>新增数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> v_student_1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student7&#39;</span>); <span style="color:#75715e"># 正确：视图包含所有必有字段
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> v_student_2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student8&#39;</span>,<span style="color:#66d9ef">null</span>,<span style="color:#66d9ef">null</span>) <span style="color:#75715e"># 错误：不可插入
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> v_student_3 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student8&#39;</span>,<span style="color:#66d9ef">null</span>) <span style="color:#75715e"># 错误：check option，因为第三个字段c_id为null,不符合视图筛选条件，查不出来
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> v_student_3 <span style="color:#a6e22e">valeus</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student9&#39;</span>,<span style="color:#ae81ff">1</span>) <span style="color:#75715e"># 正确
</span></code></pre></div></li>
<li>
<p>更新数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">update</span> v_student_1 <span style="color:#66d9ef">set</span> s_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;boy&#39;</span> <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
<span style="color:#66d9ef">update</span> v_student_2 <span style="color:#66d9ef">set</span> s_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;boy&#39;</span> <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>; <span style="color:#75715e"># 错误：不可修改 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> v_student_3 <span style="color:#66d9ef">set</span> c_id <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e"># 错误：check option，修改后c_id为null，变得不符合视图筛选条件
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> v_student_3 <span style="color:#66d9ef">set</span> s_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;boy&#39;</span> <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div></li>
<li>
<p>删除数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> v_student_1 <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> v_student_2 <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e"># 错误：不可修改
</span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> v_student_3 <span style="color:#66d9ef">where</span> s_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e"># 可以删除，check option不影响删除操作
</span></code></pre></div></li>
</ol>
<h4 id="视图算法">视图算法</h4>
<ul>
<li>
<p>视图在执行过程中对于内部的<code>select</code>指令的处理方式</p>
</li>
<li>
<p>视图算法在创建视图时指定</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> ALGORITHM <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">算法</span> view <span style="color:#960050;background-color:#1e0010">视图名字</span> <span style="color:#66d9ef">as</span> select指令;
</code></pre></div></li>
<li>
<p>视图算法一共有三种</p>
<ul>
<li><code>undefined</code>：默认的，未定义算法，即系统自动选择算法</li>
<li><code>merge</code>：合并算法，就是将视图外部查询语句跟视图内部select语句合并执行，效率高（系统优先选择）</li>
<li><code>temptable</code>：临时表算法，即系统将视图的select语句查出来先得出一张临时表，然后外部再查询（temptable算法视图不允许写操作）</li>
</ul>
</li>
</ul>
<h3 id="数据备份与还原">数据备份与还原</h3>
<h4 id="表数据备份">表数据备份</h4>
<ul>
<li>单独针对表里的<strong>数据部分</strong>进行备份（数据导出）</li>
<li>将数据从表中查出，按照一定格式存储到外部文件
<ul>
<li>字段格式化：<code>fields</code>
<ul>
<li><code>terminated by</code>：字段数据结束后使用的符号，默认是空格</li>
<li><code>enclosed by</code>：字段数据包裹，默认什么都没有</li>
<li><code>escaped by</code>：特殊字符的处理，默认是转义</li>
</ul>
</li>
<li>行格式化：<code>lines</code>
<ul>
<li><code>terminated by</code>：行结束符号，默认是\n，自动换行</li>
<li><code>starting by</code>：行开始符号，默认没有</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#960050;background-color:#1e0010">字段列表</span><span style="color:#f92672">|*</span> <span style="color:#66d9ef">into</span> <span style="color:#66d9ef">outfile</span> <span style="color:#e6db74">&#39;外部文件路径&#39;</span>
	[fields <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span> <span style="color:#66d9ef">enclosed</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span>]
	[<span style="color:#66d9ef">lines</span> <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span> <span style="color:#66d9ef">starting</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span>]
<span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">数据表</span>;
</code></pre></div><ul>
<li>表数据备份不限定数据的来源是一张表还是多张表（可以连表）</li>
</ul>
<h4 id="表数据还原">表数据还原</h4>
<ul>
<li>将<strong>符合数据结构</strong>的数据导入到数据表中（数据导入）</li>
<li>将一定格式的数据按照一定的解析方式解析成符合表字段格式的数据导入到数据表
<ul>
<li>字段处理</li>
<li>行处理</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">load</span> data <span style="color:#66d9ef">infile</span> <span style="color:#e6db74">&#39;数据文件所在路径&#39;</span> <span style="color:#66d9ef">into</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span>
	[fields <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span> <span style="color:#66d9ef">enclosed</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span>]
	[<span style="color:#66d9ef">lines</span> <span style="color:#66d9ef">terminated</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span> <span style="color:#66d9ef">starting</span> <span style="color:#66d9ef">by</span> <span style="color:#960050;background-color:#1e0010">格式</span>]
	[(<span style="color:#960050;background-color:#1e0010">字段列表</span>)];
</code></pre></div><ul>
<li>数据文件来源
<ul>
<li>表数据备份的数据文件</li>
<li>外部获取或者制作的符合格式的数据</li>
</ul>
</li>
</ul>
<h4 id="文件备份">文件备份</h4>
<ul>
<li>直接对数据表进行文件保留，属于物理备份</li>
<li>文件备份操作简单，直接将数据表（或者数据库文件夹）进行保存迁移</li>
<li>MySQL中不同表存储引擎产生的文件不一致，保存手段也不一致
<ul>
<li>InnoDB：表结构文件再ibd文件夹中，数据和索引存储在外部统一的ibdata文件夹中</li>
<li>MyIsam：每张表的数据、结构和索引都是独立文件，直接找到三个文件迁移即可</li>
</ul>
</li>
</ul>
<h4 id="文件还原">文件还原</h4>
<ul>
<li>利用备份的文件，替换出现问题的文件，还原到备份前的良好状态</li>
<li>直接将备份文件放到相应位置即可</li>
<li>文件还原影响
<ul>
<li>InnoDB：单表结构，整库数据，知识和整库备份还原，否则会影响其他InnoDB存储表</li>
<li>MyIsam：单表备份，单表还原，不影响其他任何数据</li>
</ul>
</li>
</ul>
<p>​</p>]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL多表操作</title>
      <link>https://www.niuwx.cn/posts/mysql/mysql%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 29 Jul 2021 20:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/mysql%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>简单介绍了一下MySQL多表操作</description>
      <content:encoded><![CDATA[<p><strong>多表</strong>：因为单表会出现数据冗余，所以采用多表的方式</p>
<h3 id="联合查询">联合查询</h3>
<h4 id="联合查询-1">联合查询</h4>
<ul>
<li>
<p><code>union</code>，是指将多个查询结果合并成一个结果显示</p>
</li>
<li>
<p>联合查询是针对查询结果的合并（多条select语句合并）</p>
</li>
<li>
<p>联合查询语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#960050;background-color:#1e0010">查询</span> <span style="color:#75715e"># 决定字段表
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">union</span> <span style="color:#960050;background-color:#1e0010">查询选项</span>
<span style="color:#66d9ef">select</span> <span style="color:#960050;background-color:#1e0010">查询</span>
...
</code></pre></div></li>
<li>
<p>联合查询要求：联合查询是结果联合显示</p>
<ul>
<li>多个联合查询的字段结果数量一致</li>
<li>联合查询的字段来源于第一个查询语句的字段</li>
</ul>
</li>
<li>
<p>查询选项：与<code>select</code>选项一样</p>
<ul>
<li><code>all</code>：保留所有记录</li>
<li><code>distinct</code>：保留去重记录（默认）</li>
</ul>
</li>
</ul>
<h5 id="示例">示例</h5>
<ol>
<li>
<p>创建一个表，并插入数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> t2 <span style="color:#66d9ef">like</span> t1;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;犬夜叉&#39;</span>, <span style="color:#e6db74">&#39;男&#39;</span>, <span style="color:#ae81ff">200</span>, <span style="color:#e6db74">&#39;神妖1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;日暮戈薇&#39;</span>, <span style="color:#e6db74">&#39;女&#39;</span>, <span style="color:#ae81ff">16</span>, <span style="color:#e6db74">&#39;现代1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;桔梗&#39;</span>, <span style="color:#e6db74">&#39;女&#39;</span>, <span style="color:#ae81ff">88</span>, <span style="color:#e6db74">&#39;法师1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;弥勒&#39;</span>, <span style="color:#e6db74">&#39;男&#39;</span>, <span style="color:#ae81ff">28</span>, <span style="color:#e6db74">&#39;法师2班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;珊瑚&#39;</span>, <span style="color:#e6db74">&#39;女&#39;</span>, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#39;法师2班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;七宝&#39;</span>, <span style="color:#e6db74">&#39;保密&#39;</span>, <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;宠物1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;杀生丸&#39;</span>, <span style="color:#e6db74">&#39;男&#39;</span>, <span style="color:#ae81ff">220</span>, <span style="color:#e6db74">&#39;神妖1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;铃&#39;</span>, <span style="color:#e6db74">&#39;女&#39;</span>, <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;现代1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;钢牙&#39;</span>, <span style="color:#e6db74">&#39;男&#39;</span>, <span style="color:#ae81ff">68</span>, <span style="color:#e6db74">&#39;神妖1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;奈落&#39;</span>, <span style="color:#e6db74">&#39;男&#39;</span>, <span style="color:#ae81ff">255</span>, <span style="color:#e6db74">&#39;神妖1班&#39;</span>),
  (<span style="color:#66d9ef">null</span>, <span style="color:#e6db74">&#39;神乐&#39;</span>, <span style="color:#e6db74">&#39;女&#39;</span>, <span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#39;神妖2班&#39;</span>);
</code></pre></div><pre><code> t1与t2结构一致，可以理解为因为数据量较大，拆分到两个表中
</code></pre>
</li>
<li>
<p>使用联合查询两张表的数据拼接到一起显示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1
<span style="color:#66d9ef">union</span>
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> form t2;
</code></pre></div></li>
<li>
<p>联合查询选项默认是<code>distinct</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1
<span style="color:#66d9ef">union</span>
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2;

<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1
<span style="color:#66d9ef">union</span> <span style="color:#66d9ef">all</span>
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2;
</code></pre></div></li>
<li>
<p>联合查询不要求字段类型一致，只对数量要求一致，而且字段名称与第一条查询语句相关</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> name <span style="color:#66d9ef">from</span> t1
<span style="color:#66d9ef">union</span>
<span style="color:#66d9ef">select</span> age <span style="color:#66d9ef">from</span> t2;
</code></pre></div><p>如果数据不能与字段对应，那么查询没有意义</p>
</li>
</ol>
<h4 id="联合查询排序">联合查询排序</h4>
<ul>
<li>针对联合查询的结果进行排序</li>
<li><code>order by</code>本身是对内存结果进行排序，<code>union</code>的优先级高于<code>order by</code>，所以<code>order by</code>默认是对<code>union</code>结果进行排序</li>
<li>如果想对单独<code>select</code>的结果进行排序，需要两个步骤
<ul>
<li>将需要排序的<code>select</code>指令进行括号包裹（括号使用order by）</li>
<li><code>order by</code>必须配合<code>limit</code>才能生效（limit一个足够大的数值即可）</li>
</ul>
</li>
</ul>
<h5 id="示例-1">示例</h5>
<ol>
<li>
<p>将t1和t2表的结果使用年龄降序排序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1
<span style="color:#66d9ef">union</span> <span style="color:#66d9ef">all</span>
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2
<span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">desc</span>;
</code></pre></div></li>
<li>
<p>t1表按年龄降序排序，t2表按年龄升序排序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 无效方式
</span><span style="color:#75715e"></span>(<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">desc</span>)
<span style="color:#66d9ef">union</span>
(<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">asc</span>);

<span style="color:#75715e"># 有效方式
</span><span style="color:#75715e"></span>(<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">desc</span> <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">9999</span>)
<span style="color:#66d9ef">union</span>
(<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">asc</span> <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">9999</span>);
</code></pre></div></li>
</ol>
<h3 id="连接查询">连接查询</h3>
<h4 id="交叉连接">交叉连接</h4>
<ul>
<li><code>cross join</code>，不需要任何条件的连接</li>
<li>交叉连接产生的效果就是笛卡尔积
<ul>
<li>左表的每一条记录都会与右表的所有记录连接并保存</li>
</ul>
</li>
<li>交叉连接没有实际数据价值，只是丰富了连接查询的完整性</li>
</ul>
<h5 id="示例-2">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 交叉连接t1和t2表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">cross</span> <span style="color:#66d9ef">join</span> t2;
</code></pre></div><h4 id="内连接">内连接</h4>
<ul>
<li><code>[inner] join</code>，将两张表根据指定的条件连接起来，严格连接</li>
<li>内连接是将一张表的每一个记录去另外一张表根据条件匹配
<ul>
<li>匹配成功：保留连接的数据</li>
<li>匹配失败：都不保留</li>
</ul>
</li>
<li>内连接语法：<code>左表 join 右表 on 连接条件</code></li>
</ul>
<h5 id="示例-3">示例</h5>
<ol>
<li>
<p>设计学生表和专业表：学生对专业多对一关系</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 学生表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	course_no <span style="color:#66d9ef">int</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student1&#39;</span>,<span style="color:#ae81ff">1</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student2&#39;</span>,<span style="color:#ae81ff">1</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student3&#39;</span>,<span style="color:#ae81ff">2</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student4&#39;</span>,<span style="color:#ae81ff">3</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student5&#39;</span>,<span style="color:#ae81ff">1</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;student6&#39;</span>,<span style="color:#66d9ef">default</span>);

<span style="color:#75715e"># 专业表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t2</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">unique</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Computer&#39;</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Software&#39;</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Network&#39;</span>);
</code></pre></div></li>
<li>
<p>获取已经选择了专业的学生信息，包括所选专业</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 学生和专业在两个表中，所以需要连表
</span><span style="color:#75715e"># 学生必须有专业，而专业也必须存在，所以是内连接
</span><span style="color:#75715e"># 连接条件：专业编号
</span><span style="color:#75715e"># 两张表有两个字段冲突：id,name,所以需要使用别名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> t1.<span style="color:#f92672">*</span>,t2.name <span style="color:#66d9ef">as</span> course_name <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">inner</span> <span style="color:#66d9ef">join</span> t2 <span style="color:#66d9ef">on</span> t1.course_no <span style="color:#f92672">=</span> t2.id;

<span style="color:#75715e"># 表名的使用也可以使用别名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> s.<span style="color:#f92672">*</span>,c.name <span style="color:#66d9ef">as</span> c_name <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">as</span> s <span style="color:#66d9ef">inner</span> <span style="color:#66d9ef">join</span> t2 c <span style="color:#66d9ef">on</span> s.course_no <span style="color:#f92672">=</span> c.id;
</code></pre></div></li>
</ol>
<h4 id="外连接">外连接</h4>
<ul>
<li><code>outer join</code>，是一种不严格的连接方式</li>
<li>外连接分为两种
<ul>
<li>左连接：<code>left join</code></li>
<li>右连接：<code>right join</code></li>
</ul>
</li>
<li>外连接有主表和从表之分
<ul>
<li>左连接：左表为主表</li>
<li>右连接：右表为主表</li>
</ul>
</li>
<li>外连接是将主表的记录去匹配从表的记录
<ul>
<li>匹配成功保留</li>
<li>全表匹配失败：也保留，只是从表字段置空</li>
</ul>
</li>
</ul>
<h5 id="示例-4">示例</h5>
<ol>
<li>
<p>查出学生所有信息，包括所在班级（左连接）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 主要数据是学生，而且是全部学生：外连接、且学生表为主表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> s.<span style="color:#f92672">*</span>,c.name c_name <span style="color:#66d9ef">from</span> t1 s <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t2 c <span style="color:#66d9ef">on</span> s.course_no <span style="color:#f92672">=</span> c.id;
</code></pre></div></li>
<li>
<p>查出所有班级里的所有学生</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e">#主表是班级
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> s.<span style="color:#f92672">*</span>,c.name c_name <span style="color:#66d9ef">from</span> t1 s <span style="color:#66d9ef">right</span> <span style="color:#66d9ef">join</span> t2 c <span style="color:#66d9ef">on</span> s.course_no <span style="color:#f92672">=</span> c.id;
</code></pre></div></li>
</ol>
<h4 id="自然连接">自然连接</h4>
<ul>
<li><code>natural join</code>，是一种自动寻找连接条件的连接查询</li>
<li>自然连接不是一种特殊的连接方式，而是自动匹配条件的连接</li>
<li>自然连接包含
<ul>
<li>自然内连接：<code>natural join</code></li>
<li>自然外连接：<code>natural left/right join</code></li>
</ul>
</li>
<li>自然连接条件匹配模式：自动寻找相同字段名作为连接条件</li>
</ul>
<h5 id="示例-5">示例</h5>
<ol>
<li>
<p>自然连接t1和t2表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">natural</span> <span style="color:#66d9ef">join</span> t2;
</code></pre></div></li>
<li>
<p>自然连接是不管字段是否有关系，只管名字是否相同，如果想要自然连接成功，那么字段的设计就必须非常规范</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t11</span>(
	s_id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	s_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	c_id <span style="color:#66d9ef">int</span> comment <span style="color:#e6db74">&#39;课程id&#39;</span>
)<span style="color:#66d9ef">charset</span> utf8;
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t11 <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;

<span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t22</span>(
	c_id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	c_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">unique</span>
)<span style="color:#66d9ef">charset</span> utf8;
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t22 <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2;

<span style="color:#75715e"># 自然连接 成功
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t11 <span style="color:#66d9ef">natural</span> <span style="color:#66d9ef">join</span> t22;
</code></pre></div></li>
</ol>
<h4 id="using-关键字">using 关键字</h4>
<ul>
<li>连接查询时，如果是同名字段作为连接条件，<code>using</code>可以代替<code>on</code>出现，且比<code>on</code>更好
<ul>
<li><code>using</code>是针对同名字段（using(id) === A.id = B.id）</li>
<li><code>using</code>关键字使用后会自动合并对应字段为一个</li>
<li><code>using</code>可以同时使用多个字段作为条件</li>
</ul>
</li>
</ul>
<h5 id="示例-6">示例</h5>
<p>查询t11中所有学生信息，包括所在班级名字</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> s.<span style="color:#f92672">*</span>,c.c_name <span style="color:#66d9ef">from</span> t11 s <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t22 c <span style="color:#66d9ef">using</span>(c_id);
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t11 s <span style="color:#66d9ef">left</span> <span style="color:#66d9ef">join</span> t22 c <span style="color:#66d9ef">using</span>(c_id);
</code></pre></div><h3 id="子查询">子查询</h3>
<h4 id="子查询分类">子查询分类</h4>
<ul>
<li>根据子查询<strong>出现的位置</strong>或者<strong>产生的数据效果</strong>分类
<ul>
<li>位置分类
<ul>
<li><code>from</code>子查询：子查询出现在from后做数据源</li>
<li><code>where</code>子查询：子查询出现在where后做数据条件</li>
</ul>
</li>
<li>按子查询得到的结果分类
<ul>
<li>标量子查询：子查询返回的结果是一行一列（一个数据）</li>
<li>列子查询：子查询返回的结果是一列多行（一列数据）</li>
<li>行子查询：子查询返回的结果是一行多列（一行数据）</li>
<li>表子查询：子查询返回的结果是一个二维表</li>
<li><code>exists</code>子查询：子查询返回的结果是布尔结果（验证型）</li>
</ul>
</li>
</ul>
</li>
<li>子查询都需要使用括号<code>()</code>包裹，必要时需要对子查询结果进行别名处理（from子查询）</li>
</ul>
<h4 id="标量子查询">标量子查询</h4>
<ul>
<li>通常是用来做其他查询的条件</li>
</ul>
<h5 id="示例-7">示例</h5>
<p>获取computer专业的所有学生</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 数据目标：学生表t11
</span><span style="color:#75715e"># 条件：专业名字，不在t11中
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t11 <span style="color:#66d9ef">where</span> c_id <span style="color:#f92672">=</span> (<span style="color:#66d9ef">select</span> c_id <span style="color:#66d9ef">from</span> t_22 <span style="color:#66d9ef">where</span> c_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Computer&#39;</span>);
</code></pre></div><h4 id="列子查询">列子查询</h4>
<ul>
<li>通常是用来做查询条件的</li>
</ul>
<h5 id="示例-8">示例</h5>
<p>获取所有有学生的班级信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 数据获取目标是班级信息
</span><span style="color:#75715e"># 数据获取条件是在学生表中的班级id，是多个
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t22 <span style="color:#66d9ef">where</span> c_id <span style="color:#66d9ef">in</span> (<span style="color:#66d9ef">select</span> c_id <span style="color:#66d9ef">from</span> t11);
</code></pre></div><h4 id="行子查询">行子查询</h4>
<ul>
<li>子查询返回的结果是一行多列</li>
<li>行子查询需要条件中构造元素
<ul>
<li><code>(元素1),(元素2),...(元素N)</code></li>
</ul>
</li>
<li>行子查询通常也是用来作为主查询的条件</li>
</ul>
<h5 id="示例-9">示例</h5>
<p>获取学生表中性别和年龄都和弥勒相同的学生信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 查询条件有多个：性别和年龄
</span><span style="color:#75715e"># 数据的条件的来源在另一张表中
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># 解决思路：两个标量子查询
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> gender <span style="color:#f92672">=</span> (<span style="color:#66d9ef">select</span> gender <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">where</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;弥勒&#39;</span>) <span style="color:#66d9ef">and</span> age <span style="color:#f92672">=</span> (<span style="color:#66d9ef">select</span> <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">where</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;弥勒&#39;</span>);
</code></pre></div><ul>
<li>以上查询方式使用了两次子查询，效率降低</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 构造条件行元素(gender,age)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> (gender,age) <span style="color:#f92672">=</span> (<span style="color:#66d9ef">select</span> gender,age <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">where</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;弥勒&#39;</span>);
</code></pre></div><h4 id="表子查询">表子查询</h4>
<ul>
<li>表子查询多出现在<code>from</code>之后，当作数据源</li>
<li>表子查询通常是为了想对数据进行一次加工处理，然后再交给外部进行二次加工处理</li>
</ul>
<h5 id="示例-10">示例</h5>
<p>获取学生表中每个班级里年龄最大的学生信息，然后按年龄降序排序显示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 尝试直接解决
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">any_value</span>(name),<span style="color:#a6e22e">max</span>(age) m_age, clas_name <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> m_age <span style="color:#66d9ef">desc</span>;
</code></pre></div><ul>
<li>分组统计中<code>any_value()</code>取的是分组后的第一条数据，而需要的是最大</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 解决方案：要入在分组之前将所有班级里的学生本身是降序排序，那么分组的第一条数据就是满足条件的数据，但是问题是order by必须出现在group by之后
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">any_value</span>(name),<span style="color:#a6e22e">max</span>(age),class_name <span style="color:#66d9ef">from</span> (<span style="color:#66d9ef">select</span> name,age,class_name <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">desc</span>) <span style="color:#66d9ef">as</span> t <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name;
</code></pre></div><ul>
<li>依然无效，原因是MySQL7之后若要子查询中``order by<code>生效，需要像联合查询一样，加上</code>limit`</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">any_value</span>(name),<span style="color:#a6e22e">max</span>(age),class_name <span style="color:#66d9ef">from</span> (<span style="color:#66d9ef">select</span> name,age,class_name <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">desc</span> <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">99999</span>) <span style="color:#66d9ef">as</span> t <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name;
</code></pre></div><h4 id="exists子查询">exists子查询</h4>
<ul>
<li><code>exists</code>子查询通常是作为<code>where</code>条件使用
<ul>
<li><code>where exists(子查询)</code></li>
</ul>
</li>
</ul>
<h5 id="示例-11">示例</h5>
<p>获取所有学生的班级信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 获取的数据是班级表t22
</span><span style="color:#75715e"># 班级是否有学生需要在t11中确认，并不需要t11提供任何数据显示
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t22 c <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">exists</span>(<span style="color:#66d9ef">select</span> c_id <span style="color:#66d9ef">from</span> t11 <span style="color:#66d9ef">where</span> c.c_id <span style="color:#f92672">=</span> c_id);
</code></pre></div><h4 id="比较方式">比较方式</h4>
<ul>
<li>特定的比较方式都是基于比较符号一起使用的</li>
<li><code>all</code>：满足后面全部条件
<ul>
<li><code>&gt;all(结果集)</code>：数据要大于结果集中的全部数据</li>
</ul>
</li>
<li><code>any</code>：满足任何条件
<ul>
<li><code>=any(结果集)</code>：数据只要与结果集中的任何一个元素相等</li>
</ul>
</li>
<li><code>some</code>：满足任意条件(与any完全一样)</li>
<li>结果集：可以是直接的数据也可以是子查询的结果（通常是列子查询）</li>
</ul>
<h5 id="示例-12">示例</h5>
<p>找出t1表中与t2表中年龄相同的信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 数据获取在t1表
</span><span style="color:#75715e"># 数据条件在t2表
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># 解决方案1：使用in列子查询
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> age <span style="color:#66d9ef">in</span> (<span style="color:#66d9ef">select</span> <span style="color:#66d9ef">distinct</span> age <span style="color:#66d9ef">from</span> t2);

<span style="color:#75715e"># 解决方案2：使用exists子查询
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">exists</span>(<span style="color:#66d9ef">select</span> id <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">where</span> t1.age <span style="color:#f92672">=</span> age);

<span style="color:#75715e"># 解决方案3：使用any或者some匹配（列子查询）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> age <span style="color:#f92672">=</span> <span style="color:#a6e22e">some</span>(<span style="color:#66d9ef">select</span> age <span style="color:#66d9ef">from</span> t2);
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL高级SQL操作</title>
      <link>https://www.niuwx.cn/posts/mysql/mysql%E9%AB%98%E7%BA%A7sql%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 28 Jul 2021 10:31:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/mysql%E9%AB%98%E7%BA%A7sql%E6%93%8D%E4%BD%9C/</guid>
      <description>简单介绍了一下高级SQL操作</description>
      <content:encoded><![CDATA[<p>常见的SQL高级操作，主要集中在数据操作（增删改查），基于基础操作之上实现一些复杂业务的数据操作</p>
<h3 id="数据新增">数据新增</h3>
<p>主要是在新增数据时的高级操作技巧，提升数据插入的效率问题、安全问题。</p>
<h4 id="批量插入">批量插入</h4>
<ul>
<li>
<p>批量插入分两种</p>
<ul>
<li>
<p>全字段批量插入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">values</span>(<span style="color:#960050;background-color:#1e0010">值列表</span><span style="color:#ae81ff">1</span>),(<span style="color:#960050;background-color:#1e0010">值列表</span><span style="color:#ae81ff">2</span>)...(<span style="color:#960050;background-color:#1e0010">值列表</span>n);
</code></pre></div></li>
<li>
<p>部分字段批量插入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> (<span style="color:#960050;background-color:#1e0010">字段列表</span>) <span style="color:#66d9ef">values</span>(<span style="color:#960050;background-color:#1e0010">值列表</span><span style="color:#ae81ff">1</span>),(<span style="color:#960050;background-color:#1e0010">值列表</span><span style="color:#ae81ff">2</span>)...(<span style="color:#960050;background-color:#1e0010">值列表</span>n);
</code></pre></div></li>
</ul>
</li>
</ul>
<h5 id="示例">示例</h5>
<ol>
<li>
<p>批量插入学生成绩(全字段)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>,<span style="color:#e6db74">&#39;Computer&#39;</span>,<span style="color:#e6db74">&#39;90&#39;</span>),(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Lily&#39;</span>,<span style="color:#e6db74">&#39;Computer&#39;</span>,<span style="color:#e6db74">&#39;100&#39;</span>);
</code></pre></div></li>
<li>
<p>批量插入学生考试信息(不含成绩)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span> (stu_name,course) <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;Tony&#39;</span>,<span style="color:#e6db74">&#39;English&#39;</span>),(<span style="color:#e6db74">&#39;Ray&#39;</span>,<span style="color:#e6db74">&#39;Math&#39;</span>);
</code></pre></div></li>
</ol>
<h4 id="蠕虫复制">蠕虫复制</h4>
<ul>
<li>
<p>从已有的表中复制数据直接插入到另外一张表</p>
</li>
<li>
<p>目的是快速增加表中的数据</p>
<ul>
<li>实现表中数据复制（用于数据备份和迁移）</li>
<li>实现数据的指数级递增（多用于测试）</li>
</ul>
</li>
<li>
<p>蠕虫复制语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> [(<span style="color:#960050;background-color:#1e0010">字段列表</span>)] <span style="color:#66d9ef">select</span> <span style="color:#960050;background-color:#1e0010">字段列表</span> <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">表名</span>;
</code></pre></div></li>
<li>
<p>注意事项</p>
<ul>
<li>字段列表必须对应</li>
<li>字段类型必须匹配</li>
<li>数据冲突需要事先考虑</li>
</ul>
</li>
</ul>
<h5 id="示例-1">示例</h5>
<ol>
<li>
<p>创建一张新表，将t1表中的数据迁移到新表中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t2</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
    stu_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    course <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    score <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">2</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;
</code></pre></div></li>
<li>
<p>快速让t1表中的数据达到超过100条（重复执行）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t2</span> (stu_name,course,score) <span style="color:#66d9ef">select</span> stu_name,course,score <span style="color:#66d9ef">from</span> t1;
<span style="color:#75715e"># 
</span></code></pre></div></li>
</ol>
<h4 id="主键冲突">主键冲突</h4>
<ul>
<li>
<p>在数据进行插入时包含主键指定，而主键在数据表已经存在</p>
</li>
<li>
<p>主键冲突的业务通常是发生在业务主键上（业务主键本身有业务意义）</p>
</li>
<li>
<p>主键冲突的解决方案</p>
<ul>
<li>
<p>忽略冲突：保留原始记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">ignore</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> [(<span style="color:#960050;background-color:#1e0010">字段列表</span>)] <span style="color:#66d9ef">values</span>(<span style="color:#960050;background-color:#1e0010">值列表</span>);
<span style="color:#75715e"># 产生主键冲突后，保留原始记录，插入数据无效
</span></code></pre></div></li>
<li>
<p>冲突更新：冲突后部分字段变成更新后的值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> [(<span style="color:#960050;background-color:#1e0010">字段列表</span>)] <span style="color:#66d9ef">values</span>(<span style="color:#960050;background-color:#1e0010">值列表</span>) <span style="color:#66d9ef">on</span> duplicate <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">update</span> <span style="color:#960050;background-color:#1e0010">字段</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">新值</span>[,<span style="color:#960050;background-color:#1e0010">字段</span><span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">新值</span>...];
<span style="color:#75715e"># 1.尝试新增
</span><span style="color:#75715e"># 2.失败，更新
</span></code></pre></div></li>
<li>
<p>冲突替换：先删除原有记录，后新增记录</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">replace</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> [(<span style="color:#960050;background-color:#1e0010">字段列表</span>)] <span style="color:#66d9ef">values</span>(<span style="color:#960050;background-color:#1e0010">值列表</span>);
<span style="color:#75715e">#效率没有insert高（需要检查是否冲突）
</span></code></pre></div></li>
</ul>
</li>
</ul>
<h5 id="示例-2">示例</h5>
<ol>
<li>
<p>用户名作为主键的用户注册（冲突不能覆盖）：username，password，regtime</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
	<span style="color:#f92672">`</span>password<span style="color:#f92672">`</span> <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">32</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	regtime <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#ae81ff">1234546789</span>);
<span style="color:#75715e">#冲突忽略，且数据不插入
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">ignore</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#ae81ff">123456789</span>);
</code></pre></div></li>
<li>
<p>用户名作为主键的记录用户使用信息（不存在新增，存在则更新时间）：username，logintime</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
    logintime <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#ae81ff">12345678</span>);

<span style="color:#75715e">#冲突更新（替换部分字段数据）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#ae81ff">12345678</span>) <span style="color:#66d9ef">on</span> duplicate <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">update</span> logintime <span style="color:#f92672">=</span> <span style="color:#a6e22e">unix_timestamp</span>();
</code></pre></div><ul>
<li>如果主键不冲突：新增</li>
<li>如果主键冲突：更新指定字段</li>
<li>上述方式适用于字段较多，但是可能冲突时数据变化的字段较少</li>
</ul>
</li>
<li>
<p>用户名作为主键，记录用户登录信息（不存在新增、存在则更新全部）：username、login time、clientinfo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
	logintime <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span>,
	clientinfo <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">255</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">replace</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#a6e22e">unix_timestamp</span>(),<span style="color:#e6db74">&#39;{PC:chrome}&#39;</span>);
<span style="color:#66d9ef">replace</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#a6e22e">unix_timestamp</span>(),<span style="color:#e6db74">&#39;{phone:uc}&#39;</span>);
</code></pre></div><ul>
<li><code>replace</code>遇到主键重复就会先删除、后新增</li>
</ul>
</li>
</ol>
<h3 id="数据查询">数据查询</h3>
<h4 id="查询选项">查询选项</h4>
<ul>
<li>用于对查询结果进行简单数据筛选</li>
<li>查询选项时在<code>select</code>关键字之后，有两个互斥值
<ul>
<li><code>all</code>：默认，表示保留所有记录</li>
<li><code>distinct</code>：去重，重复的记录（所有字段都重复）</li>
</ul>
</li>
</ul>
<h5 id="示例-3">示例</h5>
<p>查看商品表中所有品类的商品信息，重复商品只保留一次（名字、价格、属性都一致）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	goods_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	goods_price <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>,
	goods_color <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>),
	goods_weight <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span> comment <span style="color:#e6db74">&#39;重量，单位克&#39;</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;mate10&#39;</span>,<span style="color:#ae81ff">5499</span>.<span style="color:#ae81ff">00</span>,<span style="color:#e6db74">&#39;blue&#39;</span>,<span style="color:#ae81ff">320</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;mate10&#39;</span>,<span style="color:#ae81ff">5499</span>.<span style="color:#ae81ff">00</span>,<span style="color:#e6db74">&#39;gray&#39;</span>,<span style="color:#ae81ff">320</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;nokia3301&#39;</span>,<span style="color:#ae81ff">1299</span>,<span style="color:#e6db74">&#39;black&#39;</span>,<span style="color:#ae81ff">420</span>);

<span style="color:#75715e"># 考虑所有字段的去重（不含逻辑主键）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">distinct</span> goods_name,goods_price,goods_color,goods_weight <span style="color:#66d9ef">from</span> t1;

<span style="color:#75715e"># 不考虑颜色去重
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">distinct</span> goods_name,goods_price,goods_weight <span style="color:#66d9ef">from</span> t1;
</code></pre></div><h4 id="字段选择别名">字段选择&amp;别名</h4>
<ul>
<li><strong>字段选择</strong>：根据实际需求选择的要获取数据的字段信息</li>
<li>根据实际需求，明确所需要的字段名字，使用英文逗号，分隔</li>
<li>获取所有字段，使用星号<code>*</code>通配所有字段</li>
<li>字段数据可以不一定是来自数据源（select只要有结果即可）
<ul>
<li>数据常量：<code>select 1</code></li>
<li>函数或变量：<code>select unix_timestamp(),@@version</code>(@@是系统变量的前缀，后跟变量名)</li>
</ul>
</li>
<li><strong>字段别名</strong>：给字段取的临时名字</li>
<li>字段别名使用<code>as</code>语法实现
<ul>
<li>字段名 <code>as</code> 别名</li>
<li>字段名 别名</li>
</ul>
</li>
<li>字段别名的目的通常为了保护数据
<ul>
<li>字段冲突：多张表同时操作有同名字段（系统默认覆盖），想保留全部</li>
<li>数据安全：对外提供数据不使用真实字段名字</li>
</ul>
</li>
</ul>
<h5 id="示例-4">示例</h5>
<ol>
<li>
<p>查询商品信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 全部查询
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;

<span style="color:#75715e"># 需求为商品名字和商品
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> goods_name,goods_price <span style="color:#66d9ef">from</span> t1;

<span style="color:#75715e"># 别名使用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> goods_name <span style="color:#66d9ef">as</span> gn,goods_price <span style="color:#66d9ef">as</span> gp <span style="color:#66d9ef">from</span> t1;
</code></pre></div></li>
<li>
<p>不需要数据源的数据获取：select的表达式本身能算出结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 获取当前时间戳和版本号
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#a6e22e">unix_timestamp</span>() <span style="color:#66d9ef">as</span> now,<span style="color:#f92672">@@</span>version <span style="color:#66d9ef">as</span> version,<span style="color:#f92672">@@</span>version;
</code></pre></div></li>
</ol>
<h4 id="数据源">数据源</h4>
<ul>
<li>数据来源 <code>from</code>之后</li>
<li>单表数据源：数据源就是一张表 <code>from 表名</code></li>
<li>多表数据源：数据来源是多张表（逗号分隔） <code>from 表名1,表名2,...</code></li>
<li>子查询数据源：数据来源是一个查询结果<code>from (select 字段列表 from 表名) as 别名</code>
<ul>
<li>数据源要求必须是一个表</li>
<li>如果是查询结果必须给其一个表别名</li>
</ul>
</li>
<li>数据表也可以指定别名
<ul>
<li>表名 <code>as</code> 别名</li>
<li>表名 别名</li>
</ul>
</li>
</ul>
<h5 id="示例-5">示例</h5>
<ol>
<li>
<p>单表数据源：最简单的数据源，直接从一个数据表获取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;
</code></pre></div></li>
<li>
<p>多表数据源：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1,t2;
<span style="color:#75715e"># 利用一张表的一条数据匹配另外一张表的所有记录
</span><span style="color:#75715e"># 记录数=表1记录数*表2记录数
</span><span style="color:#75715e"># 字段数=表1字段数+表2字段数
</span></code></pre></div></li>
<li>
<p>子查询数据源：数据来源是一个select对应的查询结果</p>
<ul>
<li>查询语句需要使用括号</li>
<li>查询结果需要指定别名</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> (<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1,t2) t;
</code></pre></div></li>
<li>
<p>如果有时候名字较长或使用不方便，可以利用表别名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> table1 <span style="color:#66d9ef">as</span> t1;

<span style="color:#66d9ef">select</span> t1.<span style="color:#f92672">*</span>,t2.stu_name <span style="color:#66d9ef">from</span> table1 <span style="color:#66d9ef">as</span> t1 table2 <span style="color:#66d9ef">as</span> t2;
</code></pre></div></li>
</ol>
<h4 id="where子句">where子句</h4>
<ul>
<li>跟在<code>from</code>数据源之后，对数据进行条件匹配</li>
<li><code>where</code>是在磁盘读取后，进入内存之前进行筛选
<ul>
<li>不符合条件的数据不会进入内存</li>
</ul>
</li>
<li><code>where</code>筛选的内容因为还没进入内存，所以数据是没有被加工过的
<ul>
<li>字段别名不能在<code>where</code>中使用</li>
</ul>
</li>
</ul>
<h5 id="示例-6">示例</h5>
<ol>
<li>
<p>查询t1表中学生名字为Lily的成绩信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> stu_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lily&#39;</span>;
</code></pre></div></li>
<li>
<p>因为where是在磁盘取数据时进行条件筛选，此时数据没有进入内存，所以字段别名是无效的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> stu_name sn,score <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Lily&#39;</span>;
</code></pre></div></li>
</ol>
<h4 id="运算符">运算符</h4>
<ul>
<li>比较运算符
<ul>
<li><code>&gt;</code>、<code>&lt;</code>、<code>=</code>（即是赋值又是等于）、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>(不等于)</li>
<li><code>between A and B</code>  ：A和B之间，包括A和B本身，数值比较</li>
<li><code>in (数据1,数据2,...数据N)</code>：在列举的数据之中</li>
<li><code>like 'pattern'</code>：上面这样的，用于字符串比较
<ul>
<li><code>_</code>：单下划线，匹配对应位置的一个任意字符</li>
<li><code>%</code>：匹配当前位置往后任意数量任意字符</li>
</ul>
</li>
</ul>
</li>
<li>逻辑运算符
<ul>
<li><code>and(逻辑与)</code>、<code>or(逻辑或)</code>、<code>not(逻辑非)</code></li>
</ul>
</li>
<li>null运算符
<ul>
<li><code>is null(为空)</code>、<code>is not null(不为空)</code></li>
</ul>
</li>
</ul>
<h5 id="示例-7">示例</h5>
<ol>
<li>
<p>查询成绩不及格的所有学生信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> score <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">60</span>;
</code></pre></div></li>
<li>
<p>查询成绩在60-90之间的学生信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">between</span> <span style="color:#ae81ff">60</span> ans <span style="color:#ae81ff">90</span>;
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> score <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">60</span> <span style="color:#66d9ef">and</span> score <span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">90</span>;
</code></pre></div></li>
<li>
<p>查询没有成绩的学生</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> score <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">null</span>;
</code></pre></div></li>
</ol>
<h4 id="group-by-子句">group by 子句</h4>
<ul>
<li>分组统计，根据某个字段所有的<strong>结果分类</strong>，并进行<strong>数据统计分析</strong></li>
<li>分组的目的不是为了显示数据，一定是为了统计数据</li>
<li><code>group by</code>子句一定是出现在<code>where</code>字句之后（如果同时存在）</li>
<li>分组统计可以进行统计细分：先分大组，然后大组分小组</li>
<li>分组统计需要使用统计函数
<ul>
<li><code>group_concat()</code>：将组里的某个字段全部保留</li>
<li><code>any_value()</code>：不属于分组字段的任意一个组里的值</li>
<li><code>count()</code>：求对应分组的记录数量
<ul>
<li><code>count(字段名)</code>：统计某个字段值的数量（NULL不统计）</li>
<li><code>count(*)</code>：统计整个记录的数量（较多）</li>
</ul>
</li>
<li><code>sum()</code>：求对应分组中某个字段的和</li>
<li><code>max()/min()</code>：求对应分组中某个字段的最大/最小值</li>
<li><code>avg()</code>：求对应分组中某个字段的平均值</li>
</ul>
</li>
</ul>
<h5 id="示例-8">示例</h5>
<ol>
<li>
<p>创建一张表，存储学生信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
    <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	<span style="color:#f92672">`</span>gender<span style="color:#f92672">`</span> <span style="color:#66d9ef">enum</span>(<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#e6db74">&#39;女&#39;</span>,<span style="color:#e6db74">&#39;保密&#39;</span>),
    age <span style="color:#66d9ef">tinyint</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    class_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> comment <span style="color:#e6db74">&#39;班级名称&#39;</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;鸣人&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#e6db74">&#39;木叶1班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;佐助&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#e6db74">&#39;木叶1班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;小樱&#39;</span>,<span style="color:#e6db74">&#39;女&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#e6db74">&#39;木叶1班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;佐井&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#e6db74">&#39;木叶1班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;大蛇丸&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">28</span>,<span style="color:#e6db74">&#39;木叶0班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;卡卡西&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">29</span>,<span style="color:#e6db74">&#39;木叶2班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;雏田&#39;</span>,<span style="color:#e6db74">&#39;女&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#e6db74">&#39;木叶1班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;我爱罗&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">18</span>,<span style="color:#e6db74">&#39;木叶1班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;向日葵&#39;</span>,<span style="color:#e6db74">&#39;女&#39;</span>,<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#39;木叶10班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;博人&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">&#39;木叶10班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;鼬&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">28</span>,<span style="color:#e6db74">&#39;木叶0班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;带土&#39;</span>,<span style="color:#e6db74">&#39;男&#39;</span>,<span style="color:#ae81ff">28</span>,<span style="color:#e6db74">&#39;木叶2班&#39;</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;琳&#39;</span>,<span style="color:#e6db74">&#39;女&#39;</span>,<span style="color:#ae81ff">27</span>,<span style="color:#e6db74">&#39;木叶2班&#39;</span>)<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div></li>
<li>
<p>统计每个班的人数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>),class_name <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name;
</code></pre></div></li>
<li>
<p>多分组：统计每个班的男女学生数量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>),class_name,gender <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name,gender;
</code></pre></div></li>
<li>
<p>统计每个班里的人数，并记录班级学生的名字</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>),<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name;
</code></pre></div></li>
</ol>
<h4 id="回溯统计">回溯统计</h4>
<ul>
<li>在进行分组时（通常是多分组），每一次结果的回溯都进行一次汇总统计</li>
<li>回溯统计语法：在统计之后使用<code>with rollup</code></li>
</ul>
<h5 id="示例-9">示例</h5>
<p>统计每个班的男女同学数量，同时要知道班级人数总数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 只统计每个班的男女同学数量，没有班级汇总
</span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>),class_name,gender,<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name,gender;

<span style="color:#75715e"># 汇总统计：回溯
</span><span style="color:#75715e"></span><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">*</span>),class_name,gender,<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name,gender <span style="color:#66d9ef">with</span> rollup;
</code></pre></div><h4 id="分组排序">分组排序</h4>
<ul>
<li>在分组后统计结果，根据分组字段进行升序或者降序显示数据</li>
<li>默认系统自动升序排序</li>
<li>可以设定分组结果的排序方式
<ul>
<li><code>group by 字段名 [ASC]</code>：升序</li>
<li><code>group by 字段名 DESC</code>：降序</li>
</ul>
</li>
</ul>
<h5 id="示例-10">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>),class_name,gender,<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>),<span style="color:#a6e22e">any_value</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name,gender <span style="color:#66d9ef">desc</span>;
</code></pre></div><h4 id="having子句">having子句</h4>
<ul>
<li>类似于<code>where</code>子句，是用来进行条件筛选数据的</li>
<li><code>having</code>子句本身是针对<strong>分组统计结果进行条件筛选</strong>的</li>
<li><code>having</code>子句必须出现在<code>group by</code>子句之后（如果同时存在）</li>
<li><code>having</code>针对的数据是在内存里已经加载的数据</li>
<li><code>having</code>几乎能做<code>where</code>能做的所有事，但是<code>where</code>却不一定
<ul>
<li>字段别名（where针对磁盘数据，在处理时还没有别名）</li>
<li>统计结果（where在group by之前）</li>
<li>分组统计函数（having通常是针对group by存在的）</li>
</ul>
</li>
</ul>
<h5 id="示例-11">示例</h5>
<ol>
<li>
<p>获取班级人数小于3的班级</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> <span style="color:#f92672">`</span>count<span style="color:#f92672">`</span>,class_name,<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name <span style="color:#66d9ef">having</span> count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>;

<span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> <span style="color:#f92672">`</span>count<span style="color:#f92672">`</span> ,class_name,<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name <span style="color:#66d9ef">having</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>;
<span style="color:#75715e"># 多用了一次函数（效率降低）
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">SELECT</span> class_name,<span style="color:#a6e22e">group_concat</span>(<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>) <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_name <span style="color:#66d9ef">having</span> <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>;
</code></pre></div></li>
</ol>
<h4 id="order-by子句">order by子句</h4>
<ul>
<li>排序，根据某个指定的字段进行升序或者降序</li>
<li>排序的参照物是校对集</li>
<li><code>order by</code>子句在having子句字后（如果同时存在）</li>
<li>排序分为升序和降序：默认升序
<ul>
<li><code>order by 字段 [ASC]</code>：升序</li>
<li><code>order by 字段 DESC</code>：降序</li>
</ul>
</li>
<li>多字段排序：在根据某个字段排序好之后，可以再细分</li>
</ul>
<h5 id="示例-12">示例</h5>
<ol>
<li>
<p>单字段：按照年龄升序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age;
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> age <span style="color:#66d9ef">asc</span>;
</code></pre></div></li>
<li>
<p>多字段：先性别降序，后年龄升序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> gender <span style="color:#66d9ef">desc</span>, age;
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> gender <span style="color:#66d9ef">desc</span>, age <span style="color:#66d9ef">asc</span>;
</code></pre></div></li>
</ol>
<h4 id="limit子句">limit子句</h4>
<ul>
<li>限制数据的获取数量</li>
<li><code>limit</code>子句必须在<code>order by</code>子句之后（如果同时存在）</li>
<li><code>limit</code>限制数量方式有两种
<ul>
<li><code>limit 数量</code></li>
<li><code>limit 起始位置,数量</code></li>
</ul>
</li>
</ul>
<h5 id="示例-13">示例</h5>
<ol>
<li>
<p>获取表中前3条</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">3</span>;
</code></pre></div></li>
<li>
<p>获取表中第三条开始之后的3条数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>;
</code></pre></div></li>
</ol>
<h3 id="数据更新">数据更新</h3>
<h4 id="限制更新">限制更新</h4>
<ul>
<li>更新时对更新的记录数进行限制</li>
<li>限制更新通过limit实现</li>
<li>其实是局部更新的一种手段，一般更多情况下依据条件精确更新</li>
</ul>
<h4 id="示例-14">示例</h4>
<p>对会员选3个发送10元红包</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
    id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
    <span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">unique</span>,
    <span style="color:#f92672">`</span>password<span style="color:#f92672">`</span> <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">12</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    account <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t1 <span style="color:#66d9ef">VALUES</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username1&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username2&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username3&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username4&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username5&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username6&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>),
(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username7&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#66d9ef">default</span>);

<span style="color:#66d9ef">UPDATE</span> t1 <span style="color:#66d9ef">set</span> account <span style="color:#f92672">=</span> account <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">3</span>;

<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;
</code></pre></div><h3 id="数据删除">数据删除</h3>
<h4 id="限制删除">限制删除</h4>
<ul>
<li>限制要删除的记录数</li>
<li>使用<code>limit</code>限制</li>
<li>一般很少使用，通常使用<code>where</code>条件精确删除</li>
</ul>
<h5 id="示例-15">示例</h5>
<p>删除没有账户余额的一个用户</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> account <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><h4 id="清空数据">清空数据</h4>
<ul>
<li>将表中的数据清楚，表的所有状态回到原始状态</li>
<li>本质是先删除，后创建</li>
<li>清空后可以使表的一些变化状态回到原始状态，例如自增长回归初值</li>
<li>清空语法：<code>truncate 表名</code></li>
</ul>
<h5 id="示例-16">示例</h5>
<p>清空用户数据表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql">truncate t1;
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>范式和表关系</title>
      <link>https://www.niuwx.cn/posts/mysql/%E8%8C%83%E5%BC%8F%E5%92%8C%E8%A1%A8%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Mon, 26 Jul 2021 10:31:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/%E8%8C%83%E5%BC%8F%E5%92%8C%E8%A1%A8%E5%85%B3%E7%B3%BB/</guid>
      <description>简单介绍了一下范式和表关系</description>
      <content:encoded><![CDATA[<h3 id="关系型数据库设计范式">关系型数据库设计范式</h3>
<ul>
<li><code>Normal Format</code>，符合某一种级别的关系模式的集合，表示一个关系内部各个属性之间的联系的合理化程度</li>
<li>范式是离散数学的概念</li>
<li>范式目标是在满足组织和存储的前提下使数据结构冗余最小化</li>
<li>范式级别越高，表的级别就越标准</li>
<li>目前数据库应用的范式有以下几层
<ul>
<li>第一范式：1NF</li>
<li>第二范式：2NF</li>
<li>第三范式：3NF</li>
<li>逆规范化</li>
</ul>
</li>
</ul>
<h4 id="示例">示例</h4>
<ol>
<li>员工表
<table>
<thead>
<tr>
<th style="text-align:center">工号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">部门</th>
<th style="text-align:center">入职时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">人事部</td>
<td style="text-align:center">2021-07-26</td>
</tr>
<tr>
<td style="text-align:center">0002</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">运营部</td>
<td style="text-align:center">2021-07-26</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>每个员工都与部门挂钩，但是部门不可能有很多，所以上述表中会有很多数据重复，此时应该将部门单独维护出来，减少数据冗余。</p>
<table>
<thead>
<tr>
<th style="text-align:center">部门编号</th>
<th style="text-align:center">部门名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">人事部</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">运营部</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">工号</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">部门</th>
<th style="text-align:center">入职时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2021-07-26</td>
</tr>
<tr>
<td style="text-align:center">0002</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2021-07-26</td>
</tr>
</tbody>
</table>
<blockquote>
<p>范式一共有6层，但是数据库的设计通常只要求满足3层即可。</p>
</blockquote>
<h4 id="第一范式1nf">第一范式1NF</h4>
<ul>
<li><code>1NF</code>，数据字段设计时必须满足原子性</li>
<li><code>1NF</code>要求字段数据是不需要拆分就可以直接使用</li>
<li>如果数据使用的时候需要进行拆分那么就违背<code>1NF</code></li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>设计的字段是否在使用的时候还需要再拆分</li>
<li>将数据拆分到最小单位，设计字段</li>
<li>满足1NF</li>
</ol>
</blockquote>
<h5 id="示例-1">示例</h5>
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">课程</th>
<th style="text-align:center">教室</th>
<th>成绩</th>
<th>学习时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">C++</td>
<td style="text-align:center">101</td>
<td>100</td>
<td>2月1日-2月15日</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">C</td>
<td style="text-align:center">102</td>
<td>100</td>
<td>2月1日-2月15日</td>
</tr>
<tr>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
<td style="text-align:center">JAVA</td>
<td style="text-align:center">103</td>
<td>100</td>
<td>2月1日-2月15日</td>
</tr>
</tbody>
</table>
<p>当前表的学习时间在使用的时候肯定是基于开始时间和结束时间的，而这种设计会存在使用时的数据拆分，不满足原子性，同时也不满足<code>1NF</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">课程</th>
<th style="text-align:center">教室</th>
<th>成绩</th>
<th style="text-align:center">开始时间</th>
<th style="text-align:center">结束时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">C++</td>
<td style="text-align:center">101</td>
<td>100</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">C</td>
<td style="text-align:center">102</td>
<td>100</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
<tr>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
<td style="text-align:center">JAVA</td>
<td style="text-align:center">103</td>
<td>100</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
</tbody>
</table>
<h4 id="第二范式2nf">第二范式2NF</h4>
<ul>
<li><code>2NF</code>，字段设计不能存在部分依赖</li>
<li>部份依赖：首先表存在复合主键，其次有的字段不是依赖整个主键，而只是依赖主键中的一部分</li>
<li>部份依赖解决：让所有非主属性都依赖一个候选关键字
<ul>
<li>最简单方式：取消复合主键（一般选用逻辑主键替代，但是本质依然是复合主键做主），所有非主属性都依赖主属性（逻辑主键）</li>
<li>正确方式：将部分依赖关系独立成表</li>
</ul>
</li>
</ul>
<h5 id="示例-2">示例</h5>
<p>学生成绩中学生和课程应该是决定性关系，因此属于主属性（主键）</p>
<table>
<thead>
<tr>
<th style="text-align:center">姓名(P)</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">课程(P)</th>
<th style="text-align:center">教室</th>
<th>成绩</th>
<th style="text-align:center">开始时间</th>
<th style="text-align:center">结束时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">C++</td>
<td style="text-align:center">101</td>
<td>100</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">C</td>
<td style="text-align:center">102</td>
<td>100</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
<tr>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
<td style="text-align:center">JAVA</td>
<td style="text-align:center">103</td>
<td>100</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
</tbody>
</table>
<ul>
<li>成绩是由<strong>学生</strong>和<strong>课程</strong>决定的，是完全依赖主属性</li>
<li>性别只依赖<strong>学生</strong>（部份依赖）</li>
<li>教室、开始时间和结束时间依赖<strong>课程</strong>（部份依赖）</li>
</ul>
<p>解决方案：将学生信息维护到一张表，课程信息维护到一张表，成绩表取两个表的主属性即可</p>
<p><strong>学生表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Stu_id(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
</tr>
</tbody>
</table>
<ul>
<li>Stu_id是姓名的代指属性（逻辑主键，本质主键是姓名）</li>
<li>性别只依赖主属性</li>
</ul>
<p><strong>课程表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class_id(P)</th>
<th style="text-align:center">课程</th>
<th style="text-align:center">教室</th>
<th style="text-align:center">开始时间</th>
<th style="text-align:center">结束时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">C++</td>
<td style="text-align:center">101</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
<td style="text-align:center">102</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">JAVA</td>
<td style="text-align:center">103</td>
<td style="text-align:center">2月1日</td>
<td style="text-align:center">2月15日</td>
</tr>
</tbody>
</table>
<ul>
<li>Class_id是课程的代指属性（逻辑主键）</li>
<li>教室、开始时间和结束时间都依赖课程</li>
</ul>
<p><strong>成绩表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Stu_id(P)</th>
<th style="text-align:center">Class_id(P)</th>
<th style="text-align:center">成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">100</td>
</tr>
</tbody>
</table>
<ul>
<li>Stu_id和Class_id共同组成主属性（复合主键）</li>
<li>成绩依赖Stu_id和Class_id本身，不存在部份依赖</li>
</ul>
<h4 id="第三范式3nf">第三范式3NF</h4>
<ul>
<li><code>3NF</code>，字段设计不能存在传递依赖</li>
<li>传递依赖：字段某个非主属性不直接依赖主属性，而是通过依赖某个其他非主属性而传递到主属性之上</li>
<li>传递依赖解决：让依赖非主属性的字段与依赖字段独立成表</li>
</ul>
<h5 id="示例-3">示例</h5>
<table>
<thead>
<tr>
<th style="text-align:center">学号(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">专业编号</th>
<th style="text-align:center">专业名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">0001001</td>
<td style="text-align:center">软件工程</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">0001002</td>
<td style="text-align:center">土木工程</td>
</tr>
</tbody>
</table>
<ul>
<li>姓名和专业编号都依赖于学号</li>
<li>专业名称依赖于专业编号</li>
<li>专业名称间接依赖学号：依赖传递</li>
<li>随着学生增加，专业名字会出现大量数据冗余</li>
</ul>
<p>解决方案：将存储传递依赖部分的字段独立成表，然后在需要使用相关信息的时候，引入即可。</p>
<p><strong>专业表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">专业编号(P)</th>
<th style="text-align:center">专业名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0001001</td>
<td style="text-align:center">软件工程</td>
</tr>
<tr>
<td style="text-align:center">0001002</td>
<td style="text-align:center">土木工程</td>
</tr>
</tbody>
</table>
<p><strong>学生表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">学号(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">专业编号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">0001001</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">0001002</td>
</tr>
</tbody>
</table>
<h4 id="逆规范化">逆规范化</h4>
<ul>
<li>为了提升数据查询的效率而刻意违背范式的规则</li>
<li>逆规范化的目标是为了提升数据访问效率</li>
<li>所谓逆规范化就是减少表之间的关联查询（效率降低），刻意增加数据冗余。</li>
</ul>
<h3 id="表关系">表关系</h3>
<ul>
<li>一个表代表一个实体，实体之间都有关联关系</li>
<li>根据范式的要求来设计表关系，减少数据冗余</li>
<li>根据实际需求来设计表关系，提升访问效率</li>
</ul>
<h5 id="示例-4">示例</h5>
<p>设计一个简单的新闻管理系统的数据库</p>
<ul>
<li>新闻信息表：id、标题、内容、发布时间、作者id（作者主属性）、分类id（分类表主属性）、阅读量、推荐数</li>
<li>作者表：id、作者名字、作者来源id（来源表）</li>
<li>来源表：id、来源名字、来源描述</li>
<li>分类表：id、分类名字、分类级别（父分类id）</li>
<li>评论表：id、评论人id（评论人表）、评论时间、评论内容</li>
<li>评论人表：id、评论人名字</li>
</ul>
<h4 id="一对一关系">一对一关系</h4>
<ul>
<li>一张表中的一条记录与另外一张表中有且仅有一条记录有关系</li>
<li>一对一关系通常是用来将一张原本就是议题的表拆分成两张表
<ul>
<li>频繁使用部分：常用字段</li>
<li>不常使用部分：生僻字段</li>
<li>使用相同的主键对应</li>
</ul>
</li>
<li>一对一关系设计较多使用在优化方面</li>
</ul>
<h5 id="示例-5">示例</h5>
<table>
<thead>
<tr>
<th style="text-align:center">学号(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
<th style="text-align:center">身高</th>
<th style="text-align:center">体重</th>
<th style="text-align:center">籍贯</th>
<th style="text-align:center">政治面貌</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">20</td>
<td style="text-align:center">185</td>
<td style="text-align:center">160</td>
<td style="text-align:center">山西</td>
<td style="text-align:center">农民</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">21</td>
<td style="text-align:center">168</td>
<td style="text-align:center">110</td>
<td style="text-align:center">山西</td>
<td style="text-align:center">党员</td>
</tr>
</tbody>
</table>
<ul>
<li>姓名、性别、年龄属于常用字段，频繁查询</li>
</ul>
<p><strong>一对一关系设计</strong></p>
<ul>
<li>将常用字段取出，与学号组合成一张常用表</li>
<li>将不常用字段取出，与学号组成一张不常用表</li>
<li>表与表数据对应关系：基于学号（唯一）是一对一关系</li>
</ul>
<p><strong>常用表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">学号(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">21</td>
</tr>
</tbody>
</table>
<p><strong>不常用表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">学号(P)</th>
<th style="text-align:center">身高</th>
<th style="text-align:center">体重</th>
<th style="text-align:center">籍贯</th>
<th style="text-align:center">政治面貌</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">185</td>
<td style="text-align:center">160</td>
<td style="text-align:center">山西</td>
<td style="text-align:center">农民</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">168</td>
<td style="text-align:center">110</td>
<td style="text-align:center">山西</td>
<td style="text-align:center">党员</td>
</tr>
</tbody>
</table>
<h4 id="一对多关系">一对多关系</h4>
<ul>
<li>
<p>又称多对一关系，一张表中的一条记录与另外一张表的多条记录对应，反过来另外一张表的多条记录只能对应当前表的一条记录</p>
</li>
<li>
<p>一对多关系是实体中非常常见的一种关系，实体设计时也应用非常多</p>
</li>
<li>
<p>一对多关系的核心解决方案是如何让记录能够正确匹配到另外表中的数据</p>
<ul>
<li>一表设计：一表记录在另外一张表中有多条记录，所在无法记录多个字段</li>
<li>多表设计：多表记录在另外一张表中只有一条记录，可以设置字段记录对应的主属性（通常主键）</li>
</ul>
</li>
</ul>
<h5 id="示例-6">示例</h5>
<p>老师与学科间的关系：一个老师只能教一个学科，但是一个学科可有多个老师来教。</p>
<p><strong>老师表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">老师ID(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
<td style="text-align:center">29</td>
</tr>
</tbody>
</table>
<p><strong>学科表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">学科ID(P)</th>
<th style="text-align:center">学科名称</th>
<th style="text-align:center">课时长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">C++</td>
<td style="text-align:center">600</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">JAVA</td>
<td style="text-align:center">800</td>
</tr>
</tbody>
</table>
<ul>
<li>以上两个实体没有体现彼此之间的关联关系</li>
<li>实际上讲师与学科之间肯定是有关联的</li>
</ul>
<p>在多表中增加字段维护一表</p>
<table>
<thead>
<tr>
<th style="text-align:center">老师ID(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
<th style="text-align:center">学科ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">25</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">26</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
<td style="text-align:center">29</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h4 id="多对多关系">多对多关系</h4>
<ul>
<li>一张表中的一条记录对应另外一个表中多条记录，反过来一样</li>
<li>多对多关系在实体中是最常见的关系</li>
<li>多对多是无法在自身表中维护对应关系（违背1NF），需要通过第三方表来实现多对多关系变成多个多对一关系
<ul>
<li>设计一个中间表，记录两张表之间的对应关系（主属性）</li>
<li>中间表与其他表都是多对一关系</li>
</ul>
</li>
</ul>
<h5 id="示例-7">示例</h5>
<p>老师与学生之间的关系：一个老师教多个学生，一个学生也会被多个老师教，实体关系为多对多。</p>
<p><strong>老师表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">老师ID(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张老师</td>
<td style="text-align:center">男</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李老师</td>
<td style="text-align:center">女</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">王老师</td>
<td style="text-align:center">男</td>
<td style="text-align:center">29</td>
</tr>
</tbody>
</table>
<p><strong>学生表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">学生ID(P)</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">年龄</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">张三</td>
<td style="text-align:center">男</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">李四</td>
<td style="text-align:center">女</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">王五</td>
<td style="text-align:center">男</td>
<td style="text-align:center">19</td>
</tr>
</tbody>
</table>
<ul>
<li>以上实体没有从结构上体现表之间的关系</li>
</ul>
<p>增加一个中间表</p>
<p><strong>中间表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">ID(P)</th>
<th style="text-align:center">学生ID</th>
<th style="text-align:center">老师ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>]]></content:encoded>
    </item>
    
    <item>
      <title>字段</title>
      <link>https://www.niuwx.cn/posts/mysql/%E5%AD%97%E6%AE%B5/</link>
      <pubDate>Tue, 20 Jul 2021 10:31:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/%E5%AD%97%E6%AE%B5/</guid>
      <description>简单介绍了一下字符集校对集</description>
      <content:encoded><![CDATA[<h3 id="字段类型">字段类型</h3>
<ul>
<li>字段类型在定义表结构时设定</li>
<li>设定好字段类型后，插入数据时必须与字段类型对应，否则数据错误</li>
<li>MySQL有四大数据类型
<ul>
<li>整数类型</li>
<li>小数类型</li>
<li>字符串类型</li>
<li>时间日期类型</li>
</ul>
</li>
</ul>
<h4 id="整数类型">整数类型</h4>
<ul>
<li>MySQL中为了数据空间的有效使用，设定了五种整数类型
<ul>
<li>迷你整型：<code>tinyint</code>，使用<strong>1个字节</strong>存储整数，最多存储256个整数(-128~127)</li>
<li>短整型：<code>smallint</code>，使用<strong>2个字节</strong>存储整数</li>
<li>中整型：<code>mediumint</code>，使用<strong>3个字节</strong>存储整数</li>
<li>标准整型：<code>int</code>，使用<strong>4个字节</strong>存储整数</li>
<li>大整型：<code>bigint</code>，使用<strong>8个字节</strong>存储整数</li>
</ul>
</li>
<li>数值型存储在MySQL中分为有符号（有负数）和无符号（纯正数）</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据的格式是存储整数</li>
<li>预估整数的范围，选择合适的整数类型</li>
<li>确定整数是否需要符号（负数区间）</li>
</ol>
</blockquote>
<h5 id="示例">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 年龄：无负数，正常年龄不会超过256，迷你整型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	age <span style="color:#66d9ef">tinyint</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#75715e">#unsigned修饰整数，表示无符号
</span><span style="color:#75715e"></span>)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div><h4 id="显示宽度">显示宽度</h4>
<ul>
<li>显示宽度一般是该整数类型能表示的最大值对应的数字个数（通过desc查看字段表显示）</li>
<li>显示宽度包括符号（如果允许为负数，<code>-</code>负号会增加一个宽度）</li>
<li>显示宽度可以主动控制</li>
<li>显示宽度不会影响类型能表示的最大数值</li>
<li>可以通过<code>zerofill</code>让不够宽度的数值补充到对应宽度：在字段类型后使用<code>zerofill</code></li>
</ul>
<h5 id="示例-1">示例</h5>
<ol>
<li>
<p>有符号和无符号对应的宽度不一样</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	a <span style="color:#66d9ef">tinyint</span>,
    b <span style="color:#66d9ef">tinyint</span> <span style="color:#66d9ef">unsigned</span>
)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div></li>
<li>
<p>可以主动控制显示宽度</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> c <span style="color:#66d9ef">tinyint</span>(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">unsigned</span>;
</code></pre></div></li>
<li>
<p>显示宽度不影响数据的大小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">100</span>);
</code></pre></div></li>
<li>
<p>可以通过<code>zerofill</code>让小于显示宽度的数值前置补充0到显示宽度</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> d <span style="color:#66d9ef">tinyint</span>(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">zerofill</span>; <span style="color:#75715e"># 0填充只能针对正数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
</code></pre></div></li>
</ol>
<h4 id="小数类型浮点型">小数类型（浮点型）</h4>
<ul>
<li>
<p>无法保证精度</p>
</li>
<li>
<p>浮点数又称为精度数据，分为两种</p>
<ul>
<li>单精度：<code>float</code>，使用4个字节存储，精度范围为7~8位有效数字</li>
<li>双精度：<code>double</code>，使用8个字节存储，精度范围位15~16位有效数字</li>
</ul>
</li>
<li>
<p>浮点数超过精度范围会自动进行<strong>四舍五入</strong></p>
</li>
<li>
<p>精度可以指定整数部分和小数部分</p>
<ul>
<li>默认不指定，整数部分不超过最大值，小数部分保留2位</li>
<li>可以指定：float/double（总长度，小数部分长度）</li>
</ul>
</li>
<li>
<p>可以使用科学计数法插入数据</p>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定当前设计的字段的数据为不精确型数据（或者小数）</li>
<li>确定数据的大小或者精度的要求范围
<ul>
<li>6~7位有效数字使用float</li>
<li>14~15位有效数字使用double</li>
</ul>
</li>
<li>确定精度的分布：整数部分和小数部分</li>
</ol>
</blockquote>
<h5 id="示例-2">示例</h5>
<ol>
<li>
<p>记录商品的价格</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	goods_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>),
    goods_price <span style="color:#66d9ef">float</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#34;lala&#34;</span>,<span style="color:#ae81ff">19</span>.<span style="color:#ae81ff">99</span>);  <span style="color:#75715e">#正常保留
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#34;haha&#34;</span>,<span style="color:#ae81ff">1999</span>.<span style="color:#ae81ff">9999</span>);   <span style="color:#75715e">#四舍五入成2000
</span></code></pre></div></li>
</ol>
<h4 id="小数类型定点型">小数类型（定点型）</h4>
<ul>
<li>可以保证精度</li>
<li>不固定存储空间存储</li>
<li>每9个数字使用4个字节存储</li>
<li>定点型可以指定整数部分长度和小数部分长度
<ul>
<li>默认不指定：10位有效整数，0位小数</li>
<li>可以指定：decimal(有效数位，小数部分数位)</li>
<li>有效数位不超过65个</li>
</ul>
</li>
<li>数据规范
<ul>
<li>整数部分超出报错</li>
<li>小数部分超出四舍五入</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定小数是否需要保证精度</li>
<li>确定有效数位长度</li>
</ol>
</blockquote>
<h5 id="示例-3">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 资产和负债应该都是精确的，小数部分可以到分
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	money <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">14</span>,<span style="color:#ae81ff">2</span>),
	bet <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">2</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1111111111</span>.<span style="color:#ae81ff">12</span>,<span style="color:#ae81ff">1111111</span>.<span style="color:#ae81ff">99</span>); 
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1111111111</span>.<span style="color:#ae81ff">12</span>,<span style="color:#ae81ff">111111111111111</span>.<span style="color:#ae81ff">99</span>)<span style="color:#75715e"># 整数部分超出报错
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1111111111</span>.<span style="color:#ae81ff">12</span>,<span style="color:#ae81ff">1111111</span>.<span style="color:#ae81ff">999</span>)<span style="color:#75715e"># 四舍五入
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1111111111</span>.<span style="color:#ae81ff">12</span>,<span style="color:#ae81ff">99999999</span>.<span style="color:#ae81ff">999</span>)<span style="color:#75715e"># 四舍五入导致整数部分超出报错
</span></code></pre></div><h4 id="字符串类型定长型">字符串类型（定长型）</h4>
<ul>
<li>定长型：char(L)，指定固定长度的存储空间存储字符串</li>
<li>定长是指定存储长度</li>
<li>定长的长度是字符数量而不是字节
<ul>
<li>L的最大值是255</li>
<li>实际存储空间：$L字符数*字符集对应字节数$</li>
</ul>
</li>
<li>定长里存储的数据不能超过指定长度</li>
<li>字符串数据使用单引号或者双引号包裹</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据类型为字符串（或不能用整数存储的超长数字符号）</li>
<li>确定数据长度基本一致（定长占用固定空间）</li>
<li>确定具体长度</li>
</ol>
</blockquote>
<h5 id="示例-4">示例</h5>
<p>记录个人信息：身份证信息和手机号码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 身份证为固定长度18为
</span><span style="color:#75715e"># 手机号码为11位固定长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id_number <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">18</span>),
    phone_number <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">11</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;142629190001016666&#39;</span>,<span style="color:#e6db74">&#39;12345678910&#39;</span>);
</code></pre></div><h4 id="字符串类型变长型">字符串类型（变长型）</h4>
<ul>
<li>变长型：varchar(L)，根据实际存储的数据变化存储空间</li>
<li>变长型的存储空间是由实际存储数据决定的</li>
<li>变长型的L也是指字符而不是字节
<ul>
<li>L指定的是最大存储的数据长度</li>
<li>L最大值理论是65535</li>
<li>变长需要额外产生1-2个字节，用来记录实际数据的长度
<ul>
<li>数据长度小于256，多1个字节</li>
<li>数据长度大于256，多2个字节</li>
</ul>
</li>
<li>实际存储空间：$实际字符数*字符集对应字节数+记录长度$</li>
</ul>
</li>
<li>变长数据不能超过定义的最大长度</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据类型为字符串</li>
<li>确定数据是不规则的数据</li>
<li>确定最大长度</li>
</ol>
</blockquote>
<h5 id="示例-5">示例</h5>
<p>记录个人信息：用户名、密码、姓名、身份证</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 用户名不确定长度，最长不超过50个字符
</span><span style="color:#75715e"># 密码不确定长度，最长不超过16个字符
</span><span style="color:#75715e"># 姓名不确定长度，最长不超过10个字符
</span><span style="color:#75715e"># 身份证固定长度，18个字符
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>),
	<span style="color:#f92672">`</span>password<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">16</span>),
 	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>),
    <span style="color:#f92672">`</span>id_number<span style="color:#f92672">`</span> <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">18</span>)
)<span style="color:#66d9ef">charset</span> utf8;
<span style="color:#75715e"># 使用``包括字段名，防止字段名与关键字重名导致报错
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#e6db74">&#39;name&#39;</span>,<span style="color:#e6db74">&#39;14262919000101666&#39;</span>);
</code></pre></div><h4 id="字符串类型文本字符串">字符串类型（文本字符串）</h4>
<ul>
<li><code>test/blob</code>，专门用来存储较长的文本</li>
<li>文本字符串包含两大类
<ul>
<li><code>test</code>：普通字符
<ul>
<li><code>tinytext</code>：迷你文本，不超过$2^8-1$个字符</li>
<li><code>text</code>：普通文本，不超过$2^{16}-1$个字符</li>
<li><code>mediumtext</code>：中型文本，不超过$2^{24}-1$个字符</li>
<li><code>longtext</code>：长文本，不超过$2^{32}-1$个字符（4G）</li>
</ul>
</li>
<li><code>blob</code>：二进制字符（与text类似）
<ul>
<li><code>tinyblob</code></li>
<li><code>blob</code></li>
<li><code>mediumblob</code></li>
<li><code>longblob</code></li>
</ul>
</li>
</ul>
</li>
<li>文本字符串会自动根据文本长度选择合适的具体类型</li>
<li>一般在文本超过255个字符时，都会使用text（blob现在极少使用）</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定类型为文本文件</li>
<li>确定数据长度可能超过255个字符</li>
<li>使用text</li>
</ol>
</blockquote>
<h5 id="示例-6">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 标题一般不会超过50个字符，varchar
</span><span style="color:#75715e"># 作者一般不会超过10个字符，varchar
</span><span style="color:#75715e"># 内容通常都很长，使用text
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	author <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>),
    title <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>),
    content <span style="color:#66d9ef">text</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;佚名&#39;</span>,<span style="color:#e6db74">&#39;给家长的一封信&#39;</span>,<span style="color:#e6db74">&#39;某某某的爸爸/妈妈...您好...&#39;</span>);
</code></pre></div><h4 id="字符串类型枚举">字符串类型（枚举）</h4>
<ul>
<li>一种映射存储方式，以较小的空间存储较多的数据</li>
<li>枚举是在定义时确定可能出现的问题</li>
<li>枚举在定义后数据只能出现定义时其中的一种</li>
<li>枚举类似一种单选框</li>
<li>枚举使用1-2个字节存储，最多可以设计65535个选项</li>
<li>枚举实际存储是使用数值，映射对应的元素数据，从1开始</li>
<li>枚举语法：<code>enum(元素1,元素2....元素N)</code></li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据是固定的几种数据之一</li>
<li>使用枚举穷举相应的元素</li>
<li>数据存储只能选择穷举中的元素之一</li>
</ol>
</blockquote>
<h5 id="示例-7">示例</h5>
<ol>
<li>
<p>记录人群类型：小朋友，少年，青年，中年，老年，每个人只属于一种类型题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	type <span style="color:#66d9ef">enum</span>(<span style="color:#e6db74">&#39;小朋友&#39;</span>,<span style="color:#e6db74">&#39;少年&#39;</span>,<span style="color:#e6db74">&#39;青年&#39;</span>,<span style="color:#e6db74">&#39;中年&#39;</span>,<span style="color:#e6db74">&#39;老年&#39;</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;少年&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;神仙&#39;</span>);<span style="color:#75715e"># error 不存在的数据不能插入
</span></code></pre></div></li>
<li>
<p><code>enum</code>是建立映射关系，然后实际存储是数字，数值是按照元素顺序从1开始</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 可以使用字段 + 0来判断数据具体的效果（字符串转数值为0）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> type,type <span style="color:#f92672">+</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">from</span> t1;
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">5</span>);
</code></pre></div></li>
</ol>
<h4 id="字符串类型集合">字符串类型（集合）</h4>
<ul>
<li><code>set</code>，一种映射存储方式，以较小的空间存储较多的数据</li>
<li>集合是在定义时确定可能出现的元素进行穷举</li>
<li>集合在定义后数据只能出现定义时其中的元素（可以是多个）</li>
<li>集合类似一种多选框</li>
<li>集合使用1-8个字节存储数据，最多可以设计64个元素</li>
<li>集合实际存储是使用数值（二进制位），映射对应的元素数据，每个元素对应一个比特位</li>
<li>集合语法：<code>set(元素1,元素2,.....元素N)</code></li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据是固定的几种数据集合</li>
<li>使用集合穷极相应的元素</li>
<li>数据存储只能选择穷举中的元素组合</li>
</ol>
</blockquote>
<h5 id="示例-8">示例</h5>
<ol>
<li>
<p>记录个人的球类爱好，有篮球，足球，羽毛球，网球，乒乓球，排球，台球，冰球</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 爱好可以使多种
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	hobby <span style="color:#66d9ef">set</span>(<span style="color:#e6db74">&#39;足球&#39;</span>,<span style="color:#e6db74">&#39;篮球&#39;</span>,<span style="color:#e6db74">&#39;羽毛球&#39;</span>,<span style="color:#e6db74">&#39;网球&#39;</span>,<span style="color:#e6db74">&#39;乒乓球&#39;</span>,<span style="color:#e6db74">&#39;排球&#39;</span>,<span style="color:#e6db74">&#39;台球&#39;</span>,<span style="color:#e6db74">&#39;冰球&#39;</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;足球&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;足球,台球,篮球&#39;</span>);
</code></pre></div></li>
<li>
<p>集合建立的也是映射关系，映射方式是每个元素对应一个字节的比特位， 从左边开始第一个对应字节从右边开始的第一位</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 可以通过字段 + 0的方式查看存储的具体数值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> hobby,hobby <span style="color:#f92672">+</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">from</span> t1;

<span style="color:#75715e"># 可以通过插入数值来组合元素，但是需要确定对应的十进制转换成二进制有对应的元素对应
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#a6e22e">value</span>(<span style="color:#ae81ff">8</span>); <span style="color:#75715e"># 网球
</span></code></pre></div></li>
</ol>
<h4 id="时间如期类型年">时间如期类型（年）</h4>
<ul>
<li><code>year</code>，MySQL中用来存储年份的类型</li>
<li>MySQL中使用1个字节存储年份</li>
<li><code>year</code>能够表示的范围是1901-2155（256年）
<ul>
<li>year的特殊值是0000</li>
</ul>
</li>
<li><code>year</code>允许用户是用两种方式设计（效果一样）
<ul>
<li><code>year</code></li>
<li><code>year(4)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定存储的数据是年份</li>
<li>确定年份的区间在1901-2155之间</li>
<li>使用year类型</li>
</ol>
</blockquote>
<h5 id="示例-9">示例</h5>
<ol>
<li>
<p>记录个人的出生年份</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	y1 <span style="color:#66d9ef">year</span>,
    y2 <span style="color:#66d9ef">year</span>(<span style="color:#ae81ff">4</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1901</span>,<span style="color:#ae81ff">2155</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1800</span>); <span style="color:#75715e"># error 不在范围内
</span></code></pre></div></li>
<li>
<p>year类型允许使用2位数来插入，系统自动匹配对应的年份</p>
<ul>
<li>69以前：系统默认加2000</li>
<li>69以后：系统默认加1900</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">69</span>,<span style="color:#ae81ff">70</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">68</span>,<span style="color:#ae81ff">71</span>);
</code></pre></div></li>
<li>
<p>year类型的特殊值是0000，可以使用00或者0000插入</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span>(<span style="color:#ae81ff">00</span>,<span style="color:#ae81ff">0000</span>);
</code></pre></div></li>
</ol>
<h4 id="时间日期类型时间戳">时间日期类型（时间戳）</h4>
<ul>
<li><code>timestamp</code>，基于格林威治时间的时间记录</li>
<li>MySQL中时间戳表现形式不是秒数，而是年月日时分秒格式
<ul>
<li>YYYY-MM-DD HH:II::SS</li>
<li>YYYYMMDDHHIISS</li>
</ul>
</li>
<li>timestamp使用4个字节存储</li>
<li>timestamp的特点是所对应的记录不论哪个字段被更新，该字段都会更新到当前时间</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定类型需要使用年月日时分秒格式</li>
<li>确定当前字段需要记录数据的最近更新时间</li>
<li>使用timestamp时间戳</li>
</ol>
</blockquote>
<h5 id="示例-10">示例</h5>
<ol>
<li>
<p>记录商品库存的最后更新时间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	goods_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>),
    goods_inventory <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span>,
    change_time <span style="color:#66d9ef">timestamp</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;大白菜&#39;</span>,<span style="color:#ae81ff">100</span>,<span style="color:#e6db74">&#39;1971-01-01 00:00:00&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;小白菜&#39;</span>,<span style="color:#ae81ff">100</span>,<span style="color:#e6db74">&#39;19700101000000&#39;</span>);
</code></pre></div></li>
<li>
<p>timestamp会在自己所在的记录任何位置被修改时自动更新时间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> goods_inventory <span style="color:#f92672">=</span> <span style="color:#ae81ff">90</span>;
</code></pre></div><p>在MySQL8后，取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性：<code>on update current_timestamp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> c_time <span style="color:#66d9ef">timestamp</span> <span style="color:#66d9ef">on</span> <span style="color:#66d9ef">update</span> <span style="color:#66d9ef">current_timestamp</span>
<span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> goods_inventory <span style="color:#f92672">=</span> <span style="color:#ae81ff">80</span>;
</code></pre></div></li>
</ol>
<h4 id="时间日期类型日期">时间日期类型（日期）</h4>
<ul>
<li><code>date</code>，用来记录年月日信息</li>
<li>使用3 个字节存储数据</li>
<li>存储日期的格式为：<code>YYYY-MM-DD</code></li>
<li>存储的范围是：<code>1001-01-01</code>到<code>9999-12-31</code> 目前来说，还够用</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定存储的数据格式为日期格式</li>
<li>确定数据格式为YYYY-MM-DD</li>
<li>使用date类型</li>
</ol>
</blockquote>
<h5 id="示例-11">示例</h5>
<p>记录个人生日</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>),
	birth <span style="color:#66d9ef">date</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;张三&#39;</span>,<span style="color:#e6db74">&#39;2000-01-01&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;李四&#39;</span>,<span style="color:#e6db74">&#39;2021-07-23&#39;</span>);
</code></pre></div><h4 id="时间日期类型日期时间">时间日期类型（日期时间）</h4>
<ul>
<li><code>datetime</code>，用来综合存储日期和时间</li>
<li>存储格式为：<code>YYYY-MM-DD HH:II:SS</code></li>
<li>存储区间为：<code>1000-01-01 00:00:00</code>到<code>9999-12-31 23:59:59</code></li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定存储的时间格式包含日期</li>
<li>确定存储格式为：YYYY-MM-DD HH:II:SS</li>
<li>使用datetime</li>
</ol>
</blockquote>
<h5 id="示例-12">示例</h5>
<p>记录个人具体的出生时间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>),
	birth <span style="color:#66d9ef">datetime</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1
</code></pre></div><h4 id="时间日期类型时间">时间日期类型（时间）</h4>
<ul>
<li><code>time</code>，用来记录时间或者时间段</li>
<li>数据范围是：<code>-838:59:59</code>-<code>838:59:59</code></li>
<li>数据插入的格式分为两种
<ul>
<li>时间格式：HH:II:SS</li>
<li>时间段格式：D HH:II:SS</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定要存储的类型是时间格式</li>
<li>确定格式类型为time能表示的格式</li>
<li>使用time存储</li>
</ol>
</blockquote>
<h5 id="示例-13">示例</h5>
<p>记录用户登录的具体时间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 具体登录时间可以使用时间戳（包含年月日时分秒信息）
</span><span style="color:#75715e"># 也可以使用时间datetime格式，或者date+time双字段格式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	login_time1 <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span>,
    login_time2 <span style="color:#66d9ef">datetime</span>,
    login_date <span style="color:#66d9ef">date</span>,
    login_time3 <span style="color:#66d9ef">time</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">12345678</span>,<span style="color:#e6db74">&#39;2000-12-12 12:12:12&#39;</span>,<span style="color:#e6db74">&#39;2000-12-12&#39;</span>,<span style="color:#e6db74">&#39;12:12:12&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1234567</span>,<span style="color:#e6db74">&#39;2000-12-12 12:12:12&#39;</span>,<span style="color:#e6db74">&#39;2000-12-12&#39;</span>,<span style="color:#e6db74">&#39;3 12:12:12&#39;</span>);
</code></pre></div><h3 id="属性">属性</h3>
<h4 id="属性作用">属性作用</h4>
<ul>
<li>建立在字段类型之后，对字段除类型之外的其他约束</li>
<li>属性是在定义表字段的时候针对每个字段进行属性设定</li>
<li>设定好的属性可以通过查看表字段desc进行查看</li>
<li>数据在进行增删改（写）操作时需要在满足字段要求的同时满足属性的要求</li>
</ul>
<h5 id="示例-14">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">desc</span> t1;

<span style="color:#75715e"># Field: 字段名字
</span><span style="color:#75715e"># Type: 数据类型
</span><span style="color:#75715e"># Null: 是否为空（属性）
</span><span style="color:#75715e"># Key: 索引类型（属性）
</span><span style="color:#75715e"># Default: 默认值（属性）
</span><span style="color:#75715e"># Extra: 额外属性
</span></code></pre></div><h4 id="null属性">NULL属性</h4>
<ul>
<li>NULL：数据是否允许为空</li>
<li>不为空设计： Not Null</li>
<li>数据为空一般不具备运算和分析价值，所以通常数据都需要设定Not Null（不区分大小写）</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>数据类型确定</li>
<li>数据是否为空确定
<ul>
<li>允许为空：不考虑Null属性</li>
<li>不允许为空：Not Null</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="示例-15">示例</h5>
<ol>
<li>
<p>用户信息表：用户名、密码、姓名、年龄、注册时间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	<span style="color:#f92672">`</span>password<span style="color:#f92672">`</span> <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">32</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>),
	age <span style="color:#66d9ef">tinyint</span> <span style="color:#66d9ef">unsigned</span>,
	reg_time <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div></li>
<li>
<p>如果字段不能为空（Not Null），那么数据就必须满足条件：插入时不能为空的字段就需要主动提供值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>,<span style="color:#e6db74">&#39;张三&#39;</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">123456789</span>);

<span style="color:#75715e"># 错误操作，reg_time不能为空，而默认为空，
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span> (<span style="color:#f92672">`</span>username<span style="color:#f92672">`</span>,<span style="color:#f92672">`</span>password<span style="color:#f92672">`</span>) <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>);
</code></pre></div></li>
</ol>
<h4 id="defaule属性">Defaule属性</h4>
<ul>
<li><code>defaule</code>，在设计表字段的时候给定默认数据，在后续字段操作（数据新增）的时候系统没有检测到字段有数据的时候自动使用的值</li>
<li>默认值在字段设计的时候使用（默认值需要满足数据类型规范）</li>
<li>默认值通常设计的字段容易出现的数据
<ul>
<li>一般字段的默认值默认是Null</li>
</ul>
</li>
<li>默认值触发
<ul>
<li>在系统进行数据插入时自动检测触发</li>
<li>主动使用<code>default</code>关键字触发默认值</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定字段的数据类型</li>
<li>确定字段可能出现的数据会是某个经常出现的值</li>
<li>设定默认值</li>
<li>触发默认值
<ul>
<li>自动触发：数据插入时不给字段复制</li>
<li>手动触发：数据插入时主动使用default关键字</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="示例-16">示例</h5>
<ol>
<li>
<p>用户开户：银行卡账号、身份证号码、姓名、账户余额</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	account <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">19</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	id_card <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">18</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    money <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">16</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div></li>
<li>
<p>默认值触发</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 默认触发
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span> (account,id_card,name)
<span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;123456789101112131&#39;</span>,<span style="color:#e6db74">&#39;142629200001011010&#39;</span>,<span style="color:#e6db74">&#39;张三&#39;</span>);

<span style="color:#75715e"># 主动触发
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;123456789101112131&#39;</span>,<span style="color:#e6db74">&#39;142629200001010101&#39;</span>,<span style="color:#e6db74">&#39;李四&#39;</span>,<span style="color:#66d9ef">default</span>);
</code></pre></div></li>
</ol>
<h4 id="主键">主键</h4>
<ul>
<li><code>primary key</code>，用来保证整张表中对应的字段永远不会出现重复数据</li>
<li>主键在一张表中只能有一个</li>
<li>主键的另外一个特性是能够提升主键字段作为查询条件的效率(索引)</li>
<li>主键不能为空：Not Null(默认)</li>
<li>逻辑主键：数据没有具体业务意义，纯粹是一种数值数据
<ul>
<li>逻辑主键通常是整数：int</li>
<li>逻辑主键目的是方便检索和数据安全（不暴露数据真实信息）</li>
</ul>
</li>
<li>复合主键：多个字段共同组成不能重复的数据
<ul>
<li><code>primary key(字段1,字段2,...)</code></li>
<li>联合主键使用不多，一般也不会超过2个字段</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定字段数据具有唯一性</li>
<li>确定数据不允许为空</li>
<li>确定数据会经常用于数据检索</li>
<li>使用主键<code>primary key</code></li>
<li>一般每张表都会使用一个逻辑主键(id)</li>
</ol>
</blockquote>
<h5 id="示例-17">示例</h5>
<ol>
<li>
<p>银行账户信息：账户、姓名、余额</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 银行账户具有唯一性，不可重复，不可为空
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	account <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">17</span>) <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	money <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">16</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#75715e"># 复合主键
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t2</span>(
	account <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">17</span>),
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>),
	money <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">16</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>,
	<span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>(account,<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#75715e"># 一般使用逻辑主键
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t3</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
	account <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">17</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	<span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	money <span style="color:#66d9ef">decimal</span>(<span style="color:#ae81ff">16</span>,<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span> <span style="color:#66d9ef">default</span> <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">00</span>
)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div></li>
<li>
<p>主键数据不允许重复</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t3 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;123456&#39;</span>,<span style="color:#e6db74">&#39;1&#39;</span>,<span style="color:#66d9ef">default</span>);

<span style="color:#75715e"># 错误 主键1已经存在
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t3 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;456789&#39;</span>,<span style="color:#e6db74">&#39;2&#39;</span>,<span style="color:#66d9ef">default</span>);

<span style="color:#75715e"># 联合主键就是联合字段加起来不重复即可
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;123456&#39;</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>,<span style="color:#66d9ef">default</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t2 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#39;456789&#39;</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>,<span style="color:#66d9ef">default</span>);
</code></pre></div></li>
</ol>
<h4 id="主键管理">主键管理</h4>
<ul>
<li>在创建表并且已经有数据后的维护</li>
<li>删除主键</li>
<li>追加主键</li>
<li>修改主键（先删后增）</li>
</ul>
<h5 id="示例-18">示例</h5>
<ol>
<li>
<p>删除主键：主键只有一个，所以删除语法也比较特殊</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>;
</code></pre></div></li>
<li>
<p>后期新增主键：如果是针对业务主键需要保证字段数据没有Null数据且没有数据重复（一般主键都会在表创建时维护好）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>(account,name);
</code></pre></div></li>
</ol>
<h4 id="自增长属性">自增长属性</h4>
<ul>
<li><code>auto_increment</code>，被修饰的字段在新增时，自动增长的数据</li>
<li>自增长数据可以理解为一种默认值，如果主动给值，那么自动增长不会触发</li>
<li>自增长有两个变量控制
<ul>
<li>初始值：<code>auto_increment_offset</code>，默认为1</li>
<li>步长：<code>auto_increment_increment</code>，默认为1</li>
<li>查看自增长控制：<code>show variables like 'auto_increment'</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据类型为整形</li>
<li>确定数据需要有规则的变化
<ul>
<li>从1开始</li>
<li>每次增长1</li>
<li>可以调整，但是通常有固定规则</li>
</ul>
</li>
<li>必须有索引字段（索引主键）</li>
<li>使用<code>auto_increment</code></li>
</ol>
</blockquote>
<h5 id="示例-19">示例</h5>
<ol>
<li>
<p>记录学生信息：学号和姓名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 学生信息：学号自动增长
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
	stu_no <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">zerofill</span> <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
	stu_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div></li>
<li>
<p>触发自增长</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 使用自增长 可以使用NULL或者default触发
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;Jim&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">default</span>,<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;Tom&#39;</span>);

<span style="color:#75715e">#主动控制：自增长的值会从当前最大的值开始自动增长
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;张三&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span> (stu_no,stu_name) <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">4</span>,<span style="color:#e6db74">&#39;李四&#39;</span>);
</code></pre></div></li>
</ol>
<h4 id="自增长管理">自增长管理</h4>
<ul>
<li>修改表中自增长的值：让下次自增长按照指定的值开始</li>
<li>修改自增长的控制：调整自增长的变化</li>
</ul>
<h5 id="示例-20">示例</h5>
<ol>
<li>
<p>修改表中自增长的值，跳过一些值，直接从下次开始按照新的目标出现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">auto_increment</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>;
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span> (stu_no,stu_name) <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#39;测试1&#39;</span>);

<span style="color:#75715e"># 奇数保留原值，偶数自动加一（可能）  由于数据不稳定
</span></code></pre></div></li>
<li>
<p>修改自增长控制：步长和起始值（修改针对的是整个数据库，而非单张表）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> auto_increment_increment <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e"># 当前用户当前连接有效（局部）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">set</span> <span style="color:#f92672">@@</span>auto_increment_incremtn <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e"># 所有用户一定有效（全局）
</span></code></pre></div></li>
</ol>
<h4 id="唯一键">唯一键</h4>
<ul>
<li><code>unique key</code>，用来维护数据的唯一性</li>
<li>一个表中可以有多个唯一键</li>
<li>唯一键与主键的区别在于唯一键允许数据为Null（且数量不限）</li>
<li>唯一键与主键一样，可以提升字段数据当做条件查询的效率（索引）</li>
<li>复合唯一键：多个字段共同组成
<ul>
<li><code>unique key(字段1,字段2,字段3,...)</code></li>
<li>一般不会出现，最多2个字段组成</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
<ol>
<li>确定数据列具有唯一性</li>
<li>确定数据列不用作为主键</li>
<li>确定数据会经常用于检索条件</li>
<li>该字段是否允许数据为空</li>
<li>使用唯一键</li>
</ol>
</blockquote>
<h5 id="示例-21">示例</h5>
<ol>
<li>
<p>用户表：用户名唯一，而且经常作为查询条件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
    id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
    <span style="color:#f92672">`</span>username<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">unique</span>,
    <span style="color:#f92672">`</span>password<span style="color:#f92672">`</span> <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">32</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#66d9ef">Null</span>,<span style="color:#e6db74">&#39;password&#39;</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#66d9ef">Null</span>,<span style="color:#e6db74">&#39;password&#39;</span>);

<span style="color:#75715e"># 错误
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;username&#39;</span>,<span style="color:#e6db74">&#39;password&#39;</span>);
</code></pre></div></li>
<li>
<p>学生成绩表：一个学生只能有一个学科成绩，但是可以有多个学科</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 学号和学科编号共同组成唯一
</span><span style="color:#75715e"></span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span>,
    stu_name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    course <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>,
    score <span style="color:#66d9ef">decimal</span> (<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">2</span>),
    <span style="color:#66d9ef">unique</span> <span style="color:#66d9ef">key</span>(stu_name,course)
)<span style="color:#66d9ef">charset</span> utf8;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Jim&#39;</span>,<span style="color:#e6db74">&#39;Math&#39;</span>,<span style="color:#ae81ff">60</span>);
<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#66d9ef">null</span>,<span style="color:#e6db74">&#39;Jim&#39;</span>,<span style="color:#e6db74">&#39;English&#39;</span>,<span style="color:#ae81ff">60</span>);
</code></pre></div></li>
</ol>
<h4 id="唯一键管理">唯一键管理</h4>
<ul>
<li>删除唯一键：一张表中不止一个唯一键，所以删除方式相对麻烦：<code>alter table 表名 drop index 唯一键名字</code></li>
<li>新增唯一键：<code>alter table 表名 add unique key(字段列表)</code></li>
</ul>
<h5 id="示例-22">示例</h5>
<ol>
<li>
<p>删除表中已有的唯一键</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">index</span> <span style="color:#f92672">`</span>stu_name<span style="color:#f92672">`</span>;
</code></pre></div></li>
<li>
<p>追加唯一键</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">unique</span> <span style="color:#66d9ef">key</span> <span style="color:#f92672">`</span>stu_course<span style="color:#f92672">`</span> (stu_name,course);
</code></pre></div></li>
</ol>
<h4 id="comment-属性">comment 属性</h4>
<ul>
<li><code>comment</code>，是用文字描述字段的作用的</li>
<li>comment代表的内容是对字段的描述
<ul>
<li>方便以后自己了解字段的作用</li>
<li>方便团队了解字段的作用</li>
</ul>
</li>
<li>描述如果涉及到字符集（中文）一定要在创建表之前设计好客户端字符集（否则会出现乱码）</li>
</ul>
<h5 id="示例-23">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t1</span>(
	id <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span> <span style="color:#66d9ef">auto_increment</span> comment <span style="color:#e6db74">&#39;id逻辑主键自增长&#39;</span>
)<span style="color:#66d9ef">charset</span> utf8;
</code></pre></div><h3 id="数据库记录长度">数据库记录长度</h3>
<ul>
<li>MySQL中规定一条记录所占用的存储长度最长不超过65535个字节</li>
<li>记录长度是表中所有字段预计占用的长度之和</li>
<li>所有字段只要允许Null存在，系统就会一个字节存储Null</li>
<li>因为MySQL记录长度的存在，varchar永远达不到理论长度</li>
<li>一般数据长度超过255个字符都会使用<code>text/blob</code>进行存储</li>
</ul>]]></content:encoded>
    </item>
    
    <item>
      <title>字符集、校对集</title>
      <link>https://www.niuwx.cn/posts/mysql/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%9B%86/</link>
      <pubDate>Fri, 16 Jul 2021 10:31:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E9%9B%86/</guid>
      <description>简单介绍了一下字符集校对集</description>
      <content:encoded><![CDATA[<h3 id="字符集">字符集</h3>
<p>了解字符集的概念，掌握MySQL数据库存储数据的字符集逻辑以及设置方式</p>
<h4 id="字符集的概念">字符集的概念</h4>
<ul>
<li>字符集根据不同国家的符号不同，有不同的字符集</li>
<li>不同的字符集占用的存储空间不一样，存储的底层也不一样</li>
<li>不同字符集之间可以进行转换</li>
<li>常见字符集
<ul>
<li>ASCⅡ：美国信息交换标准码，一般英文符号，一个字节存储</li>
<li>latin1：拉丁文字符集，一个字节存储，ISO-8859-1的别名，能够向下兼容ASCIⅡ</li>
<li>GB2312：信息交换用汉字编码字符集，是中国1981年的一套国际规范，2个字节存储</li>
<li>GBK：汉字内码拓展规范（1995年），两个字节表示</li>
<li>Unicode：万国码（统一码），使用同一的编码方式来解决传统的局限，1994年出现</li>
<li>UTF-8：针对Unicode的可变长度字符编码，采用1-6个字节编码Unicode字符 （目前通用编码规则）。建议使用UTF-8字符集进行数据存储。（MySQL8中建议使用UTF8MB4）</li>
</ul>
</li>
</ul>
<h5 id="示例">示例</h5>
<p>ASCⅡ码表</p>
<h4 id="mysql字符集">MySQL字符集</h4>
<ul>
<li>MySQL内部对象可以在各个层级设置字符集</li>
<li>MySQL内部对象存在字符集继承：字段-&gt;表-&gt;数据库-&gt;DBMS</li>
<li>MySQL内部内嵌几乎所有主流字符集</li>
<li>数据存储的最终字符集由字段控制</li>
<li>客户端与服务器进行交互时，需要明确告知服务器客户端自己的字符集（数据格式）</li>
</ul>
<h5 id="示例-1">示例</h5>
<p>查看MySQL支持的所有字符集</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">charset</span>;
</code></pre></div><h4 id="乱码问题解决">乱码问题解决</h4>
<ul>
<li>
<p>乱码原因1：数据在存储的时候已经变成乱码</p>
<ul>
<li>客户端字符集与服务端解析字符集不一致</li>
<li>读取时想转成其他字符集均会错误</li>
</ul>
</li>
<li>
<p>乱码原因2：数据存储时正确，但是读取时解析成错误字符集</p>
<ul>
<li>客户端能解析的字符集与服务器提供的字符集不一致</li>
</ul>
</li>
<li>
<p>乱码解决方案：不论存储还是读取，都提前告知服务器当前客户端的字符集</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> names <span style="color:#960050;background-color:#1e0010">客户端字符集</span>;
</code></pre></div></li>
</ul>
<h4 id="字符集设置原理">字符集设置原理</h4>
<ul>
<li>MySQL服务器提供了变量来记录客户端的字符集</li>
<li>MySQL对应的存储字符集的变量可以修改</li>
<li><code>set names 字符集</code>就是对变量的修改，总共有三个
<ul>
<li><code>character_set_client</code>：客户端提供的数据的字符集</li>
<li><code>character_set_results</code>：客户端需要服务端提供的数据的字符集</li>
<li><code>character_set_connection</code>：连接使用的字符集，内部数据操作</li>
</ul>
</li>
</ul>
<h5 id="示例-2">示例</h5>
<ol>
<li>
<p>查看系统内部存储这些记录字符集的信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;character_set%&#39;</span> <span style="color:#75715e">#  %表示通配符，匹配后续不确定的数据
</span></code></pre></div></li>
<li>
<p>修改客户端字符变量，保证数据正常存进服务端</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> character_set_client <span style="color:#f92672">=</span> gbk;
</code></pre></div></li>
<li>
<p>修改客户端解析字符集变量，保证数据正常被客户端查看</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> character_set_results <span style="color:#f92672">=</span> gbk;
</code></pre></div></li>
<li>
<p>使用<code>set names 字符集</code>批量修改，保证客户端被服务端正确理解，同时客户端也能正常解析</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">set</span> names gbk;
</code></pre></div></li>
</ol>
<h3 id="校对集">校对集</h3>
<h4 id="校对集概念">校对集概念</h4>
<ul>
<li>数据比较时对应的规则</li>
<li>校对集依赖字符集</li>
<li>校对集的校对方式分为三种：
<ul>
<li>大小写不敏感：<code>_ci</code>,<code>case insensitive</code></li>
<li>大小写敏感：<code>_cs</code>，<code>case sensitive</code></li>
<li>二进制比较：<code>_bin</code>,<code>binary</code>（大小写敏感）</li>
</ul>
</li>
<li>校对集是在进行数据比较的时候触发</li>
</ul>
<h5 id="示例-3">示例</h5>
<ol>
<li>
<p><code>_ci</code>，大小写不敏感</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># A 和 a是相同的，不存在谁大谁小
</span></code></pre></div></li>
<li>
<p><code>_cs</code>，大小写敏感</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># A 和 a有大小关系，所以不同
</span></code></pre></div></li>
<li>
<p><code>_bin</code>，二进制比较</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># A 的二进制 01000001
</span><span style="color:#75715e"># a 的二进制 01100001
</span><span style="color:#75715e"># 二进制按位比较，所以不同
</span></code></pre></div></li>
</ol>
<h4 id="校对集设置">校对集设置</h4>
<ul>
<li>
<p>校对规则可以在MySQL四层对象设计</p>
<ul>
<li>DBMS：系统配置</li>
<li>DB：数据库指定（库选项）</li>
<li>Table：标指定（表选项）</li>
<li>Filed：字段指定（字段选项，一般不用）</li>
</ul>
</li>
<li>
<p>校对集从Field到DBMS继承：优先级Field最高</p>
</li>
<li>
<p>每个校对集都有字符集对应的默认规则</p>
</li>
<li>
<p>校对集设置语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">collate</span> <span style="color:#960050;background-color:#1e0010">校对集规则</span>;
</code></pre></div></li>
</ul>
<h5 id="示例-4">示例</h5>
<ol>
<li>
<p>查看MySQL支持的所有校对集</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> collation;
</code></pre></div></li>
<li>
<p>在数据库层设置校对集（常用）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> test_4 <span style="color:#66d9ef">charset</span> utf8MB4 <span style="color:#66d9ef">collate</span> utf8MB4_bin;
</code></pre></div></li>
<li>
<p>在数据表层设计校对集</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t_4</span>(
	id <span style="color:#66d9ef">int</span>,
    name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>)
) <span style="color:#66d9ef">charset</span> utf8Mb4 <span style="color:#66d9ef">collate</span> utf8MB4_bin;
</code></pre></div></li>
<li>
<p>在字段层设计校对集（一般不常用）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t_4</span>(
	id <span style="color:#66d9ef">int</span>,
    name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>) <span style="color:#66d9ef">collate</span> utf8Mb4_bin
)<span style="color:#66d9ef">charset</span> utf8MB4;
</code></pre></div></li>
</ol>
<h4 id="校对集应用">校对集应用</h4>
<ul>
<li>校对集的应用通常是通过<strong>数据比较</strong>触发：<code>order by 字段</code></li>
<li>数据表中数据一旦产生，校对集的修改就无效</li>
</ul>
<h5 id="示例-5">示例</h5>
<ol>
<li>
<p>创建校对规则数据表并插入数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e"># 创建默认校对规则表（不区分大小写）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">t1</span>(
    name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">1</span>)
)<span style="color:#66d9ef">CHARSET</span> utf8Mb4;

<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#34;B&#34;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#34;A&#34;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#34;b&#34;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#e6db74">&#34;a&#34;</span>);

<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> name;
<span style="color:#75715e">#执行结果
</span><span style="color:#75715e"></span>A
a
B
b

<span style="color:#75715e"># 创建二进制校对规则（区分大小写）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">t2</span>(
    name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">1</span>)
)<span style="color:#66d9ef">charset</span> utf8MB4 <span style="color:#66d9ef">collate</span> utf8MB4_bin;

<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t2 <span style="color:#66d9ef">VALUES</span>(<span style="color:#e6db74">&#34;B&#34;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t2 <span style="color:#66d9ef">VALUES</span>(<span style="color:#e6db74">&#34;A&#34;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t2 <span style="color:#66d9ef">VALUES</span>(<span style="color:#e6db74">&#34;b&#34;</span>);
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t2 <span style="color:#66d9ef">VALUES</span>(<span style="color:#e6db74">&#34;a&#34;</span>);

<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> name;
<span style="color:#75715e">#执行结果
</span><span style="color:#75715e"></span>A
B
a
b
</code></pre></div></li>
<li>
<p>触发校对：排序<code>order by</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> name;
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t2 <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> name;
</code></pre></div></li>
<li>
<p>数据已经存在的表重新修改校对规则</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">collate</span> utf8MB4_general_ci;
<span style="color:#75715e"># 不会报错，但是实际校对规则依旧不变
</span></code></pre></div></li>
</ol>
<p>校对集的触发自动的，只要数据在进行比较的时候就会自动触发设定的校对规则。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL基本操作</title>
      <link>https://www.niuwx.cn/posts/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Thu, 15 Jul 2021 22:31:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>简单介绍了一下高级SQL操作</description>
      <content:encoded><![CDATA[<h3 id="sql语法规则">SQL语法规则</h3>
<blockquote>
<p>概念
<strong>SQL语法规则</strong>：SQL是一种结构化编程语言</p>
</blockquote>
<ul>
<li>基础SQL指令通常是以行为单位</li>
<li>SQL指令需要语句结束符，默认是英文分号：<code>;</code>、<code>\g</code>、<code>\G</code>
<ul>
<li><code>\G</code>：主要用于查询数据</li>
</ul>
</li>
<li>SQL指令类似自然语言</li>
<li>编写的SQL中如果用到了关键字或者保留字，需要使用反引号``来包括，让系统忽略</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<ol>
<li>结构创建</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#960050;background-color:#1e0010">数据类型</span> <span style="color:#960050;background-color:#1e0010">结构名</span> <span style="color:#960050;background-color:#1e0010">结构类型</span>;
</code></pre></div><ol start="2">
<li>显示结构</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e">#显示结构
</span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> <span style="color:#960050;background-color:#1e0010">结构类型（复数）</span>;

<span style="color:#75715e">#显示结构创建详细
</span><span style="color:#75715e"></span><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">create</span> <span style="color:#960050;background-color:#1e0010">结构类型</span> <span style="color:#960050;background-color:#1e0010">结构名</span>;
</code></pre></div><ol start="3">
<li>数据操作（数据表）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#75715e">#新增数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">values</span>

<span style="color:#75715e">#查看数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">表名</span>

<span style="color:#75715e">#更新数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">update</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">set</span>

<span style="color:#75715e">#删除数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">表名</span>
</code></pre></div><p>根据数据库的对象层级，可以将基础SQL操作分为三类：</p>
<ul>
<li>库操作：数据库相关操作</li>
<li>表操作：数据表（字段）相关操作</li>
<li>数据操作：数据相关操作</li>
</ul>
<h3 id="sql库操作">SQL库操作</h3>
<h4 id="创建数据库">创建数据库</h4>
<ul>
<li>使用<code>create database 数据库名字</code> 创建
<ul>
<li>数据库层面可以指定字符集：<code>charset/character set</code></li>
</ul>
</li>
<li>数据库层面可以指定校对集：<code>collate</code></li>
<li>创建数据库会在磁盘指定存放处产生一个文件夹</li>
<li>创建语法：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> <span style="color:#960050;background-color:#1e0010">数据库名字</span> [<span style="color:#960050;background-color:#1e0010">数据库选项</span>];
</code></pre></div><h5 id="示例">示例</h5>
<ol>
<li>
<p>创建一个指定名字的数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> test_1;
</code></pre></div></li>
<li>
<p>创建一个指定字符集的数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> test_2 <span style="color:#66d9ef">charset</span> utf8MB4
</code></pre></div></li>
<li>
<p>创建一个指定校对集的数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> test_3 <span style="color:#66d9ef">charset</span> utf8MB4 <span style="color:#66d9ef">collate</span> utf8mb4_general_ci;
</code></pre></div></li>
</ol>
<p>数据库命名规则：与C同</p>
<h4 id="显示数据库">显示数据库</h4>
<ul>
<li>数据库的查看是根据用户权限限定的</li>
<li>数据库的查看分为两种查看方式：
<ul>
<li>查看全部数据库</li>
<li>查看数据库创建指令</li>
</ul>
</li>
</ul>
<h5 id="示例-1">示例</h5>
<ol>
<li>
<p>显示数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">databases</span>;
</code></pre></div></li>
<li>
<p>显示数据库创建命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">databases</span> test_1;
</code></pre></div></li>
</ol>
<h4 id="使用数据库">使用数据库</h4>
<ul>
<li>数据库的操作通常是针对数据表或数据</li>
<li>通过使用数据库可以让后续指令默认针对具体数据库环境、简化后续命令</li>
<li>使用数据库语法：<code>use 数据库名字;</code></li>
</ul>
<h5 id="示例-2">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">use</span> test_1;
</code></pre></div><h4 id="修改数据库">修改数据库</h4>
<ul>
<li>
<p>数据库名字不可修改（老版本可以）</p>
<ul>
<li>先新增</li>
<li>后迁移</li>
<li>再删除</li>
</ul>
</li>
<li>
<p>数据库修改分为两个部分</p>
<ul>
<li>字符集</li>
<li>校对集</li>
</ul>
</li>
<li>
<p>数据库修改指令（与创建指令差不多）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">database</span> <span style="color:#960050;background-color:#1e0010">数据库名字</span> <span style="color:#960050;background-color:#1e0010">库选项</span>
</code></pre></div></li>
</ul>
<h5 id="示例-3">示例</h5>
<ol>
<li>
<p>修改数据库字符集</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">database</span> test_2 <span style="color:#66d9ef">charset</span> dbk;
</code></pre></div></li>
<li>
<p>修改数据库校对集（如果字符集修改必须同时改变字符集）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">database</span> test_3 <span style="color:#66d9ef">charset</span> gbk <span style="color:#66d9ef">collate</span> gbk_chinese_ci;
</code></pre></div></li>
</ol>
<h4 id="删除数据库">删除数据库</h4>
<ul>
<li>
<p>删除数据库会删除数据库内所有的表和数据</p>
</li>
<li>
<p>删除数据库操作要慎重（删前备份）</p>
</li>
<li>
<p>删除数据库后，对应的存储文件夹就会消失</p>
</li>
<li>
<p>删除语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">database</span> <span style="color:#960050;background-color:#1e0010">数据库名字</span>;
</code></pre></div></li>
</ul>
<h5 id="示例-4">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">database</span> test_1;
</code></pre></div><h3 id="sql表字段操作">SQL表（字段）操作</h3>
<h4 id="创建数据表">创建数据表</h4>
<p>根据业务需求，确定数据表的字段信息，然后创建表结构</p>
<ul>
<li>
<p>表与字段不分家，相辅相成</p>
</li>
<li>
<p>表的创建需要指定存储的数据库</p>
<ul>
<li>明确指定数据库</li>
<li>先使用数据库</li>
</ul>
</li>
<li>
<p>字段至少需要指定改名字、类型</p>
</li>
<li>
<p>数据库表不限定字段数量</p>
<ul>
<li>每个字段间使用逗号<code>,</code>分隔</li>
<li>最后一个字段不需要逗号</li>
</ul>
</li>
<li>
<p>表可以指定表选项（都有默认值）</p>
<ul>
<li>存储引擎：engine[=]具体存储引擎</li>
<li>字符集：[default] charset 具体字符集 （继承数据库）</li>
<li>校对集：collate（继承数据库）</li>
</ul>
</li>
<li>
<p>表创建语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> [<span style="color:#960050;background-color:#1e0010">数据库名</span>.]<span style="color:#960050;background-color:#1e0010">表名</span>(
	<span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#960050;background-color:#1e0010">字段类型</span>,
    ...
	<span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#960050;background-color:#1e0010">字段类型</span>,
)<span style="color:#960050;background-color:#1e0010">表选项</span>;
</code></pre></div></li>
</ul>
<h5 id="示例-5">示例</h5>
<ol>
<li>
<p>创建简单数据表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t_1</span>(
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>)
);
</code></pre></div></li>
<li>
<p>创建数据表&mdash;多字段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t_2</span>(
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>),
    age <span style="color:#66d9ef">int</span>,
    gender <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">10</span>)
);
</code></pre></div></li>
<li>
<p>创建数据表&mdash;表选项</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> <span style="color:#a6e22e">t_3</span>(
	name <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">50</span>)
)<span style="color:#66d9ef">engine</span> Innodb <span style="color:#66d9ef">charset</span> utf8MB4;
</code></pre></div></li>
</ol>
<blockquote>
<p><strong>拓展</strong></p>
<p>存储引擎是指数据存储和管理方式，MySQL中提供了多种存储引擎，一般使用默认存储引擎。</p>
<ul>
<li>InnoDB
<ul>
<li>默认存储引擎</li>
<li>支持事务处理和外键</li>
<li>数据统一管理</li>
</ul>
</li>
<li>MyIsam
<ul>
<li>不支持事务和外键</li>
<li>数据、表结构、索引独立管理</li>
<li>MySQL5.6以后不在维护</li>
</ul>
</li>
</ul>
<p>如果想创建一个与已有表一样的数据表，MySQL提供了一个便捷的复制模式</p>
<ul>
<li><code>create table 表名 like 数据库名字.表名</code></li>
</ul>
</blockquote>
<h4 id="显示数据表">显示数据表</h4>
<ul>
<li>数据表的显示与用户权限有关</li>
<li>显示数据表有两种方式
<ul>
<li>显示所有数据表</li>
<li>显示具体数据表的创建指令</li>
</ul>
</li>
</ul>
<h5 id="示例-6">示例</h5>
<ol>
<li>
<p>显示所有数据表&mdash;当前数据库下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">tables</span>;
</code></pre></div></li>
<li>
<p>显示所有数据表&mdash;指定数据库</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">tables</span> <span style="color:#66d9ef">from</span> test_1;
</code></pre></div></li>
<li>
<p>显示部分关联数据表&mdash;匹配</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">tables</span> <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%like&#39;</span>;
<span style="color:#75715e">#_：匹配一个字符(固定位置)
</span><span style="color:#75715e">#%：匹配N个字符
</span></code></pre></div></li>
<li>
<p>显示数据表的创建指令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">show</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> t_1;
</code></pre></div></li>
</ol>
<h4 id="查看数据表">查看数据表</h4>
<ul>
<li>
<p>通常是查看字段信息</p>
</li>
<li>
<p>详细的显示字段的各项信息</p>
</li>
<li>
<p>查看语法有三种</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">desc</span> <span style="color:#960050;background-color:#1e0010">表名</span>;
<span style="color:#66d9ef">describe</span> <span style="color:#960050;background-color:#1e0010">表名</span>;
<span style="color:#66d9ef">show</span> columns <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">表名</span>;
</code></pre></div></li>
</ul>
<h4 id="更改数据表">更改数据表</h4>
<ul>
<li>更改表名：<code>rename teble 表名 to 新表名</code></li>
<li>修改表选项：<code>alter table 表名</code></li>
</ul>
<h5 id="示例-7">示例</h5>
<ol>
<li>
<p>修改表名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">rename</span> <span style="color:#66d9ef">table</span> t_1 <span style="color:#66d9ef">to</span> t1;
</code></pre></div><p><strong>注意</strong>：如果有时候要跨库修改的话，需要使用数据库名.表名</p>
</li>
<li>
<p>修改表选项</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">charset</span> gbk;
</code></pre></div></li>
</ol>
<h4 id="更改字段">更改字段</h4>
<ul>
<li>字段操作包含字段名字、类型和属性的操作</li>
<li>字段操作通常是在表已经存在数据后进行</li>
</ul>
<h5 id="新增字段">新增字段</h5>
<ul>
<li>
<p>字段的新增必须同时存在字段类型</p>
</li>
<li>
<p>新增语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">add</span> [<span style="color:#66d9ef">column</span>] <span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#960050;background-color:#1e0010">字段类型</span> [<span style="color:#960050;background-color:#1e0010">字段属性</span>] [<span style="color:#960050;background-color:#1e0010">字段位置</span>]
</code></pre></div></li>
</ul>
<h6 id="示例-8">示例</h6>
<ol>
<li>
<p>给已经存在的表增加一个字段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> age <span style="color:#66d9ef">int</span>;
</code></pre></div></li>
</ol>
<h5 id="字段位置">字段位置</h5>
<ul>
<li>
<p>字段位置分为两种</p>
<ul>
<li>第一个字段：<code>first</code></li>
<li>某个字段后：<code>after</code>已经存在字段名</li>
</ul>
</li>
<li>
<p>字段位置适用于追加字段、修改字段、更改字段名</p>
</li>
<li>
<p>字段位置语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#960050;background-color:#1e0010">字段操作</span> <span style="color:#960050;background-color:#1e0010">字段位置</span>;
</code></pre></div></li>
</ul>
<h6 id="示例-9">示例</h6>
<ol>
<li>
<p>为表增加一个字段，放在最前面</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> id <span style="color:#66d9ef">int</span> first;
</code></pre></div></li>
<li>
<p>在表某字段后增加一个字段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">add</span> card <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">18</span>) after name;
</code></pre></div></li>
</ol>
<h5 id="更改字段名">更改字段名</h5>
<ul>
<li>
<p>字段名的修改必须跟上字段类型</p>
</li>
<li>
<p>字段名修改语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">change</span> <span style="color:#960050;background-color:#1e0010">原字段名</span> <span style="color:#960050;background-color:#1e0010">新字段名</span> <span style="color:#960050;background-color:#1e0010">字段类型</span> [<span style="color:#960050;background-color:#1e0010">字段属性</span>] [<span style="color:#960050;background-color:#1e0010">位置</span>];
</code></pre></div></li>
</ul>
<h6 id="示例-10">示例</h6>
<p>修改字段名card为sfz</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">change</span> card sfz <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">18</span>);
</code></pre></div><h5 id="修改字段">修改字段</h5>
<ul>
<li>
<p>修改字段类型、字段属性和位置</p>
</li>
<li>
<p>修改字段语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> modify <span style="color:#960050;background-color:#1e0010">字段名</span> <span style="color:#960050;background-color:#1e0010">字段类型</span> [<span style="color:#960050;background-color:#1e0010">字段属性</span>] [<span style="color:#960050;background-color:#1e0010">位置</span>];
</code></pre></div></li>
</ul>
<h6 id="示例-11">示例</h6>
<p>修改sfz类型为char(18)并且把位置放到id后面</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 modify sfz <span style="color:#66d9ef">char</span>(<span style="color:#ae81ff">18</span>) after id;
</code></pre></div><h4 id="删除字段">删除字段</h4>
<ul>
<li>
<p>删除字段会将数据也删除</p>
</li>
<li>
<p>删除字段语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">drop</span> <span style="color:#960050;background-color:#1e0010">字段名</span>;
</code></pre></div></li>
</ul>
<h5 id="示例-12">示例</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t1 <span style="color:#66d9ef">drop</span> age;
</code></pre></div><h3 id="sql数据操作">SQL数据操作</h3>
<h4 id="新增数据">新增数据</h4>
<ul>
<li>新增数据是根据表的字段顺序和数据类型要求将数据存放到数据表中</li>
<li>数据表中的数据以行(row)为存储单位，实际存储属于字段(field)存储数据</li>
<li>数据插入分两种方式
<ul>
<li>全字段插入：<code>insert into 表名 values(字段列表顺序对应的所有值)</code></li>
<li>部分字段插入：<code>insert into 表名(字段列表) values(字段列表对应的值的顺序列表)</code></li>
</ul>
</li>
</ul>
<h5 id="示例-13">示例</h5>
<ol>
<li>
<p>插入完整数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> t1 <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#34;666&#34;</span>,<span style="color:#e6db74">&#34;张三&#34;</span>,<span style="color:#e6db74">&#34;小张&#34;</span>);
</code></pre></div></li>
<li>
<p>根据字段插入数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> <span style="color:#a6e22e">t1</span> (id,name ) <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">1</span>,<span style="color:#e6db74">&#34;李四&#34;</span>);
</code></pre></div></li>
</ol>
<h4 id="查看数据">查看数据</h4>
<ul>
<li>
<p>查到的数据显示出来是一张二维表</p>
</li>
<li>
<p>数据显示包含字段名和字段本身</p>
</li>
<li>
<p>数据查看分两种方式</p>
<ul>
<li>查看全部字段：使用<code>*</code>代替所有字段</li>
<li>查看部分字段：明确字段名，使用逗号分隔</li>
</ul>
</li>
<li>
<p>查看数据很多时候也是根据条件查询部分数据</p>
</li>
<li>
<p>查看语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*/</span><span style="color:#960050;background-color:#1e0010">字段列表</span> <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">表名</span>;
</code></pre></div></li>
</ul>
<h5 id="示例-14">示例</h5>
<ol>
<li>
<p>查看所有数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1;
</code></pre></div></li>
<li>
<p>查看部分字段数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> id,name;
</code></pre></div></li>
<li>
<p>查看表中id为1的信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div></li>
</ol>
<h4 id="更新数据">更新数据</h4>
<ul>
<li>
<p>更新数据通常时根据条件更新某些数据，而不是全部记录都更新</p>
</li>
<li>
<p>更新数据语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">update</span> <span style="color:#960050;background-color:#1e0010">表名</span> <span style="color:#66d9ef">set</span> <span style="color:#960050;background-color:#1e0010">字段</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">新值</span>[,<span style="color:#960050;background-color:#1e0010">字段</span> <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">新值</span>] [<span style="color:#66d9ef">where</span> <span style="color:#960050;background-color:#1e0010">条件筛选</span>];
</code></pre></div></li>
</ul>
<h5 id="示例-15">示例</h5>
<ol>
<li>
<p>更新所有记录的身份信息</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> sfz <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;777&#34;</span>;
</code></pre></div></li>
<li>
<p>更新某个记录的多个字段数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">update</span> t1 <span style="color:#66d9ef">set</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;张三&#34;</span><span style="color:#960050;background-color:#1e0010">，</span>sfz <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;666&#34;</span> <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">777</span>;
</code></pre></div></li>
</ol>
<h4 id="删除数据">删除数据</h4>
<ul>
<li>
<p>删除数据是一种不可逆操作</p>
</li>
<li>
<p>数据删除通常都是有条件删除</p>
</li>
<li>
<p>数据删除语法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> <span style="color:#960050;background-color:#1e0010">表名</span> [<span style="color:#66d9ef">where</span> <span style="color:#960050;background-color:#1e0010">条件</span>];
</code></pre></div></li>
</ul>
<h5 id="示例-16">示例</h5>
<p>删除数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-mysql" data-lang="mysql"><span style="color:#66d9ef">delete</span> <span style="color:#66d9ef">from</span> t1 <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">777</span>;
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL基本操作</title>
      <link>https://www.niuwx.cn/posts/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 15 Jul 2021 19:31:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</guid>
      <description>简单介绍了一下MySQL基本操作</description>
      <content:encoded><![CDATA[<h3 id="数据库的基本知识">数据库的基本知识</h3>
<blockquote>
<p>概念</p>
<p><strong>数据库</strong>：database，是一种存储数据的仓库。</p>
</blockquote>
<ul>
<li>数据库是根据数据结构组织，存储和管理数据的</li>
<li>数据库能够长期、高效的管理和存储数据</li>
<li>数据库的目的就是能够存储（写）和提供（读）数据</li>
</ul>
<h3 id="数据库分类">数据库分类</h3>
<blockquote>
<p>概念</p>
<p><strong>数据库分类</strong>：根据数据库的架构和数据组织原理进行分类。</p>
</blockquote>
<ol>
<li>
<p>早起根据数据库的组织数据的存储模型分类</p>
<ul>
<li>层次数据库：基于层次的数据结构（数据分层）</li>
<li>网状数据库：基于网状的数据结构（数据网络）</li>
<li>关系数据库：基于关系模型的数据结构（二维表）</li>
</ul>
</li>
<li>
<p>现在较多根据实际数据管理模型分类（存储介质）</p>
<ul>
<li>关系型数据库：基于关系模型的数据结构（二维表）通常存储在磁盘</li>
<li>非关系型数据库：没有具体模型的数据结构（键值对）通常存储在内存</li>
</ul>
</li>
</ol>
<h4 id="关系型数据库">关系型数据库</h4>
<blockquote>
<p>概念</p>
<p><strong>关系型数据库</strong>：一种建立在关系模型上的数据库</p>
</blockquote>
<ul>
<li>关系模型：
<ul>
<li>关系数据结构（存储）</li>
<li>关系操作集合（操作）</li>
<li>关系完整约束（约束）</li>
</ul>
</li>
<li>关系型数据库存储在磁盘中（永久性存储）</li>
<li>关系型数据库系统(DBS)模型有四层结构
<ul>
<li>数据库管理系统(DBMS)：管理系统运行</li>
<li>数据库(DB)：数据存储的管理者</li>
<li>数据表(Table)：数据关系管理者</li>
<li>数据字段(Field)：依赖于数据表、实际数据存储者</li>
</ul>
</li>
<li>关系型数据库产品
<ul>
<li>大型：Oracle、DB2</li>
<li>中性：MySQL、SqlServer</li>
<li>小型：Sybase、Access</li>
</ul>
</li>
</ul>
<h4 id="非关系型数据库">非关系型数据库</h4>
<blockquote>
<p>概念</p>
<p><strong>非关系型数据库</strong>：NoSQL（Not only SQL），不仅仅是关系型数据库</p>
</blockquote>
<ul>
<li>所以不是关系型数据库的统称</li>
<li>数据存储模型不是二维表，而是键值对（KEY-VALUE）</li>
<li>存储的位置通常是内存（效率高）</li>
<li>不能永久性存储（需要定时存到关系型数据库中）</li>
<li>常见的非关系型数据库产品
<ul>
<li>MongoDB</li>
<li>Redis</li>
<li>Memcached</li>
</ul>
</li>
</ul>
<h4 id="对比">对比</h4>
<p>NoSQL通常与关系型数据库配合使用，他们彼此是一种互补关系。</p>
<ul>
<li>NoSQL运行在内存、解决效率问题
<ul>
<li>I/O问题</li>
<li>效率问题</li>
</ul>
</li>
<li>MySQL运行在磁盘、解决稳定问题
<ul>
<li>安全问题（永久存储）</li>
<li>稳定</li>
</ul>
</li>
</ul>
<h3 id="sql基本介绍">SQL基本介绍</h3>
<blockquote>
<p>概念</p>
<p><strong>SQL</strong>：<code>Structured Query Language</code>，结构化查询语言，是一种针对关系型数据库特殊标准化的编程语言。</p>
</blockquote>
<ul>
<li>SQL是一种编程语言</li>
<li>能够实现用户数据库查询和程序设计</li>
<li>SQL根据操作不同，分为几类：
<ul>
<li>DQL：<code>Data Query Language </code>，数据查询语言，用于查询和检索数据</li>
<li>DML：<code>Data Manipulation Language</code>，数据操作语言，用于数据的写操作（增删改）</li>
<li>DDL：<code>Data Definition Language</code>，数据定义语言，用于创建数据结构</li>
<li>DCL：<code>Data Control Language</code>，数据控制语言，用于用户权限管理</li>
<li>TPL：<code>Transaction Process Language</code>，事务处理语言，辅助DML进行事务操作（因此也归属于DML）</li>
</ul>
</li>
</ul>
<ol>
<li>SQL虽然是编程语言，但是目前数据库通常只用来进行数据管理（逻辑部分给其他编程语言）</li>
<li>SQL虽然是针对关系型数据库的通用语言，但是不同的产品操作指令不完全通用</li>
</ol>
<h3 id="mysql基本介绍">MySQL基本介绍</h3>
<blockquote>
<p>概念</p>
<p><strong>MySQL</strong>：瑞典AB公司下的一款<strong>关系型数据库</strong></p>
</blockquote>
<ul>
<li>MySQL当前属于甲骨文公司（AB-&gt;Sun-&gt;Oracle）</li>
<li>MySQL开源免费（部分存储引擎收费）</li>
<li>MySQL是一种C/S结构软件，因此需要MySQL的客户端来访问服务端（数据管理）
<ul>
<li>mysqld.exe：服务端</li>
<li>mysql.exe：客户端</li>
</ul>
</li>
<li>MySQL使用SQL指令对数据库进行操作</li>
</ul>
<h4 id="访问原理">访问原理</h4>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
A[MySQL客户端] --&gt;B[寻找服务端 host寻找]
    B --&gt; C[寻找服务器 Port寻找]
    C --&gt; D[验证身份 username验证 password验证]
    D --&gt; E{服务器}
</code></pre><h3 id="mysql访问">MySQL访问</h3>
<blockquote>
<p><strong>MySQL访问</strong>：客户端连接上服务器，然后实现数据操作的过程</p>
</blockquote>
<ul>
<li>客户端访问服务端
<ul>
<li>利用Windows控制台访问（MySQL客户端）</li>
<li>利用数据库管理工具（Navicat）</li>
</ul>
</li>
<li>客户端需要连接认证
<ul>
<li>-h：主机地址（本机localhost 、可以忽略）</li>
<li>-P：端口号（默认3306）</li>
<li>-u：用户名</li>
<li>-p：用户密码</li>
</ul>
</li>
<li>客户端连接上服务端就表示占用了一个资源，可以进行对应权限的操作
<ul>
<li>MySQL数据库连接资源有限：单个服务器最多16384个</li>
<li>连接资源不够了其他访问就需要排队等待</li>
<li>用完尽可能释放资源</li>
</ul>
</li>
</ul>]]></content:encoded>
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 27 Mar 2021 19:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>简单介绍了一下拓扑排序</description>
      <content:encoded><![CDATA[<p>这篇文章将介绍图论中的拓扑排序。</p>
<h3 id="什么是拓扑排序">什么是拓扑排序？</h3>
<p>对于任何有向无环图而言，其拓扑排序为其所有结点的一个线性排序（对于同一个有向五环图而言可能存在多个这样的结点排序）。</p>
<h3 id="拓扑排序">拓扑排序</h3>
<ul>
<li>入度：指向v的边的个数叫做v的入度。</li>
<li>出度：v指向的点的个数叫做v的出度。</li>
</ul>
<p>如果一个点的入度是<code>0</code>，那么说明这个点是起点（起点不止一个）。如果一个点的出度为<code>0</code>，那么说明这个点排在最后。</p>
<p>举例说明：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgDAG1.jpg" alt="DAG1"  />
</p>
<p>如图所示，这是一个有向无环图，其指向顺序为<code>a,(b,c),d,e</code>,则<code>abcde</code>和<code>acbde</code>都是这个图的拓扑排序。</p>
<p>很显然，一个图是有向无环图(DAG)是其可以进行拓扑排序的充要条件。</p>
<h3 id="拓扑排序的实现">拓扑排序的实现</h3>
<p>DFS和BFS都可以实现拓扑排序。</p>
<h4 id="bfs实现拓扑排序">BFS实现拓扑排序</h4>
<p>这种算法也叫做Kahn算法</p>
<p>继续使用上面的例子进行说明</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgDAG1.jpg" alt="DAG1"  />
</p>
<p>BFS实现拓扑排序有两个实现方向，即无前驱的顶点优先、无后继的顶点优先，简单点说就是顺着找或倒着找。两种方法都差不多，在这里只介绍无前驱的定点优先。</p>
<p>无前驱的顶点优先就是顺着找，a的入度为<code>0</code>，则其为起点，a入队；</p>
<p>a出队，a指向了c，c的入度减一，判断其入度是否为零，若为零，则入队，则c入队，b同理也入队；</p>
<p>目前队列中有{c,b}，c出队，c指向d，d入度减一，d入度不为零，不入队；</p>
<p>b出队，b指向d，d入度减一，d入度为零，入队；</p>
<p>d出队，d指向e，e入度减一，e入度为零，入队；</p>
<p>e出队，无后续结点，结束。</p>
<p>由上述过程可得拓扑排序为<code>acbde</code>。</p>
<h6 id="时间复杂度">时间复杂度</h6>
<p>假设这个图$G = (V,E)$，则其时间复杂度为$O(E+V)$。</p>
<p>代码实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
<span style="color:#66d9ef">int</span> T, n, m, u, v;

<span style="color:#66d9ef">int</span> deg[N];
<span style="color:#66d9ef">int</span> vis[N];
<span style="color:#66d9ef">int</span> dest[N];
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> g[N];
queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">toposort</span>() {
    <span style="color:#75715e">//将入度为零的点放入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>deg[i]) {
            vis[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            q.push(i);
        }
    }

    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty()) {
        <span style="color:#66d9ef">int</span> now <span style="color:#f92672">=</span> q.front();
        q.pop();
        dest[num<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> now;

        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> to : g[now]) {
            <span style="color:#66d9ef">if</span> (vis[to])  <span style="color:#75715e">//判断该节点是否在队列中
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span> {
                deg[to]<span style="color:#f92672">--</span>;        <span style="color:#75715e">//入度减一
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>deg[to]) {   <span style="color:#75715e">//判断入度是否为零
</span><span style="color:#75715e"></span>                    q.push(to);   <span style="color:#75715e">//入队
</span><span style="color:#75715e"></span>                    vis[to] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//标记其在队列中
</span><span style="color:#75715e"></span>                }
            }
        }
    }
    <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">==</span> n)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    memset(deg, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(deg));
    memset(vis, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(vis));
    memset(dest, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(dest));

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> N; i<span style="color:#f92672">++</span>)
        g[i].clear();

    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>q.empty())
        q.pop();
    <span style="color:#75715e">//以上为初始化
</span><span style="color:#75715e"></span>
    cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);  <span style="color:#75715e">//读入
</span><span style="color:#75715e"></span>        g[u].push_back(v);
        deg[v]<span style="color:#f92672">++</span>;  <span style="color:#75715e">//统计入度
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">if</span> (toposort()) {<span style="color:#75715e">//如果可以生成拓扑排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)  <span style="color:#75715e">//输出结果
</span><span style="color:#75715e"></span>            printf(<span style="color:#e6db74">&#34;%d%c&#34;</span>, dest[i], i <span style="color:#f92672">==</span> n <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39; &#39;</span>);
    }
    <span style="color:#66d9ef">else</span> printf(<span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//测试数据
</span><span style="color:#75715e">//有向有环图
</span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">2</span>
<span style="color:#75715e">//有向无环图
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>
</code></pre></div><h4 id="dfs实现拓扑排序">DFS实现拓扑排序</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;

<span style="color:#66d9ef">int</span> n, u, v;
<span style="color:#66d9ef">int</span> c[N];          <span style="color:#75715e">// 标志数组
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[N];  <span style="color:#75715e">// vector 实现的邻接表
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> topo;  <span style="color:#75715e">// 拓扑排序后的节点
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u) {
    c[u] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> v : G[u]) {
        <span style="color:#66d9ef">if</span> (c[v] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[v])
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(v))
                <span style="color:#66d9ef">return</span> false;
    }
    c[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    topo.push_back(u);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">toposort</span>() {
    topo.clear();
    memset(c, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(c));
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; u <span style="color:#f92672">&lt;</span> n; u<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[u])
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(u))
                <span style="color:#66d9ef">return</span> false;
    reverse(topo.begin(), topo.end());
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>高精度计算</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</link>
      <pubDate>Fri, 19 Mar 2021 22:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6/</guid>
      <description>简单介绍了一下高精度计算</description>
      <content:encoded><![CDATA[<p>C/C++中，当进行整数计算时，最多可以储存一个8bye的数据，也就是$2^{64}$，超过这个限度的数字，没有其他的数据类型来储存。所以就需要高精度来解决这一问题</p>
<h2 id="存储">存储</h2>
<p>高精度可以使用字符串或者数组来表示，在存储时逆序存储，在输出时逆序输出</p>
<h4 id="头文件及全局变量">头文件及全局变量</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> LEN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1004</span>;
<span style="color:#66d9ef">int</span> a[LEN], b[LEN], c[LEN], d[LEN];
<span style="color:#66d9ef">int</span> flag;
</code></pre></div><h4 id="清空">清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clean</span>(<span style="color:#66d9ef">int</span> temp[]) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN; <span style="color:#f92672">++</span>i)
        temp[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="存储-1">存储</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">int</span> temp[]) {
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> s[LEN <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
    scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, s);

    clean(temp);

    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> strlen(s);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) {
        temp[len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i] <span style="color:#f92672">=</span> s[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
    }
}
</code></pre></div><h4 id="输出">输出</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">int</span> a[]) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>i)
        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>)
        putchar(a[i] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>);
    putchar(<span style="color:#e6db74">&#39;\n&#39;</span>);
}
</code></pre></div><p>这样就完成了对于数据的存储与输出</p>
<h2 id="加法">加法</h2>
<p>高精度加法其实就是按照竖式加法法则来计算</p>
<p>从低位开始相加，满十则向高一位进一，本位取余</p>
<p>{% note info, 这里使用十进制，也可以使用其他更大的进制，如1000进制 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度加法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> c[]) {
    clean(c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
        c[i] <span style="color:#f92672">=</span> a[i] <span style="color:#f92672">+</span> b[i];
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {<span style="color:#75715e">//判断是否满十
</span><span style="color:#75715e"></span>            c[i] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">10</span>;
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><h2 id="减法">减法</h2>
<p>高精度减法同样也是按照竖式减法逐位相减，减不过向高一位借一。</p>
<p>因为要考虑到小数减大数的情况，所以用此函数来判断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">compare</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[]) {
    <span style="color:#66d9ef">int</span> i, j;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>i)
        <span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">--</span>j)
        <span style="color:#66d9ef">if</span> (b[j] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;

    <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> j) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> i; p <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>p) {
            <span style="color:#66d9ef">if</span> (a[p] <span style="color:#f92672">==</span> b[p])
                <span style="color:#66d9ef">continue</span>;

            <span style="color:#66d9ef">if</span> (a[p] <span style="color:#f92672">&gt;</span> b[p])
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度减法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sub</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> b, <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> c) {
    flag <span style="color:#f92672">=</span> compare(a, b);<span style="color:#75715e">//判断是否是小数减大数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (flag) {<span style="color:#75715e">//如果是
</span><span style="color:#75715e"></span>        putchar(<span style="color:#e6db74">&#39;-&#39;</span>);<span style="color:#75715e">//则输出负号
</span><span style="color:#75715e"></span>        sub(b, a, c);<span style="color:#75715e">//按照大数减小数计算
</span><span style="color:#75715e"></span>        flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span>;
    }

    clean(c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
        c[i] <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">-</span> b[i];
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
            c[i] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><h2 id="乘法">乘法</h2>
<h4 id="高精度低精度">高精度*低精度</h4>
<p>如果是高精度与低精度相乘的话，就没必要使用高精度乘法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mul</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c[]) {
    clean(c);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) {
        c[i] <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">*</span> b;<span style="color:#75715e">//每位都乘低精度
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> c[i] <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>;
            c[i] <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
        }
    }
}
</code></pre></div><h4 id="高精度高精度">高精度*高精度</h4>
<p>高精度与高精度相乘也是模拟了手写计算乘法的方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度乘法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mul</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> c[]) {
    clean(c);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">++</span>) {
        <span style="color:#75715e">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> i; j<span style="color:#f92672">++</span>) {
            c[i] <span style="color:#f92672">+=</span> a[j] <span style="color:#f92672">*</span> b[i <span style="color:#f92672">-</span> j];
        }
        
        <span style="color:#66d9ef">if</span> (c[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>) {
            c[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> c[i] <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>;
            c[i] <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
        }
    }
}
</code></pre></div><h2 id="除法">除法</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//判断长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">greater_eq</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> last_dg, <span style="color:#66d9ef">int</span> len) {
    <span style="color:#66d9ef">if</span> (a[last_dg <span style="color:#f92672">+</span> len] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
        <span style="color:#66d9ef">if</span> (a[last_dg <span style="color:#f92672">+</span> i] <span style="color:#f92672">&gt;</span> b[i])
            <span style="color:#66d9ef">return</span> true;
        <span style="color:#66d9ef">if</span> (a[last_dg <span style="color:#f92672">+</span> i] <span style="color:#f92672">&lt;</span> b[i])
            <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//高精度除法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">div</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> b[], <span style="color:#66d9ef">int</span> c[], <span style="color:#66d9ef">int</span> d[]) {
    clean(c);
    clean(d);

    <span style="color:#66d9ef">int</span> la, lb;
    <span style="color:#66d9ef">for</span> (la <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; la <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>la)
        <span style="color:#66d9ef">if</span> (a[la <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">for</span> (lb <span style="color:#f92672">=</span> LEN <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; lb <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>lb)
        <span style="color:#66d9ef">if</span> (b[lb <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">if</span> (lb <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        puts(<span style="color:#e6db74">&#34;除数为零，错误&#34;</span>);
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> la; <span style="color:#f92672">++</span>i) d[i] <span style="color:#f92672">=</span> a[i];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> la <span style="color:#f92672">-</span> lb; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
        <span style="color:#66d9ef">while</span> (greater_eq(d, b, i, lb)) {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> lb; <span style="color:#f92672">++</span>j) {
                d[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">-=</span> b[j];
                <span style="color:#66d9ef">if</span> (d[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
                    d[i <span style="color:#f92672">+</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
                    d[i <span style="color:#f92672">+</span> j] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>;
                }
            }
            c[i] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        }
    }
}
</code></pre></div><h2 id="测试">测试</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    read(a);
    read(b);

    add(a, b, c);
    print(c);

    sub(a, b, c);
    print(c);

    mul(a, b, c);
    print(c);

    div(a, b, c, d);
    print(c);
    print(d);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之并发</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Thu, 18 Mar 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</guid>
      <description>并发</description>
      <content:encoded><![CDATA[<p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发。</p>
<h3 id="并发和并行">并发和并行</h3>
<p>并发：同一时间段内执行多个任务。</p>
<p>并行：同一时刻执行多个任务。</p>
<p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于进程，属于用户态的进程。可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时调度完成，而线程是由操作系统调度完成。</p>
<p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是Go语言并成的CSP并发模式的重要实现基础。</p>
<h3 id="goroutine">goroutine</h3>
<p>Go语言中<code>goroutine</code>的概念类似于线程但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。</p>
<h4 id="goroutine的使用">goroutine的使用</h4>
<p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p>
<p>一个<code>gotoutine</code>必定对应一个函数，可以创建的多个<code>goroutine</code>去执行相同的函数。</p>
<h4 id="启动单个goroutine">启动单个goroutine</h4>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">hello</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
}
</code></pre></div><p>这个例子的输出结果是<code>Hello goroutine!</code> 和<code>main goroutine done!</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
}
</code></pre></div><p>这个例子启动了一个goroutine执行hello函数，然而结果中只打印出了<code>main goroutine done!</code>，这是为什么呢？</p>
<p>在程序启动时，Go程序为<code>main()</code>函数创建一个默认的goroutine，当<code>main()</code>函数返回的时候也就意味这main的goroutine就结束了，也就意味着程序结束，其他的goroutine也会被结束掉。接就是说在上述例子中，<code>hello()</code>还没来得及进行，程序就结束了。</p>
<p>如何才能将hello()进行呢？最简单粗暴的方式就是<code>time.Sleep</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1000</span>)
}
</code></pre></div><p>执行上面的代码会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>，这是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p>
<h4 id="启动多个goroutine">启动多个goroutine</h4>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>() <span style="color:#75715e">//goroutine结束也要登记,-1
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello goroutine&#34;</span>, <span style="color:#a6e22e">i</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>) <span style="color:#75715e">//启动一个goroutine就登记一次,+1
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>() <span style="color:#75715e">//等待所有登记的goroutine都结束
</span><span style="color:#75715e"></span>}
</code></pre></div><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p>
<h3 id="goroutine与线程">goroutine与线程</h3>
<h4 id="goroutine调度">goroutine调度</h4>
<p>GPM是Go语言运行时层面的实现，是Go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p>
<h4 id="gomaxprocs">GOMAXPROCS</h4>
<p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p>
<p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;runtime&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">a</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;A:&#34;</span>, <span style="color:#a6e22e">i</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">b</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;B:&#34;</span>, <span style="color:#a6e22e">i</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOMAXPROCS</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">a</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">b</span>()
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
}
</code></pre></div><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。将逻辑核心数设置为2，此时两个任务并行执行。</p>
<p>Go语言中的操作系统线程和goroutine的关系：</p>
<ol>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ol>
<h3 id="channel">channel</h3>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h4 id="channel类型">channel类型</h4>
<p><code>channel</code>是一种类型，一种引用类型。声明格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">变量</span> <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">元素类型</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch1</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch2</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch3</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">int</span>
</code></pre></div><h4 id="创建channel">创建channel</h4>
<p>通道是引用类型，通道类型的空值是<code>nil</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ch</span>) <span style="color:#75715e">//nil
</span></code></pre></div><p>声明的通道在<code>make</code>初始化后才能使用。</p>
<p>格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">元素类型</span>, [<span style="color:#a6e22e">大小</span>])
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
<span style="color:#a6e22e">ch3</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">int</span>)
</code></pre></div><h4 id="channel操作">channel操作</h4>
<p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p>
<p>发送和接收都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</code></pre></div><h5 id="发送">发送</h5>
<p>将一个值发送到通道中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">// 把10发送到ch中
</span></code></pre></div><h5 id="接收">接收</h5>
<p>从一个通道中接收值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span> <span style="color:#75715e">// 从ch中接收值并赋值给变量x
</span><span style="color:#75715e"></span><span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>       <span style="color:#75715e">// 从ch中接收值，忽略结果
</span></code></pre></div><h5 id="关闭">关闭</h5>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">close(<span style="color:#a6e22e">ch</span>)
</code></pre></div><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致panic。</li>
</ol>
<h4 id="无缓冲的通道">无缓冲的通道</h4>
<p>无缓冲的通道又称为阻塞的通道。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;成功&#34;</span>)
}
</code></pre></div><p>这段代码在执行时会出现错误</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">fatal error: all goroutines are asleep - deadlock!

goroutine <span style="color:#ae81ff">1</span> <span style="color:#f92672">[</span>chan send<span style="color:#f92672">]</span>:
main.main<span style="color:#f92672">()</span>
        E:/MyStudy/Programfiles/VsCode/GO/src/mytest/test.go:9 +0x5f
exit status <span style="color:#ae81ff">2</span>
</code></pre></div><p>因为<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲通道必须有接受才能发送。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁。</p>
<p>解决方法：</p>
<p>一种方法就是启用一个goroutine去接受，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rec</span>(<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;成功&#34;</span>, <span style="color:#a6e22e">ret</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">rec</span>(<span style="color:#a6e22e">ch</span>)
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;成功&#34;</span>)
}
</code></pre></div><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h4 id="有缓冲的通道">有缓冲的通道</h4>
<p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// 创建一个容量为1的有缓冲区通道
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;发送成功&#34;</span>)
}
</code></pre></div><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量。</p>
<h4 id="for-range-从通道循环取值">for range 从通道循环取值</h4>
<p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p>
<p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p>
<p>看这个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#75715e">// 开启goroutine将0~100的数发送到ch1中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
			<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
		}
		close(<span style="color:#a6e22e">ch1</span>)
	}()
	<span style="color:#75715e">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">for</span> {
			<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span> <span style="color:#75715e">// 通道关闭后再取值ok=false
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
				<span style="color:#66d9ef">break</span>
			}
			<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">i</span>
		}
		close(<span style="color:#a6e22e">ch2</span>)
	}()
	<span style="color:#75715e">// 在主goroutine中从ch2中接收值打印
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch2</span> { <span style="color:#75715e">// 通道关闭后会退出for range循环
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}

}
</code></pre></div><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p>
<h4 id="单向通道">单向通道</h4>
<p>有的时候将通道作为参数在多个任务函数间传递，很多时候我们要在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">counter</span>(<span style="color:#a6e22e">out</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">out</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
	}
	close(<span style="color:#a6e22e">out</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">squarer</span>(<span style="color:#a6e22e">out</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">in</span> {
		<span style="color:#a6e22e">out</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">i</span>
	}
	close(<span style="color:#a6e22e">out</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printer</span>(<span style="color:#a6e22e">in</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">in</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">ch2</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">counter</span>(<span style="color:#a6e22e">ch1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">squarer</span>(<span style="color:#a6e22e">ch2</span>, <span style="color:#a6e22e">ch1</span>)
	<span style="color:#a6e22e">printer</span>(<span style="color:#a6e22e">ch2</span>)
}
</code></pre></div><p>其中，</p>
<ul>
<li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li>
<li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li>
</ul>
<p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>
<h3 id="worker-pool-goroutine池">worker pool （goroutine池）</h3>
<p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">results</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">jobs</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;worker:%d start job:%d\n&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;worker:%d end job:%d\n&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">i</span>)

		<span style="color:#a6e22e">results</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">jobs</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)
	<span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)

    <span style="color:#75715e">//只开启3个goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">w</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">w</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">jobs</span>, <span style="color:#a6e22e">results</span>)
	}
	<span style="color:#75715e">//5个任务
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">jobs</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">j</span>
	}

	close(<span style="color:#a6e22e">jobs</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">a</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">a</span><span style="color:#f92672">++</span> {
		<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">results</span>
	}
}

</code></pre></div><h3 id="select多路复用">select多路复用</h3>
<p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span>{
    <span style="color:#75715e">// 尝试从ch1接收值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span>
    <span style="color:#75715e">// 尝试从ch2接收值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch2</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
}
</code></pre></div><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p>
<p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">select</span>{
    <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch1</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch2</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ch3</span><span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">data</span>:
        <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">default</span>:
        <span style="color:#a6e22e">默认操作</span>
}
</code></pre></div><p>举个例子来演示下<code>select</code>的使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>:
		}
	}
}
</code></pre></div><p>使用<code>select</code>语句能提高代码的可读性。</p>
<ul>
<li>可处理一个或多个channel的发送/接收操作。</li>
<li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li>
<li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li>
</ul>
<h3 id="并发安全和锁">并发安全和锁</h3>
<p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">50000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)
}

</code></pre></div><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>
<h4 id="互斥锁">互斥锁</h4>
<p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int64</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">50000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>() <span style="color:#75715e">//上锁
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
		<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>() <span style="color:#75715e">//解锁
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">add</span>()
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>)
}
</code></pre></div><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>
<h4 id="读写互斥锁">读写互斥锁</h4>
<p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p>
<p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>
<p>读写锁示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> (
	<span style="color:#a6e22e">x</span>      <span style="color:#66d9ef">int64</span>
	<span style="color:#a6e22e">wg</span>     <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#75715e">//lock   sync.Mutex
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">write</span>() {
	<span style="color:#75715e">// lock.Lock()   // 加互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">Lock</span>() <span style="color:#75715e">// 加写锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// 假设读操作耗时10毫秒
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">Unlock</span>()                   <span style="color:#75715e">// 解写锁
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// lock.Unlock()                     // 解互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">read</span>() {
	<span style="color:#75715e">// lock.Lock()                  // 加互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">RLock</span>()               <span style="color:#75715e">// 加读锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// 假设读操作耗时1毫秒
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rwlock</span>.<span style="color:#a6e22e">RUnlock</span>()             <span style="color:#75715e">// 解读锁
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// lock.Unlock()                // 解互斥锁
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">write</span>()
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">read</span>()
	}

	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">start</span>))
}
</code></pre></div><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p>
<h4 id="syncwaitgroup">sync.WaitGroup</h4>
<p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(wg * WaitGroup) Add(delta int)</td>
<td style="text-align:center">计数器+delta</td>
</tr>
<tr>
<td style="text-align:center">(wg *WaitGroup) Done()</td>
<td style="text-align:center">计数器-1</td>
</tr>
<tr>
<td style="text-align:center">(wg *WaitGroup) Wait()</td>
<td style="text-align:center">阻塞直到计数器变为0</td>
</tr>
</tbody>
</table>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>
<p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello Goroutine!&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hello</span>() <span style="color:#75715e">// 启动另外一个goroutine去执行hello函数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main goroutine done!&#34;</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p>
<h4 id="synconce">sync.Once</h4>
<p>说在前面的话：这是一个进阶知识点。</p>
<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p>
<p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Once</span>) <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()) {}
</code></pre></div><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p>
<h5 id="加载配置文件示例">加载配置文件示例</h5>
<p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">icons</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadIcons</span>() {
	<span style="color:#a6e22e">icons</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>{
		<span style="color:#e6db74">&#34;left&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;left.png&#34;</span>),
		<span style="color:#e6db74">&#34;up&#34;</span>:    <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;up.png&#34;</span>),
		<span style="color:#e6db74">&#34;right&#34;</span>: <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;right.png&#34;</span>),
		<span style="color:#e6db74">&#34;down&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;down.png&#34;</span>),
	}
}

<span style="color:#75715e">// Icon 被多个goroutine调用时不是并发安全的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Icon</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">icons</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">loadIcons</span>()
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">icons</span>[<span style="color:#a6e22e">name</span>]
}
</code></pre></div><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadIcons</span>() {
	<span style="color:#a6e22e">icons</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;left&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;left.png&#34;</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;up&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;up.png&#34;</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;right&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;right.png&#34;</span>)
	<span style="color:#a6e22e">icons</span>[<span style="color:#e6db74">&#34;down&#34;</span>] = <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;down.png&#34;</span>)
}
</code></pre></div><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>
<p>使用<code>sync.Once</code>改造的示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">icons</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">loadIconsOnce</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">loadIcons</span>() {
	<span style="color:#a6e22e">icons</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span>{
		<span style="color:#e6db74">&#34;left&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;left.png&#34;</span>),
		<span style="color:#e6db74">&#34;up&#34;</span>:    <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;up.png&#34;</span>),
		<span style="color:#e6db74">&#34;right&#34;</span>: <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;right.png&#34;</span>),
		<span style="color:#e6db74">&#34;down&#34;</span>:  <span style="color:#a6e22e">loadIcon</span>(<span style="color:#e6db74">&#34;down.png&#34;</span>),
	}
}

<span style="color:#75715e">// Icon 是并发安全的
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Icon</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">image</span>.<span style="color:#a6e22e">Image</span> {
	<span style="color:#a6e22e">loadIconsOnce</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">loadIcons</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">icons</span>[<span style="color:#a6e22e">name</span>]
}
</code></pre></div><h5 id="并发安全的单例模式">并发安全的单例模式</h5>
<p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">singleton</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">singleton</span> <span style="color:#66d9ef">struct</span> {}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">instance</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">singleton</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">once</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">GetInstance</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">singleton</span> {
    <span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">instance</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">singleton</span>{}
    })
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">instance</span>
}
</code></pre></div><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p>
<h4 id="syncmap">sync.Map</h4>
<p>Go语言中内置的map不是并发安全的。请看下面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>]
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
			<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;k=:%v,v:=%v\n&#34;</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>))
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p>
<p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Map</span>{}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
			<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">n</span>)
			<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">key</span>)
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;k=:%v,v:=%v\n&#34;</span>, <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>)
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}(<span style="color:#a6e22e">i</span>)
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}
</code></pre></div><h3 id="原子操作">原子操作</h3>
<p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p>
<h4 id="示例">示例</h4>
<p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
	<span style="color:#e6db74">&#34;sync/atomic&#34;</span>
	<span style="color:#e6db74">&#34;time&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Counter</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Inc</span>()
	<span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span>
}

<span style="color:#75715e">// 普通版
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CommonCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">CommonCounter</span>) <span style="color:#a6e22e">Inc</span>() {
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">CommonCounter</span>) <span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">counter</span>
}

<span style="color:#75715e">// 互斥锁版
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MutexCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int64</span>
	<span style="color:#a6e22e">lock</span>    <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MutexCounter</span>) <span style="color:#a6e22e">Inc</span>() {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MutexCounter</span>) <span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span> {
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Lock</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lock</span>.<span style="color:#a6e22e">Unlock</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">counter</span>
}

<span style="color:#75715e">// 原子操作版
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AtomicCounter</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int64</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AtomicCounter</span>) <span style="color:#a6e22e">Inc</span>() {
	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">counter</span>, <span style="color:#ae81ff">1</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">AtomicCounter</span>) <span style="color:#a6e22e">Load</span>() <span style="color:#66d9ef">int64</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">LoadInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">counter</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Counter</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Inc</span>()
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
		}()
	}
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Load</span>(), <span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">start</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">CommonCounter</span>{} <span style="color:#75715e">// 非并发安全
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">c1</span>)
	<span style="color:#a6e22e">c2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">MutexCounter</span>{} <span style="color:#75715e">// 使用互斥锁实现并发安全
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c2</span>)
	<span style="color:#a6e22e">c3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">AtomicCounter</span>{} <span style="color:#75715e">// 并发安全且比互斥锁效率更高
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c3</span>)
}
</code></pre></div><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的类型/类型实现同步更好</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之接口</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 18 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</guid>
      <description>接口</description>
      <content:encoded><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h3 id="接口类型">接口类型</h3>
<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p><code>interface</code>是一组<code>method</code>的集合，不关心属性（数据），只关心行为（方法）。</p>
<h3 id="引入">引入</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cat</span> <span style="color:#66d9ef">struct</span>{} <span style="color:#75715e">//猫
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">Say</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;喵喵喵&#34;</span> }

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span>{} <span style="color:#75715e">//狗
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">Say</span>() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;汪汪汪&#34;</span> }

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Cat</span>{}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Say</span>())

	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Say</span>())
}
</code></pre></div><p>上述代码定义了猫和狗，以及他们叫声的方法，可以发现，main中会有重复的代码，如果再加上其他动物，代码还会重复，那如果把他们都归类成“会叫的动物”来处理呢？</p>
<p>像这样类似的例子还有很多，例如：</p>
<p>支付宝、微信、银联等在线支付的方式，可以把它们当成支付方式来处理。</p>
<p>计算三角形、正方形、圆形等的周长和面积，可以把他们当成图形来处理</p>
<p>等等……</p>
<p>而在Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于所有的具体类型，接口是一种抽象的类型。当看到一个接口类型的值时，你不知道它是什么，只知道通过它的方法能做什么。</p>
<h3 id="接口的定义">接口的定义</h3>
<p>Go语言提倡面向接口编程</p>
<p>每个接口由数个方法组成，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">接口类型名</span> <span style="color:#66d9ef">interface</span>{
    <span style="color:#a6e22e">方法名1</span>( <span style="color:#a6e22e">参数列表1</span> ) <span style="color:#a6e22e">返回值列表1</span>
    <span style="color:#a6e22e">方法名2</span>( <span style="color:#a6e22e">参数列表2</span> ) <span style="color:#a6e22e">返回值列表2</span>
    <span style="color:#960050;background-color:#1e0010">…</span>
}
</code></pre></div><ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">writer</span> <span style="color:#66d9ef">interface</span>{
    <span style="color:#a6e22e">Write</span>([]<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span>
}
</code></pre></div><p>当你看到这个接口类型的值时，并不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p>
<h3 id="接口实现的条件">接口实现的条件</h3>
<p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个{% emp 需要实现的方法列表 %}</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Sayer</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Say</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cat</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">Say</span>() { <span style="color:#75715e">//Cat实现了Sayer接口
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;喵喵喵&#34;</span>) 
} 

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span>{}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">Say</span>() { <span style="color:#75715e">//Dog实现了Sayer接口
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;汪汪汪&#34;</span>) 
} 
</code></pre></div><h3 id="接口类型的变量">接口类型的变量</h3>
<p>实现了接口有什么作用呢？</p>
<p>接口类型变量能够储存所有实现了该接口的实例。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Sayer</span>

	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Cat</span>{}
	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Dog</span>{}

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">Say</span>()

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">d</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">Say</span>()
}
</code></pre></div><h3 id="值接收者和指针接收者实现接口的区别">值接收者和指针接收者实现接口的区别</h3>
<p>定义一个<code>Mover</code>接口和一个<code>Dog</code>结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span>{}
</code></pre></div><p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;狗跑了&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wangcai</span> = <span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">wangcai</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fugui</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">fugui</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
}
</code></pre></div><p>从上面这段代码不难发现，使用值接收者实现接口之后，不管是Dog结构体还是*Dog结构体指针类型的变量都可以赋值给该接口变量。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>同样的代码，如果使用指针接受实现接口呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;狗跑了&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wangcai</span> = <span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">wangcai</span> <span style="color:#75715e">//x不可以接收Dog类型
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fugui</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Dog</span>{}
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">fugui</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
}
</code></pre></div><p>此时实现<code>Mover</code>接口的是<code>*Dog</code>类型，所以不能给<code>x</code>传入<code>Dog</code>类型。</p>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="类型与接口的关系">类型与接口的关系</h3>
<h4 id="一个类型实现多个接口">一个类型实现多个接口</h4>
<p>一个类型可以同时实现多个接口，而接口之间批次独立。例如，狗可以叫，也可以跑。就可以分别定义Sayer接口和Mover接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Sayer</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">say</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">say</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s说\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s跑了\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#a6e22e">Sayer</span>

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">Dog</span>{<span style="color:#e6db74">&#34;旺财&#34;</span>}

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">a</span>

	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
	<span style="color:#a6e22e">y</span>.<span style="color:#a6e22e">say</span>()
}
</code></pre></div><h4 id="多个类型实现同一接口">多个类型实现同一接口</h4>
<p>Go语言中不同的类型还可以实现同一接口，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s跑了\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Car</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Car</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s跑了\n&#34;</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">Mover</span>

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> = <span style="color:#a6e22e">Dog</span>{<span style="color:#e6db74">&#34;旺财&#34;</span>}
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">Car</span>{<span style="color:#e6db74">&#34;保时捷&#34;</span>}

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">d</span>
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()

	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">c</span>
	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">move</span>()
    <span style="color:#75715e">//不关心具体是什么，只需调用方法即可
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="接口嵌套">接口嵌套</h3>
<p>接口与接口之间可以通过嵌套创造出新的接口</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//Sayer接口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Sayer</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">say</span>()
}

<span style="color:#75715e">//Mover接口
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Mover</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">move</span>()
}

<span style="color:#75715e">//接口嵌套
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">animal</span> <span style="color:#66d9ef">interface</span>{
	<span style="color:#a6e22e">Sayer</span>
	<span style="color:#a6e22e">Mover</span>
}
</code></pre></div><p>嵌套得到的接口的使用与普通接口一样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Cat</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">say</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;喵喵喵&#34;</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Cat</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;猫跑了&#34;</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#a6e22e">animal</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">Cat</span>{<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;臭宝&#34;</span>}

	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">move</span>()
	<span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">say</span>()
}
</code></pre></div><h3 id="空接口">空接口</h3>
<h4 id="空接口的定义">空接口的定义</h4>
<p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{}

	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">s</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)

	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">i</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)

	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">true</span>
	<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">b</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">x</span>)
}
</code></pre></div><h4 id="空接口的应用">空接口的应用</h4>
<p>{% tabs tab-2 %}</p>
<!-- raw HTML omitted -->
<p>使用空接口实现可以接受任意类型的函数参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">show</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{}) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T %v\n&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">a</span>)
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>使用空接口实现可以保存任意值的字典。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">studentInfo</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
	<span style="color:#a6e22e">studentInfo</span>[<span style="color:#e6db74">&#34;name&#34;</span>] = <span style="color:#e6db74">&#34;臭宝&#34;</span>
	<span style="color:#a6e22e">studentInfo</span>[<span style="color:#e6db74">&#34;age&#34;</span>] = <span style="color:#ae81ff">18</span>
	<span style="color:#a6e22e">studentInfo</span>[<span style="color:#e6db74">&#34;married&#34;</span>] = <span style="color:#66d9ef">false</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">studentInfo</span>)
	<span style="color:#75715e">//map[age:18 married:false name:臭宝]
</span><span style="color:#75715e"></span>}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="类型断言">类型断言</h3>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之结构体（二）</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/</link>
      <pubDate>Wed, 17 Mar 2021 20:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/</guid>
      <description>结构体</description>
      <content:encoded><![CDATA[<p>在（一）中介绍了结构体的基本用法，（二）中将介绍结构体更多的用法。</p>
<h3 id="构造函数">构造函数</h3>
<p>在C++面向对象中，声明一个对象后，可以写一些针对该对象的一些方法，例如构造函数等。Go语言中的结构体没有构造函数，可以自己实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">//构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Student</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">student</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{ <span style="color:#75715e">//struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">name</span>,
		<span style="color:#a6e22e">age</span>,
		<span style="color:#a6e22e">id</span>,
		<span style="color:#a6e22e">score</span>,
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#75715e">//&amp;main.student{name:&#34;小学生&#34;, age:7, id:&#34;666&#34;, score:60}
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="方法和接收者">方法和接收者</h3>
<p>Go语言中的<code>方法(Method)</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者(Receiver)</code>。接收者的概念类似于C++中的<code>this</code>。</p>
<p>定义格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">接收者变量</span> <span style="color:#a6e22e">接收者类型</span>) <span style="color:#a6e22e">方法名</span>(<span style="color:#a6e22e">参数列表</span>) (<span style="color:#a6e22e">返回参数</span>) {
    <span style="color:#a6e22e">函数体</span>
}
</code></pre></div><ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>this</code>之类的命名。例如，student类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">//构造函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Student</span>(<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">student</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{ <span style="color:#75715e">//struct是值类型，如果结构体比较复杂，值拷贝开销较大，所以返回结构体指针类型
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">name</span>,
		<span style="color:#a6e22e">age</span>,
		<span style="color:#a6e22e">id</span>,
		<span style="color:#a6e22e">score</span>,
	}
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">student</span>) <span style="color:#a6e22e">study</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;我要好好学习！\n&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">study</span>()
}
</code></pre></div><p>方法和函数的区别就是函数不属于任何类型，方法只属于特定的类型</p>
<p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<p>指针类型的接收者由一个结构的指针组成，由于指针的特性，调用方法时可以修改接收者指针的任何成员变量，在方法结束后，修改依然有效。这种方法类似于C++中使用<code>this</code>。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">student</span>) <span style="color:#a6e22e">setAge</span>(<span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#a6e22e">age</span>
}
</code></pre></div><p>这是一个修改student的age 的方法</p>
<p>调用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//7
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">setAge</span>(<span style="color:#ae81ff">18</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//18
</span><span style="color:#75715e"></span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>与指针类型的接收者对比，调用方法时，拿到的是值类型接收者的值的拷贝份。在值类型接收者的方法中可以获取接收者的成员值，但修改成员变量指针对这个副本，无法修改接收者变量本身。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">student</span>) <span style="color:#a6e22e">setAge</span>(<span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#a6e22e">age</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>(<span style="color:#e6db74">&#34;小学生&#34;</span>, <span style="color:#ae81ff">7</span>, <span style="color:#e6db74">&#34;666&#34;</span>, <span style="color:#ae81ff">60</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//7
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">setAge</span>(<span style="color:#ae81ff">18</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>) <span style="color:#75715e">//7
</span><span style="color:#75715e"></span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ol>
<li>需要修改接收者的成员值</li>
<li>接收者是比较复杂的结构体，拷贝开销大</li>
</ol>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="任意类型添加方法">任意类型添加方法</h3>
<p>Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。例如，基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为这个自定义类型添加方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">MyInt</span>) <span style="color:#a6e22e">SayHello</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello, I&#39;m SatHello&#34;</span>) <span style="color:#75715e">//Hello, I&#39;m SatHello
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">MyInt</span>
	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">SayHello</span>()
	<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v %T\n&#34;</span>, <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span>) <span style="color:#75715e">//100 main.MyInt
</span><span style="color:#75715e"></span>}
</code></pre></div><p>注意：只可以给本包的类型定义方法</p>
<h3 id="结构体的匿名字段">结构体的匿名字段</h3>
<p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段称为匿名字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#66d9ef">string</span>
	<span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{
		<span style="color:#e6db74">&#34;小学生&#34;</span>,
		<span style="color:#ae81ff">7</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">s</span>) <span style="color:#75715e">//&amp;main.student{string:&#34;小学生&#34;, int:7}
</span><span style="color:#75715e"></span>}
</code></pre></div><p>匿名字段的说法并不代表没有字段名，而是默认采用类型名作为字段名。从其定义中不难发现，</p>
<p>由于结构体要求字段名必须唯一，因此一个结构体中一种类型的匿名字段只能有一个。</p>
<h3 id="嵌套结构体">嵌套结构体</h3>
<p>一个结构体中可以嵌套包含另一个结构体或结构体指针，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#75715e">//成绩信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">grade</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">math</span>    <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">chinese</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">english</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">//学生信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">mygrade</span> <span style="color:#a6e22e">grade</span>
    <span style="color:#75715e">//grade
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//↑可采用匿名字段的方式嵌套
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{
		<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;小学生&#34;</span>,
		<span style="color:#a6e22e">age</span>:  <span style="color:#ae81ff">7</span>,
		<span style="color:#a6e22e">mygrade</span>: <span style="color:#a6e22e">grade</span>{
			<span style="color:#a6e22e">math</span>:    <span style="color:#ae81ff">60</span>,
			<span style="color:#a6e22e">chinese</span>: <span style="color:#ae81ff">60</span>,
			<span style="color:#a6e22e">english</span>: <span style="color:#ae81ff">60</span>,
		},
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#75715e">//&amp;main.student{name:&#34;小学生&#34;, age:7, mygrade:main.grade{math:60, chinese:60, english:60}}
</span><span style="color:#75715e"></span>}

</code></pre></div><h3 id="结构体的继承">结构体的“继承”</h3>
<p>Go语言中使用结构体也可以实现C++中面向对象的继承。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Animal</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#a6e22e">Animal</span>) <span style="color:#a6e22e">move</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s会动\n&#34;</span>, <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">age</span>     <span style="color:#66d9ef">int</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">Animal</span> <span style="color:#75715e">//通过嵌套匿名结构体实现继承
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Dog</span>) <span style="color:#a6e22e">wang</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s汪汪汪的叫\n&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">name</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Dog</span>{
		<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">4</span>,
		<span style="color:#a6e22e">Animal</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Animal</span>{
			<span style="color:#a6e22e">name</span>: <span style="color:#e6db74">&#34;小明&#34;</span>,
		},
	}
	<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">move</span>()
	<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">wang</span>()
}

</code></pre></div><h3 id="结构体字段的可见性">结构体字段的可见性</h3>
<p>结构体中字段大写开头表示可公开访问，小写代表私有（仅在定义当前结构体的包中可访问）</p>
<p>{% note warning, 区别私有概念 %}</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之结构体（一）</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80/</link>
      <pubDate>Wed, 17 Mar 2021 18:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%80/</guid>
      <description>结构体</description>
      <content:encoded><![CDATA[<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<h2 id="自定义类型和类型别名">自定义类型和类型别名</h2>
<p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以像C/C++一样使用<code>type</code>关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//将MyInt定义为int类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> <span style="color:#66d9ef">int</span>
</code></pre></div><p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>类型别名规定：MyType只是Type的别名，本质上MyType与Type是同一个类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyType</span> = <span style="color:#a6e22e">Type</span>
</code></pre></div><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">byte</span> = <span style="color:#66d9ef">uint8</span>
<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">rune</span> = <span style="color:#66d9ef">int32</span>
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>自定义类型和类型别名在语法上看似只有一个等号的差别，但其实不然，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//自定义类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">NewInt</span> <span style="color:#66d9ef">int</span>

<span style="color:#75715e">//类型别名
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyInt</span> = <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">NewInt</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#a6e22e">MyInt</span>
   	
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">a</span>) <span style="color:#75715e">//main.NewInt
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T&#34;</span>, <span style="color:#a6e22e">b</span>) <span style="color:#75715e">//int
</span><span style="color:#75715e"></span>}
</code></pre></div><p>输出结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的``NewInt<code>类型；b的类型是</code>int`。</p>
<p><code>MyInt</code>类型在编译完成时，会被替换成int</p>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h2 id="结构体">结构体</h2>
<p>Go语言中结构体的定义与C/C++中类似。</p>
<p>我们想表达一个事物的全部或部分属性时，这时用单一的基本数据类型无法满足需求，Go语言提供了自定义数据类型，可以封装多个基本数据类型，这就是结构体。</p>
<p>通过<code>struct</code>来定义，同时在Go语言中，也通过<code>struct</code>实现面向对象</p>
<h3 id="结构体的定义">结构体的定义</h3>
<p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyType</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">Name1</span> <span style="color:#a6e22e">Type1</span>
	<span style="color:#a6e22e">Name2</span> <span style="color:#a6e22e">Type2</span>
	<span style="color:#f92672">...</span>
}
</code></pre></div><ul>
<li>MyType：自定义类型的名称，同一个包中不可重复</li>
<li>Name1和Name2：结构体中成员名称，同一结构体中不可重复</li>
<li>Type1和Type2：成员的具体类型</li>
</ul>
<p>例如，定义一个学生的结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}
</code></pre></div><p>这样，使用student结构体就可以很方便在代码中表示和储存信息了</p>
<p>Go语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>
<h3 id="结构体实例化">结构体实例化</h3>
<p>只有结构体实例化后，才会对相应的变量分配内存。结构体实例化与声明内置类型一样，使用<code>var</code>关键字声明变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">student1</span> <span style="color:#a6e22e">student</span>
</code></pre></div><p>{% tabs tab-2 %}</p>
<!-- raw HTML omitted -->
<p>通过<code>.</code>访问结构体的成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stu</span> <span style="color:#a6e22e">student</span> <span style="color:#75715e">//声明结构体变量
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">//赋值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span>
	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">id</span> = <span style="color:#e6db74">&#34;666&#34;</span>
	<span style="color:#a6e22e">stu</span>.<span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">60</span>

	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)

}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">666</span> <span style="color:#ae81ff">60</span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>在定义一些临时数据结构等场景下，可以使命匿名结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span> {
		<span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
		<span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
	}
	<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span>
	<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">Age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">user</span>)
}

</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Go语言中还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> = new(<span style="color:#a6e22e">student</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span> <span style="color:#75715e">//Go语言中支持对结构体指针直接使用.来访问结构体成员
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">id</span> = <span style="color:#e6db74">&#34;666&#34;</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">60</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">*</span><span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">student</span>
<span style="color:#f92672">&amp;</span>{ <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>}
<span style="color:#f92672">&amp;</span>{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">666</span> <span style="color:#ae81ff">60</span>}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>使用<code>&amp;</code>对结构体进行取址操作相当于对该结构体进行了依次<code>new</code>实例化操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">student</span>{}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T\n&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;小学生&#34;</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">7</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">id</span> = <span style="color:#e6db74">&#34;666&#34;</span>
	<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">score</span> = <span style="color:#ae81ff">60</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}

</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">*</span><span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">student</span>
<span style="color:#f92672">&amp;</span>{ <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>}
<span style="color:#f92672">&amp;</span>{<span style="color:#a6e22e">小学生</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">666</span> <span style="color:#ae81ff">60</span>}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="结构体初始化">结构体初始化</h3>
<p>没有初始化的结构体，其成员变量都是对应类型的零值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">student</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">name</span>  <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">age</span>   <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">id</span>    <span style="color:#66d9ef">string</span>
	<span style="color:#a6e22e">score</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stu</span> <span style="color:#a6e22e">student</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v\n&#34;</span>, <span style="color:#a6e22e">stu</span>)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">student</span>{<span style="color:#a6e22e">name</span>:<span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">age</span>:<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">id</span>:<span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">score</span>:<span style="color:#ae81ff">0</span>}
</code></pre></div><p>{% tabs tab-3 %}</p>
<!-- raw HTML omitted -->
<p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#a6e22e">name</span>:  <span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#a6e22e">age</span>:   <span style="color:#ae81ff">7</span>,
	<span style="color:#a6e22e">id</span>:    <span style="color:#e6db74">&#34;666&#34;</span>,
	<span style="color:#a6e22e">score</span>: <span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//{小学生 7 666 60}
</span></code></pre></div><p>也可以对结构体指针进行键值对初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#a6e22e">name</span>:  <span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#a6e22e">age</span>:   <span style="color:#ae81ff">7</span>,
	<span style="color:#a6e22e">id</span>:    <span style="color:#e6db74">&#34;666&#34;</span>,
	<span style="color:#a6e22e">score</span>: <span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//&amp;{小学生 7 666 60}
</span></code></pre></div><p>当某些字段没有初始值时，该字段可以不写。此时，没有指定初始值的字段的值时该字段类型的零值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#a6e22e">name</span>:  <span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#a6e22e">score</span>: <span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%#v&#34;</span>, <span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//main.student{name:&#34;小学生&#34;, age:0, id:&#34;&#34;, score:60}
</span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>初始话结构体时可以简写，也就是初始化时不写键，直接写值即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">stu</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">student</span>{
	<span style="color:#e6db74">&#34;小学生&#34;</span>,
	<span style="color:#ae81ff">7</span>,
	<span style="color:#e6db74">&#34;666&#34;</span>,
	<span style="color:#ae81ff">60</span>,
}

<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stu</span>)<span style="color:#75715e">//{小学生 7 666 60}
</span></code></pre></div><p>使用这种格式要注意：</p>
<ul>
<li>必须初始化结构体的所有字段</li>
<li>顺序必须一致</li>
<li>不可与简直初始化混用</li>
</ul>
<!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="结构体内存布局">结构体内存布局</h3>
<p>结构体占用一块连续的内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int8</span>
	<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int8</span>
	<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int8</span>
	<span style="color:#a6e22e">d</span> <span style="color:#66d9ef">int8</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>{
		<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.a %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">a</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.b %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">b</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.c %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">c</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;n.d %p\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">d</span>)
}
</code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">a</span> <span style="color:#ae81ff">0xc000012090</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">b</span> <span style="color:#ae81ff">0xc000012091</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">c</span> <span style="color:#ae81ff">0xc000012092</span>
<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">d</span> <span style="color:#ae81ff">0xc000012093</span>
</code></pre></div><h4 id="空结构体">空结构体</h4>
<p>空结构体不占用空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">struct</span>{}
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">t</span>)) <span style="color:#75715e">// 0
</span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之指针</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 17 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</guid>
      <description>Go指针</description>
      <content:encoded><![CDATA[<p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<h2 id="go语言中的指针">Go语言中的指针</h2>
<p>Go语言中的指针与C/C++中指针有一定的区别，Go语言中的指针不能进行偏移和运算，是安全指针。因此，Go语言中的指针操作比较简单，只需要记住两个符号<code>&amp;</code>（取址）和<code>*</code>（取值）</p>
<h3 id="指针地址和指针类型">指针地址和指针类型</h3>
<p>每个变量在运行都有一个地址，这个地址也就代表变量在内存中的位置。Go语言中使用<code>&amp;</code>对变量进行取地址。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span> <span style="color:#75715e">//定义整型变量a
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#ae81ff">10</span><span style="color:#75715e">//p为整型类型的指针类型，其中保存的是变量a的地址
</span></code></pre></div><p>在Go语言中，每个值类型都有对应的指针类型。</p>
<h3 id="指针取值">指针取值</h3>
<p>在对变量使用<code>&amp;</code>取地址后，可以使用<code>*</code>对接收了地址的指针变量进行取值，有一个很简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>{% folding green, 输出结果 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#ae81ff">10</span>
</code></pre></div><p>{% endfolding %}</p>
<h3 id="指针传值示例">指针传值示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {
	<span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">20</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">myfunc</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
}
</code></pre></div><p>{% folding blue, 输出结果 %}</p>
<pre tabindex="0"><code>20
</code></pre><p>{% endfolding %}</p>
<h2 id="new--make">new &amp; make</h2>
<p>先分析一个经典的例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
	<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">b</span>[<span style="color:#e6db74">&#34;哈哈哈&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>执行这段代码，其实是会报错的。</p>
<ol>
<li>在声明了整型的指针类型a之后，系统并没有给变量分配内存空间</li>
<li>在声明了map类型的b之后，同样，系统并没有给其分配内存空间</li>
</ol>
<p>Go语言中对于值类型的声明，在声明的时候就默认分配了内存空间。然而对于引用类型，在使用的时候不仅要声明它，还要给它分配内存空间，否则无法储存。</p>
<p>所以就要使用Go语言中new和make来分配内存</p>
<h3 id="new">new</h3>
<p><code>new</code>是一个内置的函数，语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">Type</span>)
<span style="color:#75715e">//name 变量名
</span><span style="color:#75715e">//Type 指针变量指向的变量的类型
</span></code></pre></div><p>举例说明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> new(<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#66d9ef">bool</span>)
    
    <span style="color:#75715e">//使用new函数后得到的是一个指针变量，且该指针对应的值为该类型的零值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)
}
</code></pre></div><p>在上述开始的经典例子中，<code>var a *int</code>只是声明了指针变量a，但是并未初始化，指针作为引用类型需要初始化才会有内存空间，才可对其进行赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">a</span> = new(<span style="color:#66d9ef">int</span>)
    <span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">100</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)
}
</code></pre></div><h3 id="make">make</h3>
<p>make也用于内存分配，区别于new，只用于slice(切片)，map以及chan(通道)的内存创建，而不是他们的指针类型，因为这三种类型本来就是引用类型。</p>
<p>语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">Type1</span>]<span style="color:#a6e22e">Type2</span>, <span style="color:#a6e22e">Size</span>)
</code></pre></div><p>make函数是无可替代的，在使用slice，map以及chan时，都需要使用make初始化。</p>
<p>在上述开始的经典例子中，<code>var b map[string]int</code>只是声明了b是一个map类型的变量，并未初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">b</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
    <span style="color:#a6e22e">b</span>[<span style="color:#e6db74">&#34;哈哈哈&#34;</span>] = <span style="color:#ae81ff">10</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)
}
</code></pre></div><h3 id="new和make的异同">new和make的异同</h3>
<ol>
<li>new和make都是用来做内存分配的</li>
<li>make只用于slice，map，channel的初始化</li>
<li>new用于指针类型的分配，而且内存对应的值为类型零值</li>
</ol>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之函数</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 16 Mar 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</guid>
      <description>函数</description>
      <content:encoded><![CDATA[<p>函数是基本的代码块，用于执行一个任务。</p>
<p>Go 语言至少要有个 main() 函数。</p>
<p>本文将介绍Go语言中函数的相关内容。</p>
<h2 id="函数">函数</h2>
<p>Go语言中支持函数、匿名函数、闭包。</p>
<h3 id="函数定义">函数定义</h3>
<p>Go语言中定义函数使用关键字<code>func</code>，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">函数名</span>(<span style="color:#a6e22e">参数1</span>,<span style="color:#a6e22e">参数2</span>)(<span style="color:#a6e22e">返回值1</span>,<span style="color:#a6e22e">返回值2</span>){
    <span style="color:#a6e22e">函数体</span>
}
</code></pre></div><ul>
<li>函数名：命名规则与变量相同</li>
<li>参数：参数由参数变量和参数变量类型组成</li>
<li>返回值：返回值由返回值变量和返回值类型组成，也可以只写返回值的类型。Go语言支持多个返回值，须用<code>()</code>包裹。</li>
</ul>
<p>具体用以下例子说明：</p>
<p>{% tabs tab-1 %}</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mysum</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myhello</span>(){
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello Boy!&#34;</span>)
}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="函数调用">函数调用</h3>
<p>在定义了函数之后，可以通过<code>函数名()</code>的方式对函数进行调用。</p>
<p>例如调用上述定义的两个函数，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">myhello</span>();
    <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret</span>)
}
</code></pre></div><h3 id="参数">参数</h3>
<p>{% tabs tab-2 %}</p>
<!-- raw HTML omitted -->
<p>函数中的参数如果相邻变量的类型相同，则可以省略类型，只留一个，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mysum</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>可变参数是指函数的参数数量不固定，Go语言中的可变参数通过在参数名后加<code>...</code>来表示。</p>
<p>{% note warning, 可变参数通常要作为函数的最后一个参数 %}</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mysum2</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span>) <span style="color:#75715e">//x是一个切片
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">x</span>{
        <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}


<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">ret1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum2</span>()
    <span style="color:#a6e22e">ret2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum2</span>(<span style="color:#ae81ff">10</span>)
    <span style="color:#a6e22e">ret3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mysum3</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret1</span>,<span style="color:#a6e22e">ret2</span>,<span style="color:#a6e22e">ret3</span>)
}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="返回值">返回值</h3>
<p>Go语言中通过关键字<code>return</code>返回</p>
<p>{% tabs tab-3 %}</p>
<!-- raw HTML omitted -->
<p>Go语言中函数支持多个返回值，函数如果有多个返回值时，必须用<code>()</code>将返回值括起来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>){
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
    <span style="color:#a6e22e">sub</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>,<span style="color:#a6e22e">sub</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">sum</span>, <span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
	<span style="color:#a6e22e">sub</span> = <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// 没必要返回[]int{}
</span><span style="color:#75715e"></span>	}
	<span style="color:#f92672">...</span>
}
</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h2 id="函数进阶">函数进阶</h2>
<h3 id="函数类型和变量">函数类型和变量</h3>
<p>使用<code>type</code>关键字来定义一个函数类型，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mytype</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>
</code></pre></div><p>上面的语句定义了一个<code>mytype</code>类型，一种函数类型，且这种函数接受两个int类型的参数并且返回一个int类型的返回值。简单点来说，凡是满足这个条件的函数都是mytype类型的函数，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sub</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mytype</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">mytype</span>
	<span style="color:#a6e22e">c</span> = <span style="color:#a6e22e">add</span>              <span style="color:#75715e">//将函数add赋值给变量c
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)) <span style="color:#75715e">// 可以像add一样调用c
</span><span style="color:#75715e"></span>}

</code></pre></div><h3 id="高阶函数">高阶函数</h3>
<h4 id="函数作为参数">函数作为参数</h4>
<p>Go语言中，函数可以作为参数。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">canshu</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">canshu</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ret1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">add</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret1</span>)
}
</code></pre></div><p>也可以使用定义函数类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mytype</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">canshu</span> <span style="color:#a6e22e">mytype</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">canshu</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ret1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">add</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret1</span>)
}

</code></pre></div><h4 id="函数作为返回值">函数作为返回值</h4>
<p>Go语言中，函数可以作为返回值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//待补充
</span></code></pre></div><h3 id="匿名函数和闭包">匿名函数和闭包</h3>
<h4 id="匿名函数">匿名函数</h4>
<p>Go语言中函数内部定义函数与之前有所不同，只能定义匿名函数。匿名函数就是没有函数名的函数，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">参数</span>)(<span style="color:#a6e22e">返回值</span>){
    <span style="color:#a6e22e">函数体</span>
}
</code></pre></div><p>匿名函数因为没有函数名，没办法想普通函数一样被调用，所以匿名函数需要保存到某个变量或者立即执行该函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">add</span> <span style="color:#f92672">:=</span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>){<span style="color:#75715e">//将匿名函数保存到变量中
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>)
    }
    <span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>)<span style="color:#75715e">//通过变量调用匿名函数
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">//自执行函数，匿名函数定义完加()直接执行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>){
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>)
    }(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>)
}
</code></pre></div><h4 id="闭包">闭包</h4>
<p>闭包指的是一个函数和其相关的引用环境组合而成的实体。简单点说，<code>闭包 = 函数 + 引用环境</code>。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adder</span>() <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">y</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">adder</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e">//10
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">20</span>)) <span style="color:#75715e">//30
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">30</span>)) <span style="color:#75715e">//60
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">adder</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">40</span>)) <span style="color:#75715e">//40
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">50</span>)) <span style="color:#75715e">//90
</span><span style="color:#75715e"></span>}
</code></pre></div><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中<code>x</code>变量，此时<code>f</code>是一个闭包。在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p>
<h5 id="闭包进阶示例">闭包进阶示例</h5>
<p>{% tabs tab-4 %}</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">adder2</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">y</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>
	}
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> = <span style="color:#a6e22e">adder2</span>(<span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">10</span>)) <span style="color:#75715e">//20
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">20</span>)) <span style="color:#75715e">//40
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f</span>(<span style="color:#ae81ff">30</span>)) <span style="color:#75715e">//70
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">adder2</span>(<span style="color:#ae81ff">20</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">40</span>)) <span style="color:#75715e">//60
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">50</span>)) <span style="color:#75715e">//110
</span><span style="color:#75715e"></span>}

</code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#a6e22e">base</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">add</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">base</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">base</span>
	}

	<span style="color:#a6e22e">sub</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
		<span style="color:#a6e22e">base</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">i</span>
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">base</span>
	}

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">add</span>, <span style="color:#a6e22e">sub</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">f1</span>, <span style="color:#a6e22e">f2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">myfunc</span>(<span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">1</span>), <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">2</span>)) <span style="color:#75715e">//11 9
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">3</span>), <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">4</span>)) <span style="color:#75715e">//12 8
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">f1</span>(<span style="color:#ae81ff">5</span>), <span style="color:#a6e22e">f2</span>(<span style="color:#ae81ff">6</span>)) <span style="color:#75715e">//13 7
</span><span style="color:#75715e"></span>}

</code></pre></div><!-- raw HTML omitted -->
<p>{% endtabs %}</p>
<h3 id="defer语句">defer语句</h3>
<p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句最先被执行，和C语言中栈的顺序一样</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;start&#34;</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">3</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;end&#34;</span>)
}
</code></pre></div><p>运行结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">start
end
<span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">1</span>
</code></pre></div><p>利用<code>defer</code>语句延迟调用的特性，可以很方便的处理资源释放的问题</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之map</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</link>
      <pubDate>Tue, 16 Mar 2021 18:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</guid>
      <description>Map</description>
      <content:encoded><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p>
<h1 id="map">map</h1>
<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h2 id="map定义">map定义</h2>
<p>Go语言中 <code>map</code>的定义语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">KeyType</span>]<span style="color:#a6e22e">ValueType</span>
</code></pre></div><p>其中，</p>
<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">make(<span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">KeyType</span>]<span style="color:#a6e22e">ValueType</span>, [<span style="color:#a6e22e">cap</span>])
</code></pre></div><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<h2 id="map基本使用">map基本使用</h2>
<p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">8</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">scoreMap</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>])
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of a:%T\n&#34;</span>, <span style="color:#a6e22e">scoreMap</span>)
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">map<span style="color:#f92672">[</span>小明:100 张三:90<span style="color:#f92672">]</span>
<span style="color:#ae81ff">100</span>
type of a:map<span style="color:#f92672">[</span>string<span style="color:#f92672">]</span>int
</code></pre></div><p>map也支持在声明的时候填充元素，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">userInfo</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>{
		<span style="color:#e6db74">&#34;username&#34;</span>: <span style="color:#e6db74">&#34;沙河小王子&#34;</span>,
		<span style="color:#e6db74">&#34;password&#34;</span>: <span style="color:#e6db74">&#34;123456&#34;</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">userInfo</span>) <span style="color:#75715e">//
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="判断某个键是否存在">判断某个键是否存在</h2>
<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#a6e22e">key</span>]
</code></pre></div><p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#75715e">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>]
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;查无此人&#34;</span>)
	}
}
</code></pre></div><h2 id="map的遍历">map的遍历</h2>
<p>Go语言中使用<code>for range</code>遍历map。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;娜扎&#34;</span>] = <span style="color:#ae81ff">60</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
	}
}
</code></pre></div><p>但我们只想遍历key的时候，可以按下面的写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;娜扎&#34;</span>] = <span style="color:#ae81ff">60</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>)
	}
}
</code></pre></div><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h2 id="使用delete函数删除键值对">使用delete()函数删除键值对</h2>
<p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">delete(<span style="color:#66d9ef">map</span>, <span style="color:#a6e22e">key</span>)
</code></pre></div><p>其中，</p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<p>示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#a6e22e">scoreMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;张三&#34;</span>] = <span style="color:#ae81ff">90</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;小明&#34;</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">scoreMap</span>[<span style="color:#e6db74">&#34;娜扎&#34;</span>] = <span style="color:#ae81ff">60</span>
	delete(<span style="color:#a6e22e">scoreMap</span>, <span style="color:#e6db74">&#34;小明&#34;</span>)<span style="color:#75715e">//将小明:100从map中删除
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span>{
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
	}
}
</code></pre></div><h2 id="按照指定顺序遍历map">按照指定顺序遍历map</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Seed</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">UnixNano</span>()) <span style="color:#75715e">//初始化随机数种子
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">scoreMap</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">200</span>)

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;stu%02d&#34;</span>, <span style="color:#a6e22e">i</span>) <span style="color:#75715e">//生成stu开头的字符串
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Intn</span>(<span style="color:#ae81ff">100</span>)          <span style="color:#75715e">//生成0~99的随机整数
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">scoreMap</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
	}
	<span style="color:#75715e">//取出map中的所有key存入切片keys
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">keys</span> = make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">200</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">scoreMap</span> {
		<span style="color:#a6e22e">keys</span> = append(<span style="color:#a6e22e">keys</span>, <span style="color:#a6e22e">key</span>)
	}
	<span style="color:#75715e">//对切片进行排序
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Strings</span>(<span style="color:#a6e22e">keys</span>)
	<span style="color:#75715e">//按照排序后的key遍历map
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">keys</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">scoreMap</span>[<span style="color:#a6e22e">key</span>])
	}
}
</code></pre></div><h2 id="元素为map类型的切片">元素为map类型的切片</h2>
<p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mapSlice</span> = make([]<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">3</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">mapSlice</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;index:%d value:%v\n&#34;</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;after init&#34;</span>)
	<span style="color:#75715e">// 对切片中的map元素进行初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>] = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#34;name&#34;</span>] = <span style="color:#e6db74">&#34;小王子&#34;</span>
	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#34;password&#34;</span>] = <span style="color:#e6db74">&#34;123456&#34;</span>
	<span style="color:#a6e22e">mapSlice</span>[<span style="color:#ae81ff">0</span>][<span style="color:#e6db74">&#34;address&#34;</span>] = <span style="color:#e6db74">&#34;沙河&#34;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">mapSlice</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;index:%d value:%v\n&#34;</span>, <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><h2 id="值为切片类型的map">值为切片类型的map</h2>
<p>下面的代码演示了map中值为切片类型的操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sliceMap</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">3</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sliceMap</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;after init&#34;</span>)
	<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;中国&#34;</span>
	<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sliceMap</span>[<span style="color:#a6e22e">key</span>]
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">value</span> = make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
	}
	<span style="color:#a6e22e">value</span> = append(<span style="color:#a6e22e">value</span>, <span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>)
	<span style="color:#a6e22e">sliceMap</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">value</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sliceMap</span>)
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之切片</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</link>
      <pubDate>Tue, 16 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</guid>
      <description>Go切片</description>
      <content:encoded><![CDATA[<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p>
<h2 id="引入">引入</h2>
<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">arraySum</span>(<span style="color:#a6e22e">x</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>{
    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">x</span>{
        <span style="color:#a6e22e">sum</span> = <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">v</span>
    }
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sum</span>
}
</code></pre></div><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</code></pre></div><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了，这样就难受的一批。而切片可以很好的解决这个问题</p>
<h2 id="切片">切片</h2>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<h3 id="切片的定义">切片的定义</h3>
<p>声明切片类型的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> []<span style="color:#a6e22e">T</span>
</code></pre></div><ul>
<li>name:表示变量名</li>
<li>T:表示切片中的元素类型</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// 声明切片类型
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">string</span>              <span style="color:#75715e">//声明一个字符串切片
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> = []<span style="color:#66d9ef">int</span>{}             <span style="color:#75715e">//声明一个整型切片并初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> = []<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>} <span style="color:#75715e">//声明一个布尔切片并初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> = []<span style="color:#66d9ef">bool</span>{<span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">true</span>} <span style="color:#75715e">//声明一个布尔切片并初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)              <span style="color:#75715e">//[]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)              <span style="color:#75715e">//[]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>)              <span style="color:#75715e">//[false true]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)       <span style="color:#75715e">//true
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)       <span style="color:#75715e">//false
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)       <span style="color:#75715e">//false
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="切片的长度和容量">切片的长度和容量</h3>
<p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p>
<h3 id="切片表达式">切片表达式</h3>
<h4 id="简单切片表达式">简单切片表达式</h4>
<p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// s := a[low:high]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s:%v len(s):%v cap(s):%v\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
}
</code></pre></div><p>输入结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">s:<span style="color:#f92672">[</span><span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:4
</code></pre></div><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>:]  <span style="color:#75715e">// 等同于 a[2:len(a)]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// 等同于 a[0:3]
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>[:]   <span style="color:#75715e">// 等同于 a[0:len(a)]
</span></code></pre></div><p>{% span red, 注意： %}</p>
<p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p>
<p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// s := a[low:high]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s:%v len(s):%v cap(s):%v\n&#34;</span>, <span style="color:#a6e22e">s</span>, len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">4</span>]  <span style="color:#75715e">// 索引的上限是cap(s)而不是len(s)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;s2:%v len(s2):%v cap(s2):%v\n&#34;</span>, <span style="color:#a6e22e">s2</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>))
}
</code></pre></div><p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">s:<span style="color:#f92672">[</span><span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>:4
s2:<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>s2<span style="color:#f92672">)</span>:1 cap<span style="color:#f92672">(</span>s2<span style="color:#f92672">)</span>:1
</code></pre></div><h4 id="完整切片表达式">完整切片表达式</h4>
<p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">low</span> : <span style="color:#a6e22e">high</span> : <span style="color:#a6e22e">max</span>]
</code></pre></div><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">5</span>]
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;t:%v len(t):%v cap(t):%v\n&#34;</span>, <span style="color:#a6e22e">t</span>, len(<span style="color:#a6e22e">t</span>), cap(<span style="color:#a6e22e">t</span>))
}
</code></pre></div><p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">t:<span style="color:#f92672">[</span><span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span> len<span style="color:#f92672">(</span>t<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>t<span style="color:#f92672">)</span>:4
</code></pre></div><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p>
<h3 id="使用make函数构造切片">使用make()函数构造切片</h3>
<p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">make<span style="color:#f92672">([]</span>T, size, cap<span style="color:#f92672">)</span>
</code></pre></div><p>其中：</p>
<ul>
<li>T:切片的元素类型</li>
<li>size:切片中元素的数量</li>
<li>cap:切片的容量</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)      <span style="color:#75715e">//[0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">a</span>)) <span style="color:#75715e">//2
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(cap(<span style="color:#a6e22e">a</span>)) <span style="color:#75715e">//10
</span><span style="color:#75715e"></span>}
</code></pre></div><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p>
<h3 id="切片的本质">切片的本质</h3>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p>
<ul>
<li>多个切片指向同一数组时，对任一切片进行操作时，都有可能对其他切片造成影响</li>
</ul>
<h3 id="切片不能直接比较">切片不能直接比较</h3>
<p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> []<span style="color:#66d9ef">int</span>         <span style="color:#75715e">//len(s1)=0;cap(s1)=0;s1==nil
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}        <span style="color:#75715e">//len(s2)=0;cap(s2)=0;s2!=nil
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">//len(s3)=0;cap(s3)=0;s3!=nil
</span></code></pre></div><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<h3 id="切片的赋值拷贝">切片的赋值拷贝</h3>
<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">//[0 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s1</span>             <span style="color:#75715e">//将s1直接赋值给s2，s1和s2共用一个底层数组
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>) <span style="color:#75715e">//[100 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s2</span>) <span style="color:#75715e">//[100 0 0]
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="切片遍历">切片遍历</h3>
<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>])
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><h3 id="append方法为切片添加元素">append()方法为切片添加元素</h3>
<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>)        <span style="color:#75715e">// [1]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)  <span style="color:#75715e">// [1 2 3 4]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>}  
	<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">s2</span><span style="color:#f92672">...</span>)    <span style="color:#75715e">// [1 2 3 4 5 6 7]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>**注意：**通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</code></pre></div><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}  <span style="color:#75715e">// 没有必要初始化
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> = make([]<span style="color:#66d9ef">int</span>)  <span style="color:#75715e">// 没有必要初始化
</span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</code></pre></div><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">//append()添加元素和切片扩容
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numSlice</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">numSlice</span> = append(<span style="color:#a6e22e">numSlice</span>, <span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v  len:%d  cap:%d  ptr:%p\n&#34;</span>, <span style="color:#a6e22e">numSlice</span>, len(<span style="color:#a6e22e">numSlice</span>), cap(<span style="color:#a6e22e">numSlice</span>), <span style="color:#a6e22e">numSlice</span>)
	}
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>  len:1  cap:1  ptr:0xc0000a8000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> 1<span style="color:#f92672">]</span>  len:2  cap:2  ptr:0xc0000a8040
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> 2<span style="color:#f92672">]</span>  len:3  cap:4  ptr:0xc0000b2020
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span>  len:4  cap:4  ptr:0xc0000b2020
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>  len:5  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> 5<span style="color:#f92672">]</span>  len:6  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> 6<span style="color:#f92672">]</span>  len:7  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> 7<span style="color:#f92672">]</span>  len:8  cap:8  ptr:0xc0000b6000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> 8<span style="color:#f92672">]</span>  len:9  cap:16  ptr:0xc0000b8000
<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span>  len:10  cap:16  ptr:0xc0000b8000
</code></pre></div><p>从上面的结果可以看出：</p>
<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li>
</ol>
<p>append()函数还支持一次性追加多个元素。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">citySlice</span> []<span style="color:#66d9ef">string</span>
<span style="color:#75715e">// 追加一个元素
</span><span style="color:#75715e"></span><span style="color:#a6e22e">citySlice</span> = append(<span style="color:#a6e22e">citySlice</span>, <span style="color:#e6db74">&#34;北京&#34;</span>)
<span style="color:#75715e">// 追加多个元素
</span><span style="color:#75715e"></span><span style="color:#a6e22e">citySlice</span> = append(<span style="color:#a6e22e">citySlice</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>)
<span style="color:#75715e">// 追加切片
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>}
<span style="color:#a6e22e">citySlice</span> = append(<span style="color:#a6e22e">citySlice</span>, <span style="color:#a6e22e">a</span><span style="color:#f92672">...</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">citySlice</span>) <span style="color:#75715e">//[北京 上海 广州 深圳 成都 重庆]
</span></code></pre></div><h3 id="使用copy函数复制切片">使用copy()函数复制切片</h3>
<p>首先我们来看一个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1000</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1000 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">//[1000 2 3 4 5]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p>
<p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">copy<span style="color:#f92672">(</span>destSlice, srcSlice <span style="color:#f92672">[]</span>T<span style="color:#f92672">)</span>
</code></pre></div><p>其中：</p>
<ul>
<li>srcSlice: 数据来源切片</li>
<li>destSlice: 目标切片</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// copy()复制切片
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>)
	copy(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">a</span>)     <span style="color:#75715e">//使用copy()函数将切片a中的元素复制到切片c
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1000</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[1 2 3 4 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>) <span style="color:#75715e">//[1000 2 3 4 5]
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="从切片中删除元素">从切片中删除元素</h3>
<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#75715e">// 从切片中删除元素
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">37</span>}
	<span style="color:#75715e">// 要删除索引为2的元素
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span> = append(<span style="color:#a6e22e">a</span>[:<span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">3</span>:]<span style="color:#f92672">...</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[30 31 33 34 35 36 37]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之数组</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 15 Mar 2021 18:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</guid>
      <description>Go数组</description>
      <content:encoded><![CDATA[<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p>
<h1 id="array数组">Array(数组)</h1>
<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 定义一个长度为3元素类型为int的数组a
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
</code></pre></div><h3 id="数组定义">数组定义：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">var 数组变量名 <span style="color:#f92672">[</span>元素数量<span style="color:#f92672">]</span>T
</code></pre></div><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>
<span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">b</span> <span style="color:#75715e">//不可以这样做，因为此时a和b是不同的类型
</span></code></pre></div><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<h3 id="数组的初始化">数组的初始化</h3>
<p>数组的初始化也有很多方式。</p>
<h4 id="方法一">方法一</h4>
<p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testArray</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>                        <span style="color:#75715e">//数组会初始化为int类型的零值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numArray</span> = [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}                 <span style="color:#75715e">//使用指定的初始值完成初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cityArray</span> = [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>} <span style="color:#75715e">//使用指定的初始值完成初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">testArray</span>)                      <span style="color:#75715e">//[0 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">numArray</span>)                       <span style="color:#75715e">//[1 2 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cityArray</span>)                      <span style="color:#75715e">//[北京 上海 深圳]
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="方法二">方法二</h4>
<p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">testArray</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numArray</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cityArray</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">testArray</span>)                          <span style="color:#75715e">//[0 0 0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">numArray</span>)                           <span style="color:#75715e">//[1 2]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of numArray:%T\n&#34;</span>, <span style="color:#a6e22e">numArray</span>)   <span style="color:#75715e">//type of numArray:[2]int
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cityArray</span>)                          <span style="color:#75715e">//[北京 上海 深圳]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of cityArray:%T\n&#34;</span>, <span style="color:#a6e22e">cityArray</span>) <span style="color:#75715e">//type of cityArray:[3]string
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="方法三">方法三</h4>
<p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>: <span style="color:#ae81ff">5</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)                  <span style="color:#75715e">// [0 1 0 5]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;type of a:%T\n&#34;</span>, <span style="color:#a6e22e">a</span>) <span style="color:#75715e">//type of a:[4]int
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="数组的遍历">数组的遍历</h3>
<p>遍历数组a有以下两种方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>}
	<span style="color:#75715e">// 方法1：for循环遍历
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">a</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>])
	}

	<span style="color:#75715e">// 方法2：for range遍历
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
	}
}
</code></pre></div><h3 id="多维数组">多维数组</h3>
<p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p>
<h3 id="二维数组的定义">二维数组的定义</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>{
		{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
		{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
		{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[[北京 上海] [广州 深圳] [成都 重庆]]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">1</span>]) <span style="color:#75715e">//支持索引取值:重庆
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="二维数组的遍历">二维数组的遍历</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>{
		{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
		{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
		{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v2</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">v1</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s\t&#34;</span>, <span style="color:#a6e22e">v2</span>)
		}
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	}
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">北京	上海	
广州	深圳	
成都	重庆	
</code></pre></div><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//支持的写法
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">string</span>{
	{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
	{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
	{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
}
<span style="color:#75715e">//不支持多维数组的内层使用...
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#f92672">...</span>]<span style="color:#66d9ef">string</span>{
	{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>},
	{<span style="color:#e6db74">&#34;广州&#34;</span>, <span style="color:#e6db74">&#34;深圳&#34;</span>},
	{<span style="color:#e6db74">&#34;成都&#34;</span>, <span style="color:#e6db74">&#34;重庆&#34;</span>},
}
</code></pre></div><h3 id="数组是值类型">数组是值类型</h3>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">modifyArray</span>(<span style="color:#a6e22e">x</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">modifyArray2</span>(<span style="color:#a6e22e">x</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>}
	<span style="color:#a6e22e">modifyArray</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//在modify中修改的是a的副本x
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">//[10 20 30]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>{
		{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>},
		{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>},
		{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>},
	}
	<span style="color:#a6e22e">modifyArray2</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">//在modify中修改的是b的副本x
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>)  <span style="color:#75715e">//[[1 1] [1 1] [1 1]]
</span><span style="color:#75715e"></span>}
</code></pre></div><p><strong>注意：</strong></p>
<ol>
<li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li>
<li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li>
</ol>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之流程控制</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 15 Mar 2021 16:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制</description>
      <content:encoded><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分。</p>
<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<h4 id="if-else-分支结构">if else (分支结构)</h4>
<h5 id="if条件判断基本写法">if条件判断基本写法</h5>
<p>Go语言中if条件判断的格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">表达式1</span> {
    <span style="color:#a6e22e">分支1</span>
} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">表达式2</span> {
    <span style="color:#a6e22e">分支2</span>
} <span style="color:#66d9ef">else</span>{
    <span style="color:#a6e22e">分支3</span>
}
</code></pre></div><p>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if和表达式</code>放在同一行，<code>{</code>放在其他位置会触发编译错误。 同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>() {
	<span style="color:#a6e22e">score</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">65</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">90</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;A&#34;</span>)
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">85</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;B&#34;</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;C&#34;</span>)
	}
}
</code></pre></div><h5 id="if条件判断特殊写法">if条件判断特殊写法</h5>
<p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc</span>() {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">65</span>; <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">90</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;A&#34;</span>)
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">score</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">85</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;B&#34;</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;C&#34;</span>)
	}
}
</code></pre></div><p><strong>两种写法有什么不同呢？</strong></p>
<h4 id="for-循环结构">for (循环结构)</h4>
<p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p>
<p>for循环的基本格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">初始语句</span>;<span style="color:#a6e22e">条件表达式</span>;<span style="color:#a6e22e">结束语句</span>{
    <span style="color:#a6e22e">循环体语句</span>
}
</code></pre></div><p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc1</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}
</code></pre></div><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc2</span>() {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
	}
}
</code></pre></div><p>for循环的初始语句和结束语句都可以省略，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">myfunc3</span>() {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>
	}
}
</code></pre></div><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<p>{% noteblock, 无限循环 %}</p>
<p>{% folding yellow, Folding 点击打开 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> {
    <span style="color:#a6e22e">循环体语句</span>
}
</code></pre></div><p>{% endfolding %}</p>
<p>for循环可以通过break、goto、return、panic语句强制退出循环。</p>
<p>{% endnoteblock %}</p>
<h4 id="for-range键值循环">for range(键值循环)</h4>
<p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h4 id="switch-case">switch case</h4>
<p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">switch1</span>() {
	<span style="color:#a6e22e">finger</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">finger</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;大拇指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;食指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;中指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;无名指&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;小拇指&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;无效的输入！&#34;</span>)
	}
}
</code></pre></div><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>
<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Switch2</span>() {
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">7</span>; <span style="color:#a6e22e">n</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;奇数&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;偶数&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span>)
	}
}
</code></pre></div><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">switch3</span>() {
	<span style="color:#a6e22e">age</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">30</span>
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">age</span> &lt; <span style="color:#ae81ff">25</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;好好学习！&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">age</span> &gt; <span style="color:#ae81ff">25</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">age</span> &lt; <span style="color:#ae81ff">35</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;好好工作！&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">age</span> &gt; <span style="color:#ae81ff">60</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;好好享受！&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;长命百岁！&#34;</span>)
	}
}
</code></pre></div><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">switch4</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;a&#34;</span>
	<span style="color:#66d9ef">switch</span> {
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;a&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a&#34;</span>)
		<span style="color:#66d9ef">fallthrough</span>
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;b&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;b&#34;</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;c&#34;</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;c&#34;</span>)
	<span style="color:#66d9ef">default</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;...&#34;</span>)
	}
}
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">a
b
</code></pre></div><p>{% note warning, 注意Go与C中switch的区别 %}</p>
<h4 id="goto跳转到指定标签">goto(跳转到指定标签)</h4>
<p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goto1</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">breakFlag</span> <span style="color:#66d9ef">bool</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#75715e">// 设置退出标签
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">breakFlag</span> = <span style="color:#66d9ef">true</span>
				<span style="color:#66d9ef">break</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
		<span style="color:#75715e">// 外层for循环判断
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">breakFlag</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
}
</code></pre></div><p>使用<code>goto</code>语句能简化代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goto2</span>() {
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#75715e">// 设置退出标签
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">breakTag</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
	}
	<span style="color:#66d9ef">return</span>
	<span style="color:#75715e">// 标签
</span><span style="color:#75715e"></span><span style="color:#a6e22e">breakTag</span>:
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;结束for循环&#34;</span>)
}
</code></pre></div><h4 id="break跳出循环">break(跳出循环)</h4>
<p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>
<p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">break1</span>() {
<span style="color:#a6e22e">BREAKDEMO1</span>:
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">BREAKDEMO1</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;...&#34;</span>)
}
</code></pre></div><h4 id="continue继续下次循环">continue(继续下次循环)</h4>
<p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>
<p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">continue1</span>() {
<span style="color:#a6e22e">forloop1</span>:
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#75715e">// forloop2:
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
				<span style="color:#66d9ef">continue</span> <span style="color:#a6e22e">forloop1</span>
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v-%v\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>)
		}
	}
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之运算符</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 15 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Go运算符</description>
      <content:encoded><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p>
<p>Go 语言内置的运算符有五类：</p>
<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>
<h4 id="算数运算符">算数运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">相加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">相减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">相乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">相除</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">求余</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
<h4 id="关系运算符">关系运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody>
</table>
<h4 id="逻辑运算符">逻辑运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody>
</table>
<h4 id="位运算符">位运算符</h4>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td style="text-align:center">&laquo;</td>
<td style="text-align:center">左移n位就是乘以2的n次方。 “a&laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td style="text-align:center">&raquo;</td>
<td style="text-align:center">右移n位就是除以2的n次方。 “a&raquo;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody>
</table>
<h4 id="赋值运算符">赋值运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">相加后再赋值</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">相减后再赋值</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">相乘后再赋值</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">相除后再赋值</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">求余后再赋值</td>
</tr>
<tr>
<td style="text-align:center">&laquo;=</td>
<td style="text-align:center">左移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&raquo;=</td>
<td style="text-align:center">右移后赋值</td>
</tr>
<tr>
<td style="text-align:center">&amp;=</td>
<td style="text-align:center">按位与后赋值</td>
</tr>
<tr>
<td style="text-align:center">|=</td>
<td style="text-align:center">按位或后赋值</td>
</tr>
<tr>
<td style="text-align:center">^=</td>
<td style="text-align:center">按位异或后赋值</td>
</tr>
</tbody>
</table>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之基本数据类型</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 14 Mar 2021 15:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型</description>
      <content:encoded><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>
<h3 id="基本数据类型">基本数据类型</h3>
<h4 id="整型">整型</h4>
<p>整数分为以下两个大类：</p>
<p>按长度分为：int8，int16，int64</p>
<p>对应的无符号整型：uint16，uint32，uint64</p>
<p>其中，<code>uint8</code>就是我们熟知的<code>byte</code>型，<code>int16</code>对应C语言中的<code>short</code>型，<code>int64</code>对应C语言中的<code>long</code>型。</p>
<h5 id="特殊整型">特殊整型</h5>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uint</td>
<td style="text-align:center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td style="text-align:center">uintptr</td>
<td style="text-align:center">无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<h4 id="浮点型">浮点型</h4>
<p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。 <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</p>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
        <span style="color:#e6db74">&#34;fmt&#34;</span>
        <span style="color:#e6db74">&#34;math&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%f\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>)
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%.2f\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pi</span>)
}
</code></pre></div><h4 id="复数">复数</h4>
<p><code>complex64</code>和<code>complex128</code></p>
<p>具体用法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c1</span> <span style="color:#66d9ef">complex64</span>
<span style="color:#a6e22e">c1</span> = <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2i</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c2</span> <span style="color:#66d9ef">complex128</span>
<span style="color:#a6e22e">c2</span> = <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3i</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c2</span>)
</code></pre></div><h4 id="布尔值">布尔值</h4>
<p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true（真）</code>和<code>false（假）</code>两个值。</p>
<p><strong>注意：</strong></p>
<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<h4 id="字符串">字符串</h4>
<p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为<code>双引号(&quot;)</code>中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;hello&#34;</span>
<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;你好&#34;</span>
</code></pre></div><h5 id="转义字符">转义字符</h5>
<table>
<thead>
<tr>
<th style="text-align:center"><code>\r</code></th>
<th style="text-align:center">回车符（返回行首）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表符</td>
</tr>
<tr>
<td style="text-align:center"><code>\'</code></td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\&quot;</code></td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">反斜杠</td>
</tr>
</tbody>
</table>
<p>例如，我们要打印Windows平台的文件路径</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;str := \&#34;c:\\Code\\lesson1\\go.exe\&#34;&#34;</span>)
}
</code></pre></div><h5 id="多行字符串">多行字符串</h5>
<p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">`第一行
</span><span style="color:#e6db74">第二行
</span><span style="color:#e6db74">第三行
</span><span style="color:#e6db74">`</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>)
</code></pre></div><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<h5 id="字符串的常用操作">字符串的常用操作</h5>
<table>
<thead>
<tr>
<th style="text-align:center">len(str)</th>
<th style="text-align:center">求长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+ 或 fmt.Sprintf</td>
<td style="text-align:center">拼接字符串</td>
</tr>
<tr>
<td style="text-align:center">strings.Split</td>
<td style="text-align:center">分割</td>
</tr>
<tr>
<td style="text-align:center">strings.contains</td>
<td style="text-align:center">判断是否包含</td>
</tr>
<tr>
<td style="text-align:center">strings.HasPrefix,strings.HasSuffix</td>
<td style="text-align:center">前缀/后缀判断</td>
</tr>
<tr>
<td style="text-align:center">strings.Index(),strings.LastIndex()</td>
<td style="text-align:center">子串出现的位置</td>
</tr>
</tbody>
</table>
<h5 id="byte和rune类型">byte和rune类型</h5>
<p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（'）包裹起来，如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#39;中&#39;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#39;x&#39;</span>
</code></pre></div><p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>uint8</code>类型，或者叫 byte 型，代表了<code>ASCII码</code>的一个字符。</li>
<li><code>rune</code>类型，代表一个 <code>UTF-8字符</code>。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
<p>如下，可以知道rune和byte的区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 遍历字符串
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traversalString</span>() {
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;GO你好&#34;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">//byte
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v(%c) &#34;</span>, <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>])
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> { <span style="color:#75715e">//rune
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v(%c) &#34;</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">r</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
}
</code></pre></div><p>这是我们的输出结果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">71</span>(<span style="color:#a6e22e">G</span>) <span style="color:#ae81ff">79</span>(<span style="color:#a6e22e">O</span>) <span style="color:#ae81ff">228</span>(<span style="color:#a6e22e">ä</span>) <span style="color:#ae81ff">189</span>(<span style="color:#960050;background-color:#1e0010">½</span>) <span style="color:#ae81ff">160</span>( ) <span style="color:#ae81ff">229</span>(<span style="color:#a6e22e">å</span>) <span style="color:#ae81ff">165</span>(<span style="color:#960050;background-color:#1e0010">¥</span>) <span style="color:#ae81ff">189</span>(<span style="color:#960050;background-color:#1e0010">½</span>) 
<span style="color:#ae81ff">71</span>(<span style="color:#a6e22e">G</span>) <span style="color:#ae81ff">79</span>(<span style="color:#a6e22e">O</span>) <span style="color:#ae81ff">20320</span>(<span style="color:#a6e22e">你</span>) <span style="color:#ae81ff">22909</span>(<span style="color:#a6e22e">好</span>) 
</code></pre></div><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<p>字符串底层是一个byte数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p>
<h5 id="修改字符串">修改字符串</h5>
<p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">changeString</span>() {
	<span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;big&#34;</span>
	<span style="color:#75715e">// 强制类型转换
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">byteS1</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">s1</span>)
	<span style="color:#a6e22e">byteS1</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;p&#39;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">byteS1</span>))

	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;白萝卜&#34;</span>
	<span style="color:#a6e22e">runeS2</span> <span style="color:#f92672">:=</span> []rune(<span style="color:#a6e22e">s2</span>)
	<span style="color:#a6e22e">runeS2</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#39;红&#39;</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">runeS2</span>))
}
</code></pre></div><h4 id="类型转化">类型转化</h4>
<p>强制类型转换的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">T<span style="color:#f92672">(</span>表达式<span style="color:#f92672">)</span>
</code></pre></div><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为<code>float64</code>类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sqrtDemo</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> = <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>
	<span style="color:#75715e">// math.Sqrt()接收的参数是float64类型，需要强制转换
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span> = int(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(float64(<span style="color:#a6e22e">a</span><span style="color:#f92672">*</span><span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span><span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>)
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言基础之变量与常量</title>
      <link>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Sat, 13 Mar 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/golang/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</guid>
      <description>常量与变量</description>
      <content:encoded><![CDATA[<p>变量和常量是编程中必不可少的部分，也是很好理解的一部分。</p>
<h3 id="标识符与关键字">标识符与关键字</h3>
<h4 id="标识符">标识符</h4>
<p>关于Go语言中的命名规则，与C类似。Go语言中标识符由字母、数字和<code>_</code>(下划线)组成，并且只能以字母和<code>_</code>开头。
例如<code>aaa</code>,<code>_ </code>,<code>_123</code>,<code>a123</code></p>
<h4 id="关键字">关键字</h4>
<p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。且不能将关键字和保留字作为变量名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//25个关键字
</span><span style="color:#75715e"></span><span style="color:#66d9ef">break</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">func</span> <span style="color:#66d9ef">interface</span> <span style="color:#66d9ef">select</span>
<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">map</span> <span style="color:#66d9ef">struct</span> 
<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">continue</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">fallthrough</span>
<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">goto</span> <span style="color:#f92672">package</span> <span style="color:#66d9ef">range</span> 
<span style="color:#f92672">import</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">switch</span> <span style="color:#66d9ef">type</span> <span style="color:#66d9ef">var</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//37个保留字
</span><span style="color:#75715e"></span><span style="color:#a6e22e">Constants</span>: <span style="color:#66d9ef">true</span> <span style="color:#66d9ef">false</span> <span style="color:#66d9ef">iota</span> <span style="color:#66d9ef">nil</span>

<span style="color:#a6e22e">Types</span>: <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">int8</span> <span style="color:#66d9ef">int16</span> <span style="color:#66d9ef">int32</span> <span style="color:#66d9ef">int64</span> <span style="color:#66d9ef">uint</span> <span style="color:#66d9ef">uint8</span> <span style="color:#66d9ef">uint16</span> <span style="color:#66d9ef">uint32</span> <span style="color:#66d9ef">uint64</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#66d9ef">float32</span> <span style="color:#66d9ef">float64</span> <span style="color:#66d9ef">complex128</span> <span style="color:#66d9ef">complex64</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">byte</span> <span style="color:#66d9ef">rune</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">error</span> <span style="color:#a6e22e">Functions</span>: <span style="color:#a6e22e">make</span> <span style="color:#a6e22e">len</span> <span style="color:#a6e22e">cap</span> <span style="color:#a6e22e">new</span> <span style="color:#a6e22e">append</span> <span style="color:#a6e22e">copy</span> <span style="color:#a6e22e">close</span> <span style="color:#a6e22e">delete</span> <span style="color:#a6e22e">complex</span> <span style="color:#a6e22e">real</span> <span style="color:#a6e22e">imag</span> <span style="color:#a6e22e">panic</span> <span style="color:#a6e22e">recover</span>
</code></pre></div><h3 id="变量">变量</h3>
<h4 id="变量类型">变量类型</h4>
<p>变量的功能是存储数据，不同类型的变量存储不同类型的数据。</p>
<p>常见变量的数据类型有：整型、浮点型、布尔型等。</p>
<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h4 id="变量声明">变量声明</h4>
<p>Go语言声明变量的格式为:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">变量名</span> <span style="color:#a6e22e">变量类型</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">isOK</span> <span style="color:#66d9ef">bool</span>
</code></pre></div><p>当然，在Go语言中，可以批量声明变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span>(
    <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">bool</span>
    <span style="color:#a6e22e">d</span> <span style="color:#66d9ef">float32</span>
)
</code></pre></div><h4 id="变量初始化">变量初始化</h4>
<p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为<code>0</code>。 字符串变量的默认值为<code>空字符串</code>。 布尔型变量默认为<code>false</code>。 切片、函数、指针变量的默认为<code>nil</code>。</p>
<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">变量名</span> <span style="color:#a6e22e">类型</span> = <span style="color:#a6e22e">值</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span> = <span style="color:#e6db74">&#34;Q1mi&#34;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">18</span>
</code></pre></div><p>同样，也支持多个变量初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">age</span> = <span style="color:#e6db74">&#34;Q1mi&#34;</span>, <span style="color:#ae81ff">20</span>
</code></pre></div><p>{% note info, 类型推导 %}</p>
<p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;Q1mi&#34;</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">age</span> = <span style="color:#ae81ff">18</span>
</code></pre></div><p>{% note info, 短变量声明 %}</p>
<p>在函数内部，可以使用更简略的<code>:=</code>方式声明并初始化变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#75715e">// 全局变量m
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">100</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10</span>
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">200</span> <span style="color:#75715e">// 此处声明局部变量m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">n</span>)
}
</code></pre></div><p>{% note info, 匿名变量 %}
在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量</code>。 匿名变量用一个下划线<code>_</code>表示。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;hahaha&#34;</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>()
	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x=&#34;</span>, <span style="color:#a6e22e">x</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;y=&#34;</span>, <span style="color:#a6e22e">y</span>)
}
</code></pre></div><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<p>注意事项：</p>
<ul>
<li>函数外的每个语句都必须以关键字开始（var、const、func等）</li>
<li>:=不能使用在函数外。</li>
<li>_多用于占位，表示忽略值。</li>
</ul>
<h3 id="常量">常量</h3>
<p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>ar</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">pi</span> = <span style="color:#ae81ff">3.1415</span>
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">e</span> = <span style="color:#ae81ff">2.7182</span>
</code></pre></div><p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>
<p>多个常量也可以一起声明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> (
    <span style="color:#a6e22e">pi</span> = <span style="color:#ae81ff">3.1415</span>
    <span style="color:#a6e22e">e</span> = <span style="color:#ae81ff">2.7182</span>
)
</code></pre></div><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">const</span> (
    <span style="color:#a6e22e">n1</span> = <span style="color:#ae81ff">100</span>
    <span style="color:#a6e22e">n2</span>
    <span style="color:#a6e22e">n3</span>
)
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>快速幂</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Wed, 10 Mar 2021 20:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>简单介绍了一下快速幂</description>
      <content:encoded><![CDATA[<h2 id="引入">引入</h2>
<p>例题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1097">hdu1097</a></p>
<p>这道题如果使用暴力法，数据过大时候会超时或者变量存不下那么大的数，所以需要考虑其他方法</p>
<p>{% folding green, 点击展开 %}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power){
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> power; i<span style="color:#f92672">++</span>){
        ans <span style="color:#f92672">*=</span>base;
    }
    <span style="color:#66d9ef">return</span> ans <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div><p>{%endfolding%}</p>
<p>那么，考虑到个位数的改变只与个位数有关，如果每次只计算个位数呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power){
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    base <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> power; i<span style="color:#f92672">++</span>){
        ans <span style="color:#f92672">*=</span> base;
        <span style="color:#66d9ef">if</span>(ans <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">9</span>)
            ans <span style="color:#f92672">%=</span> <span style="color:#ae81ff">10</span>;
    }
    <span style="color:#66d9ef">return</span> ans;
}
</code></pre></div><p>结果同样，如果数据过大，还是会超时。</p>
<h2 id="快速幂">快速幂</h2>
<p>{% folding green, 取模的运算法则 %}</p>
<p>$(a+b) mod M = (amodM + bmodM)modM$</p>
<p>$(a-b)modM = (amodM - bmodM)modM$</p>
<p>$(a*b)modM = (amodM * bmodM)modM$</p>
<p>{% endfolding %}</p>
<hr>
<h4 id="入门">入门</h4>
<p>快速幂算法可以高效快速的算出$a^n$。</p>
<p>下面举一个例子</p>
<p>如果计算$2^{10}$</p>
<p>$2^{10}$ = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2</p>
<p>尽量将指数变小，如下</p>
<p>$2^{10} = (2*2)^5 = 4^5$</p>
<p>此时指数由10缩减一半变成了5，而底数变成了原来的平方，原本要执行十次的乘法操作，现在只需要进行五次。对于高次幂的计算来说，效果更佳。</p>
<p>那么，现在的问题是如何将5次方也变成原来的一半，5的一半是2.5，但指数不能是小数，所以式子就变成了这样</p>
<p>$2^{10} = 4^4*4^1$</p>
<p>将$4^1$单独拿出来，那$4^4$就能够继续执行上面的操作：</p>
<p>$2^{10} = 16^2*4^1$</p>
<p>将指数再次缩小一半</p>
<p>$2^{10} = 256^1*4^1$</p>
<p>此时256和4的指数都是1、奇数，无法再次缩小：所以发现了一个规律，<strong>得到的结果是变化过程中所有指数为奇数时的底数的乘积</strong></p>
<h4 id="初步实现">初步实现</h4>
<p>用代码实现上面的算法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power) {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (power) {
        <span style="color:#66d9ef">if</span> (power <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>) {
            power <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
            result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
            power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
            base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        } <span style="color:#66d9ef">else</span> {
            power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
            base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        }
    }
    <span style="color:#66d9ef">return</span> result <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div><h4 id="优化">优化</h4>
<p>1.由于if、else中有重复语句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
</code></pre></div><p>2.且在整形运算中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">-=</span><span style="color:#ae81ff">1</span>;
power <span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
</code></pre></div><p>可以压缩成下面一句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
</code></pre></div><hr>
<p>于是代码就可以压缩成以下这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power) {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (power) {
        <span style="color:#66d9ef">if</span> (power <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>)
            result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        power <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>;
        base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
    }
    <span style="color:#66d9ef">return</span> result <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div><h4 id="再次优化">再次优化</h4>
<p>在C/C++中可以利用更快位运算来代替一些计算，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
power <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//位运算
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">power <span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
power <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//位运算
</span></code></pre></div><p>于是代码就变成了这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">fastPower</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> base, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> power) {
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (power) {
        <span style="color:#66d9ef">if</span> (power <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)
            result <span style="color:#f92672">=</span> result <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
        power <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
        base <span style="color:#f92672">=</span> base <span style="color:#f92672">*</span> base <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
    }

    <span style="color:#66d9ef">return</span> result <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>STL</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/stl/</link>
      <pubDate>Thu, 04 Feb 2021 16:01:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/stl/</guid>
      <description>简单介绍了一下STL</description>
      <content:encoded><![CDATA[<p>STL是一个C++模板库，里面包含算法（algorithms）、容器（containers）、函数（functions）、迭代器（iterator）</p>
<h3 id="容器">容器</h3>
<p>使用容器时要在头文件中引入</p>
<h4 id="序列式容器">序列式容器</h4>
<p><strong>序列的元素的位置是由进入容器的时间和地点决定的</strong></p>
<h5 id="vector">vector</h5>
<p>vector简单点说就是一个动态数组，vector实现动态增长，当插入新元素的时候，如果空间不足，那么vector会重新申请更大的一块内存空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintVector</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> v) {
    <span style="color:#66d9ef">for</span> (vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> v.begin(); it <span style="color:#f92672">!=</span> v.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }

    cout <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1;  <span style="color:#75715e">//默认构造
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>};
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v2(arr, arr <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v3(v2.begin(), v2.end());
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v4(v3);

    PrintVector(v2);
    PrintVector(v3);
    PrintVector(v4);
}

<span style="color:#75715e">//常用赋值操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>};
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1(arr, arr <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));

    <span style="color:#75715e">//成员方法
</span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v2;
    v2.assign(v1.begin(), v1.end());

    <span style="color:#75715e">//重载=
</span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v3;
    v3 <span style="color:#f92672">=</span> v2;

    <span style="color:#66d9ef">int</span> arr1[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">300</span>, <span style="color:#ae81ff">400</span>};
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v4(arr1, arr1 <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(arr1) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));

    PrintVector(v1);
    PrintVector(v2);
    PrintVector(v3);
    PrintVector(v4);

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;---------------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#75715e">//交换
</span><span style="color:#75715e"></span>    v4.swap(v1);
    PrintVector(v1);
    PrintVector(v2);
    PrintVector(v3);
    PrintVector(v4);
}

<span style="color:#75715e">//大小操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test03</span>() {
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">300</span>, <span style="color:#ae81ff">400</span>};
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1(arr, arr <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v1.size() <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">if</span> (v1.empty()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;空&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;不空&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    PrintVector(v1);
    v1.resize(<span style="color:#ae81ff">2</span>);
    PrintVector(v1);
    v1.resize(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e">//不写默认零
</span><span style="color:#75715e"></span>    PrintVector(v1);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; i<span style="color:#f92672">++</span>) {
        v1.push_back(i);
    }

    cout <span style="color:#f92672">&lt;&lt;</span> v1.size() <span style="color:#f92672">&lt;&lt;</span> endl;      <span style="color:#75715e">//长度、大小
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> v1.capacity() <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">//容量
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//vector存取数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test04</span>() {
    <span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">300</span>, <span style="color:#ae81ff">400</span>};
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1(arr, arr <span style="color:#f92672">+</span> <span style="color:#66d9ef">sizeof</span>(arr) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v1.size(); i<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> v1[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-----------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> v1.size(); i<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> v1.at(i) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;front: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v1.front() <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">//第一个元素
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;back: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v1.back() <span style="color:#f92672">&lt;&lt;</span> endl;    <span style="color:#75715e">//最后一个元素
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//插入和删除
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test05</span>() {
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
    v.push_back(<span style="color:#ae81ff">10</span>);
    v.push_back(<span style="color:#ae81ff">20</span>);

    <span style="color:#75715e">//头插法
</span><span style="color:#75715e"></span>    v.insert(v.begin(), <span style="color:#ae81ff">30</span>);

    <span style="color:#75715e">//尾插法
</span><span style="color:#75715e"></span>    v.insert(v.end(), <span style="color:#ae81ff">40</span>);

    PrintVector(v);

    v.insert(v.begin() <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>);  <span style="color:#75715e">//插到第二个位置
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//vector支持随机访问
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//支持数组下标，一般都支持随机访问
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//迭代器可以直接+-操作
</span><span style="color:#75715e"></span>
    PrintVector(v);

    <span style="color:#75715e">//删除
</span><span style="color:#75715e"></span>    v.erase(v.begin());
    PrintVector(v);

    v.erase(v.begin() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, v.end());
    PrintVector(v);

    v.clear();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.size() <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//巧用swap缩减空间
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test06</span>() {
    <span style="color:#75715e">//vector添加元素 自动增长 那么，删除元素的时候，会自动减少吗
</span><span style="color:#75715e"></span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100000</span>; i<span style="color:#f92672">++</span>) {
        v.push_back(i);
    }

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.size() <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;capacity: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.capacity() <span style="color:#f92672">&lt;&lt;</span> endl;

    v.resize(<span style="color:#ae81ff">10</span>);

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;----------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.size() <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;capacity: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.capacity() <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#75715e">//收缩空间
</span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(v).swap(v);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;----------&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.size() <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;capacity: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> v.capacity() <span style="color:#f92672">&lt;&lt;</span> endl;
    PrintVector(v);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test07</span>() {
    <span style="color:#75715e">//reserve预留空间 resize区别
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> address <span style="color:#f92672">=</span> NULL;
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;

    v.reserve(<span style="color:#ae81ff">100000</span>);  <span style="color:#75715e">//预先分配
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100000</span>; i<span style="color:#f92672">++</span>) {
        v.push_back(i);
        <span style="color:#66d9ef">if</span> (address <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">0</span>]) {
            num<span style="color:#f92672">++</span>;
        }
    }

    cout <span style="color:#f92672">&lt;&lt;</span> num <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#75715e">//如果你知道容器大概需要的空间，预先分配空间，可以减少时间浪费吗，提高程序运行效率
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test03();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test04();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test05();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test06();
</span><span style="color:#75715e"></span>    test07();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="deque">deque</h5>
<p>deque表示双端队列，即可以从前端或者后端这两端进行数据的插入和删除</p>
<ul>
<li>分段连续的内存空间</li>
<li>支持随机访问</li>
<li>指定位置插入，会引起数据移动</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;deque&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintDeque</span>(deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> d) {
    <span style="color:#66d9ef">for</span> (deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> d.begin(); it <span style="color:#f92672">!=</span> d.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
}

<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d1;
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d2(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5</span>);
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d3(d2.begin(), d2.end());
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d4(d3);

    <span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    PrintDeque(d4);
    cout <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//赋值、大小操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d1;
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d2;
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d3;
    d1.assign(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">5</span>);
    d2.assign(d1.begin(), d1.end());  <span style="color:#75715e">//迭代器指定区间赋值
</span><span style="color:#75715e"></span>    d3 <span style="color:#f92672">=</span> d2;                          <span style="color:#75715e">//等号赋值
</span><span style="color:#75715e"></span>
    d1.swap(d2);  <span style="color:#75715e">//交换两个空间的元素
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> (d1.empty()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;空&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;不空&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    d1.resize(<span style="color:#ae81ff">5</span>);  <span style="color:#75715e">//有十个，后五个扔掉
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//插入和删除
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test03</span>() {
    deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d1;
    d1.push_back(<span style="color:#ae81ff">100</span>);
    d1.push_front(<span style="color:#ae81ff">200</span>);
    d1.push_back(<span style="color:#ae81ff">300</span>);
    d1.push_back(<span style="color:#ae81ff">400</span>);
    d1.push_front(<span style="color:#ae81ff">500</span>);
    <span style="color:#75715e">//500 200 100 300 400
</span><span style="color:#75715e"></span>
    PrintDeque(d1);

    <span style="color:#66d9ef">int</span> val <span style="color:#f92672">=</span> d1.front();  <span style="color:#75715e">//拿到第一个数据
</span><span style="color:#75715e"></span>    d1.pop_front();        <span style="color:#75715e">//删除第一个，无返回值
</span><span style="color:#75715e"></span>
    val <span style="color:#f92672">=</span> d1.back();
    d1.pop_back();  <span style="color:#75715e">//删除最后一个元素
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>    test03();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="list">list</h5>
<ul>
<li>双向链表</li>
<li>链表是由一系列节点组成的，节点包括两个域，一个数据域，一个指针域。</li>
<li>链表内存是非连续的，添加删除元素 时间复杂度是常数项 不需要移动元素</li>
<li>链表需要额外空间保留节点关系</li>
<li>不支持随机访问，故不能使用算法提供的sort()来进行排序，但可以调用其成员方法</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l1;
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l2(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l3(l2);
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l4(l3.begin(), l3.end());

    <span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l4.begin(); it <span style="color:#f92672">!=</span> l4.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }

    cout <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//插入和删除
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l;
    l.push_back(<span style="color:#ae81ff">100</span>);
    l.push_front(<span style="color:#ae81ff">200</span>);
    l.insert(l.begin(), <span style="color:#ae81ff">300</span>);
    l.insert(l.end(), <span style="color:#ae81ff">200</span>);

    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin();
    it<span style="color:#f92672">++</span>;
    l.insert(it, <span style="color:#ae81ff">500</span>);

    <span style="color:#75715e">//删除
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//l.pop_back();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//l.pop_front();
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//l.erase(l.begin(), l.end());
</span><span style="color:#75715e"></span>
    l.remove(<span style="color:#ae81ff">200</span>);  <span style="color:#75715e">//删除匹配的所有值
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin(); it <span style="color:#f92672">!=</span> l.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }

    cout <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#75715e">//赋值操作
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test03</span>() {
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l;
    l.assign(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);

    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l2;
    l2 <span style="color:#f92672">=</span> l;

    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l3;
    l3.swap(l);
}

<span style="color:#75715e">//反转
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test04</span>() {
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
        l.push_back(i);
    }

    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin(); it <span style="color:#f92672">!=</span> l.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    l.reverse();  <span style="color:#75715e">//容器元素反转
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin(); it <span style="color:#f92672">!=</span> l.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Mycompare</span>(<span style="color:#66d9ef">int</span> val1, <span style="color:#66d9ef">int</span> val2) {
    <span style="color:#66d9ef">return</span> val1 <span style="color:#f92672">&gt;</span> val2;
}

<span style="color:#75715e">//排序
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test05</span>() {
    list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
        l.push_back(rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
    }
    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin(); it <span style="color:#f92672">!=</span> l.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    l.sort();

    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin(); it <span style="color:#f92672">!=</span> l.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#75715e">//从大到小
</span><span style="color:#75715e"></span>    l.sort(Mycompare);

    <span style="color:#66d9ef">for</span> (list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> l.begin(); it <span style="color:#f92672">!=</span> l.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#75715e">//算法sort  只支持可随机访问的容器 链表没有
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//list的sort是自己的成员函数不是算法
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test04();
</span><span style="color:#75715e"></span>    test05();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="queue">queue</h5>
<ul>
<li>先进先出</li>
<li>不提供迭代器，不能遍历，不支持随机访问</li>
<li>push 入队（队尾）</li>
<li>pop 出队（队头）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
	queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;<span style="color:#75715e">//创建队列
</span><span style="color:#75715e"></span>
	q.push(<span style="color:#ae81ff">10</span>);
	q.push(<span style="color:#ae81ff">20</span>);
	q.push(<span style="color:#ae81ff">30</span>);
	q.push(<span style="color:#ae81ff">40</span>);

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;队尾元素: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> q.back() <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//输出顺序 10,20,30,40
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (q.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>){
		cout <span style="color:#f92672">&lt;&lt;</span> q.front() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//输出队头
</span><span style="color:#75715e"></span>		q.pop();<span style="color:#75715e">//删除队头
</span><span style="color:#75715e"></span>	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	test01();
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="stack">stack</h5>
<ul>
<li>先进后出</li>
<li>push 压栈</li>
<li>pop 出栈</li>
<li>栈不提供迭代器，不能遍历，不支持随机访问，只能通过top从栈顶获取和删除元素</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>(){

	<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s1;
	stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s2(s1);

	<span style="color:#75715e">//stack操作
</span><span style="color:#75715e"></span>	s1.push(<span style="color:#ae81ff">10</span>);
	s1.push(<span style="color:#ae81ff">20</span>);
	s1.push(<span style="color:#ae81ff">30</span>);
	s1.push(<span style="color:#ae81ff">100</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;栈顶元素：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> s1.top() <span style="color:#f92672">&lt;&lt;</span> endl;
	s1.pop();<span style="color:#75715e">//删除栈顶元素
</span><span style="color:#75715e"></span>
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;栈顶元素：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> s1.top() <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#75715e">//打印栈容器数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>s1.empty()) {
		cout <span style="color:#f92672">&lt;&lt;</span> s1.top() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
		s1.pop();
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;

	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;size:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> s1.size() <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	test01();
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="关联式容器">关联式容器</h4>
<p><strong>容器的规则是固定的，与元素进入容器的时间和地点无关</strong></p>
<h5 id="setmultiset">set/multiset</h5>
<p>set表示集合，集合是存储排序键的关联式容器，且每个键值都是唯一的，可以插入或删除但是不能更改</p>
<ul>
<li>以红黑树为底层机制，查找效率非常好</li>
<li>set中不允许重复元素，multiset中允许重复元素</li>
<li>不可通过迭代器改变set元素的值，会破坏set组织</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//仿函数  类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mycompare</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">int</span> v1, <span style="color:#66d9ef">int</span> v2) <span style="color:#66d9ef">const</span> {  <span style="color:#75715e">//此处注意，要加const限定符
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> v1 <span style="color:#f92672">&gt;</span> v2;
    }
};

<span style="color:#75715e">//set容器初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
    set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, Mycompare<span style="color:#f92672">&gt;</span> s1;
    s1.insert(<span style="color:#ae81ff">8</span>);
    s1.insert(<span style="color:#ae81ff">10</span>);
    s1.insert(<span style="color:#ae81ff">4</span>);
    s1.insert(<span style="color:#ae81ff">6</span>);
    s1.insert(<span style="color:#ae81ff">5</span>);
    s1.insert(<span style="color:#ae81ff">1</span>);
    s1.insert(<span style="color:#ae81ff">3</span>);
    s1.insert(<span style="color:#ae81ff">2</span>);  <span style="color:#75715e">//自动进行排序，默认从小到大
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> s1.begin(); it <span style="color:#f92672">!=</span> s1.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#75715e">//从大到小排序怎么办？
</span><span style="color:#75715e"></span><span style="color:#75715e">#if 0</span><span style="color:#75715e">
</span><span style="color:#75715e">	//赋值
</span><span style="color:#75715e">	set&lt;int&gt; s2;
</span><span style="color:#75715e">	s2 = s1;
</span><span style="color:#75715e">
</span><span style="color:#75715e">	//删除
</span><span style="color:#75715e">	s1.erase(s1.begin());
</span><span style="color:#75715e">	s1.erase(6);
</span><span style="color:#75715e">
</span><span style="color:#75715e">	for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) {
</span><span style="color:#75715e">		cout &lt;&lt; *it &lt;&lt; &#34; &#34;;
</span><span style="color:#75715e">	}
</span><span style="color:#75715e">	cout &lt;&lt; endl;
</span><span style="color:#75715e">
</span><span style="color:#75715e">	cout &lt;&lt; &#34;size = &#34; &lt;&lt; s2.size() &lt;&lt; endl;
</span><span style="color:#75715e">	s2.clear();
</span><span style="color:#75715e">	cout &lt;&lt; &#34;size = &#34; &lt;&lt; s2.size() &lt;&lt; endl;
</span><span style="color:#75715e"></span><span style="color:#75715e">
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">//set查找
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {
    <span style="color:#75715e">//实值
</span><span style="color:#75715e"></span>    set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s1;
    s1.insert(<span style="color:#ae81ff">8</span>);
    s1.insert(<span style="color:#ae81ff">10</span>);
    s1.insert(<span style="color:#ae81ff">4</span>);
    s1.insert(<span style="color:#ae81ff">6</span>);
    s1.insert(<span style="color:#ae81ff">5</span>);
    s1.insert(<span style="color:#ae81ff">1</span>);
    s1.insert(<span style="color:#ae81ff">3</span>);
    s1.insert(<span style="color:#ae81ff">2</span>);

    set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator ret <span style="color:#f92672">=</span> s1.find(<span style="color:#ae81ff">4</span>);

    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> s1.end()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>ret <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#75715e">//找到第一个大于等于的元素
</span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> s1.lower_bound(<span style="color:#ae81ff">4</span>);
    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> s1.end()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>ret <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#75715e">//找到第一个大于的元素
</span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> s1.upper_bound(<span style="color:#ae81ff">4</span>);
    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> s1.end()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>ret <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#75715e">//equal_range 返回lower_bound和upper_bound的值
</span><span style="color:#75715e"></span>    pair<span style="color:#f92672">&lt;</span>set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator, set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator<span style="color:#f92672">&gt;</span> pret <span style="color:#f92672">=</span> s1.equal_range(<span style="color:#ae81ff">4</span>);
    <span style="color:#66d9ef">if</span> (pret.first <span style="color:#f92672">==</span> s1.end()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pret.first <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#66d9ef">if</span> (pret.second <span style="color:#f92672">==</span> s1.end()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>pret.second <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Person(<span style="color:#66d9ef">int</span> id, <span style="color:#66d9ef">int</span> age) <span style="color:#f92672">:</span> id(id), age(age){};

    <span style="color:#66d9ef">int</span> id;
    <span style="color:#66d9ef">int</span> age;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PersonCompare</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p1, <span style="color:#66d9ef">const</span> Person<span style="color:#f92672">&amp;</span> p2) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> p1.age <span style="color:#f92672">&gt;</span> p2.age;
    }
};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test03</span>() {
    set<span style="color:#f92672">&lt;</span>Person, PersonCompare<span style="color:#f92672">&gt;</span> sp;

    Person p1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>), p2(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>), p3(<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">60</span>);

    sp.insert(p1);
    sp.insert(p2);
    sp.insert(p3);

    <span style="color:#66d9ef">for</span> (set<span style="color:#f92672">&lt;</span>Person, PersonCompare<span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> sp.begin(); it <span style="color:#f92672">!=</span> sp.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>it).id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;   &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>it).age <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#75715e">//查找
</span><span style="color:#75715e"></span>    Person p4(<span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">20</span>);
    set<span style="color:#f92672">&lt;</span>Person, PersonCompare<span style="color:#f92672">&gt;::</span>iterator ret <span style="color:#f92672">=</span> sp.find(p4);  <span style="color:#75715e">//可找到，对应p1，按照age排序就按照age查找
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> sp.end()) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>ret).id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;   &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>ret).age <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>    test03();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h6 id="对组">对组</h6>
<p>将两个值合并成一个值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#define _CRT_SECURE_NO_WARNINGS
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
	pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pair1(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> pair1.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;   &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pair1.second <span style="color:#f92672">&lt;&lt;</span> endl;

	pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, string<span style="color:#f92672">&gt;</span> pair2 <span style="color:#f92672">=</span> make_pair(<span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;aaa&#34;</span>);
	cout <span style="color:#f92672">&lt;&lt;</span> pair2.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;   &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pair2.second <span style="color:#f92672">&lt;&lt;</span> endl;

	pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, string<span style="color:#f92672">&gt;</span> pair3 <span style="color:#f92672">=</span> pair2;
	cout <span style="color:#f92672">&lt;&lt;</span> pair3.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;   &#34;</span> <span style="color:#f92672">&lt;&lt;</span> pair3.second <span style="color:#f92672">&lt;&lt;</span> endl;

}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	test01();
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="mapmultimap">map/multimap</h5>
<ul>
<li>map与set区别，map具有键值和实值</li>
<li>所有元素根据键值自动排序</li>
<li>pair的第一个元素成为键值，第二个元素成为实值</li>
<li>map也是以红黑树为底层实现机制</li>
<li>不可以通过map的迭代器修改map键值，键值关系到容器内元素的排列顺序，任意改变键值会破坏容器的排列规则，但是可以改变实值</li>
<li>multimap允许相同键值存在，map不允许</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#75715e">//map初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test01</span>() {
    <span style="color:#75715e">//map容器模板参数：第一个参数key的类型，第二个参数value的类型
</span><span style="color:#75715e"></span>    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m;

    <span style="color:#75715e">//插入数据  pair.first  对应key，pair.second   对应value
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//第一种
</span><span style="color:#75715e"></span>    pair<span style="color:#f92672">&lt;</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator, <span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> ret <span style="color:#f92672">=</span> m.insert(pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>));  <span style="color:#75715e">//放入匿名对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (ret.second) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;第一次插入成功&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;插入失败&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#75715e">//第二种
</span><span style="color:#75715e"></span>    ret <span style="color:#f92672">=</span> m.insert(make_pair(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>));
    <span style="color:#66d9ef">if</span> (ret.second) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;第二次插入成功&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;插入失败&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#75715e">//第三种
</span><span style="color:#75715e"></span>    m.insert(map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value_type(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">30</span>));

    <span style="color:#75715e">//第四种
</span><span style="color:#75715e"></span>    m[<span style="color:#ae81ff">40</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>;
    m[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    <span style="color:#75715e">//如果key不存在，创建pair并插入
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果key存在，修改value实值
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> m.begin(); it <span style="color:#f92672">!=</span> m.end(); it<span style="color:#f92672">++</span>) {
        <span style="color:#75715e">//*it取出来一个pair
</span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;key = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>it).first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, value = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>it).second <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;m[60] = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m[<span style="color:#ae81ff">60</span>] <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#75715e">//访问一个不存再的key，那么map会将这个key插入到map中，对应的value默认为零
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">for</span> (map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> m.begin(); it <span style="color:#f92672">!=</span> m.end(); it<span style="color:#f92672">++</span>) {
        <span style="color:#75715e">//*it取出来一个pair
</span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;key = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>it).first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, value = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (<span style="color:#f92672">*</span>it).second <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyKey</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    MyKey(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> id) <span style="color:#f92672">:</span> index(index), id(id) {}

    <span style="color:#66d9ef">int</span> index;
    <span style="color:#66d9ef">int</span> id;
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">mycompare</span> {
    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()(MyKey key1, MyKey key2) <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> key1.index <span style="color:#f92672">&gt;</span> key2.index;
    }
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test02</span>() {
    map<span style="color:#f92672">&lt;</span>MyKey, <span style="color:#66d9ef">int</span>, mycompare<span style="color:#f92672">&gt;</span> m;  <span style="color:#75715e">//需要排序，自定义类型，给定一个排序方法
</span><span style="color:#75715e"></span>
    m.insert(make_pair(MyKey(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), <span style="color:#ae81ff">2</span>));

    m.insert(make_pair(MyKey(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>), <span style="color:#ae81ff">2</span>));

    <span style="color:#66d9ef">for</span> (map<span style="color:#f92672">&lt;</span>MyKey, <span style="color:#66d9ef">int</span>, mycompare<span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> m.begin(); it <span style="color:#f92672">!=</span> m.end(); it<span style="color:#f92672">++</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> it<span style="color:#f92672">-&gt;</span>first.index <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> it<span style="color:#f92672">-&gt;</span>first.id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;;&#34;</span> <span style="color:#f92672">&lt;&lt;</span> it<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}

<span style="color:#75715e">//equal_range
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test03</span>() {
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m;
    m.insert(make_pair(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>));
    m.insert(make_pair(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>));
    m.insert(make_pair(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>));

    pair<span style="color:#f92672">&lt;</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator, map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator<span style="color:#f92672">&gt;</span> ret <span style="color:#f92672">=</span> m.equal_range(<span style="color:#ae81ff">2</span>);

    <span style="color:#66d9ef">if</span> (ret.first<span style="color:#f92672">-&gt;</span>second) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到lower_bound&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没有找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }

    <span style="color:#66d9ef">if</span> (ret.second<span style="color:#f92672">-&gt;</span>second) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到upper_bound&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    } <span style="color:#66d9ef">else</span> {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没有找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">//test01();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//test02();
</span><span style="color:#75715e"></span>    test03();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="对比">对比</h4>
<table>
<thead>
<tr>
<th>容器</th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody>
<tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="迭代器">迭代器</h3>
<p>可以理解为指针，对指针的操作基本可以对迭代器操作，但实际上，迭代器是一个类，这个类封装了一个指针</p>
<h3 id="算法">算法</h3>
<p>通过有限的步骤解决问题的方法</p>]]></content:encoded>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Wed, 03 Feb 2021 20:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>简单介绍了一下并查集</description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6%e6%9f%a5%e9%9b%86.jpg" alt=""  />
</p>
<p>“你只看见我渺小的身躯，却没有看到我心中的广阔森林”</p>
<p>并查集可以总结为三句话：</p>
<ul>
<li>“并”的意思是把两个有某些关系的结点并到一起</li>
<li>“查”的意思是查找一个结点的根节点</li>
<li>“并”的时候需要用到“查”</li>
</ul>
<h3 id="初始化">初始化</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> father[len];<span style="color:#75715e">//此数组定义在全局
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Init</span>(<span style="color:#66d9ef">int</span> n){
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; <span style="color:#f92672">++</span>i) {<span style="color:#75715e">//len为结点总数
</span><span style="color:#75715e"></span>		father[i] <span style="color:#f92672">=</span> i;
	}
}
</code></pre></div><h3 id="查">查</h3>
<p>初始化一个father数组，里面存放每个结点的父结点，即数组序号就是自己，数组里存放的数据就是自己的爹（父结点）。所以我们可以用数组表示一棵树，其目的是为了找到根节点（祖先）（自己是自己的爹的那个结点）</p>
<p>假如有一个大家族里，大家族中的每个人都知道自己的父亲是谁，当有一天，你问你爸爸我的祖先是谁呀？你爸爸就会先问你爷爷，你爷爷就问你太爷爷，最后就能追溯到祖先 root.</p>
<p>如图即是对应关系</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%9f%a5.jpg" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//查（非递归算法）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FindRoot</span>(<span style="color:#66d9ef">int</span> x){
	r <span style="color:#f92672">=</span> x;
    <span style="color:#66d9ef">while</span>(r <span style="color:#f92672">!=</span> father[r]){<span style="color:#75715e">//自己是自己的爹即是找到了根结点
</span><span style="color:#75715e"></span>        r <span style="color:#f92672">=</span> father[r];
    }
    
    <span style="color:#66d9ef">return</span> r;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//递归算法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">FindRoot</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">return</span> x <span style="color:#f92672">==</span> father[x] <span style="color:#f92672">?</span> x : FindRoot(father[x]);
}
</code></pre></div><h3 id="并">并</h3>
<p>如果现在有两个结点x，y，通过“查”可以判断x和y的根节点是否相同（查询祖先是否相同），如果是同一个祖先，那么x和y就是一家人，不进行操作；</p>
<p>相反的，如果x和y祖先不同，那就必须要迁户口，让他们成为一家人，即y的祖先做x的祖先的儿子，至此，实现了合并的操作</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%b9%b6.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//并
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
	x <span style="color:#f92672">=</span> FindRoot(x);
	y <span style="color:#f92672">=</span> FindRoot(y);
    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">!=</span> y){
		parent[y] <span style="color:#f92672">=</span> x;
    }
}
</code></pre></div><h3 id="例题">例题</h3>
<p>hdu1213</p>
<h5 id="问题描述">问题描述</h5>
<p>今天是伊格纳修斯的生日。他邀请了很多朋友。现在是晚餐时间。伊格纳修斯想知道他至少需要多少张桌子。你必须注意到，不是所有的朋友都认识，所有的朋友都不想和陌生人呆在一起。
此问题的一个重要规则是，如果我告诉你 A 知道 B，B 知道 C，这意味着 A、B、C 彼此了解，这样他们就可以坐在一个桌子上。</p>
<p>例如：如果我告诉你 A 知道 B，B 知道 C，D 知道 E，所以 A、B、C 可以坐在一个桌子上，而 D、E 必须坐在另一个桌子上
所以伊格纳修斯至少需要 2 张桌子。</p>
<h5 id="输入">输入</h5>
<p>输入以表示测试用例数的整数 T（1&lt;=T&lt;=25）开头。然后 T 测试用例随之而来。每个测试用例以两个整数 N 和 M（1&lt;=N，M&lt;=1000）开头。N 表示好友数量，好友从 1 标记为 N。然后 M 线跟随。每行由两个整数 A 和 B（A！=B）组成，这意味着朋友 A 和朋友 B 彼此认识。两个案例之间空一行。</p>
<h5 id="输出">输出</h5>
<p>对于每个测试用例，只需输出至少需要多少张桌子。不要打印任何空白。</p>
<h5 id="示例输入">示例输入</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">5</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>

<span style="color:#ae81ff">5</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">2</span> <span style="color:#ae81ff">5</span>

</code></pre></div><h5 id="示例输出">示例输出</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">2</span>
<span style="color:#ae81ff">4</span>
</code></pre></div><p>这道题用一句话概括就是在一张桌子上，每个人都要有认识的人</p>
<h5 id="代码">代码</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> father[<span style="color:#ae81ff">1001</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x) {
	<span style="color:#66d9ef">return</span> father[x] <span style="color:#f92672">==</span> x <span style="color:#f92672">?</span> x : find(father[x]);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span> (<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
	x <span style="color:#f92672">=</span> find(x);
	y <span style="color:#f92672">=</span> find(y);
	<span style="color:#66d9ef">if</span> (x <span style="color:#f92672">!=</span> y) {
		a[x] <span style="color:#f92672">=</span> y;
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {
	<span style="color:#66d9ef">int</span> t, m, n, x, y;
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>t);
	<span style="color:#66d9ef">while</span> (t<span style="color:#f92672">--</span>) {
		scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
		<span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
			father[i] <span style="color:#f92672">=</span> i;
		}

		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; <span style="color:#f92672">++</span>i) {
			scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>, <span style="color:#f92672">&amp;</span>x, <span style="color:#f92672">&amp;</span>y);
			merge(x, y);
		}
		
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; <span style="color:#f92672">++</span>i) {
			<span style="color:#66d9ef">if</span> (father[i] <span style="color:#f92672">==</span> i) {
				cnt<span style="color:#f92672">++</span>;
			}
		}
		printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cnt);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="优化">优化</h3>
<h4 id="合并的优化">合并的优化</h4>
<p>如果一开始就是暴力盲目的将大树接到小树的根结点下，那么就会出现头重脚轻的现象，导致树生长的不平衡。那么，如果将小树接到大树的根结点下就可以避免</p>
<p>不妨再设置一个数组height，用来统计以每个结点为根结点的树的深度</p>
<p>初始化代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> father[len];
<span style="color:#66d9ef">int</span> height[len];
<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> len; i<span style="color:#f92672">++</span>){
	father[i] <span style="color:#f92672">=</span> i;
	height[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//初始深度为1
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//并
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
	x <span style="color:#f92672">=</span> FindRoot(x);
	y <span style="color:#f92672">=</span> FindRoot(y);
	<span style="color:#66d9ef">if</span>(height[x] <span style="color:#f92672">==</span> height[y]){<span style="color:#75715e">//此处无需判断x，y根结点是否一致
</span><span style="color:#75715e"></span>		height[x] <span style="color:#f92672">=</span> height[x] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
		father[y] <span style="color:#f92672">=</span> x;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(height[x] <span style="color:#f92672">&gt;</span> height [y]){
		father[y] <span style="color:#f92672">=</span> x;
    }
    <span style="color:#66d9ef">else</span> {
        father[x] <span style="color:#f92672">=</span> y;
    }
}
</code></pre></div><h4 id="查询的优化">查询的优化</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"> <span style="color:#75715e">//对于之前的查询程序，查询元素i是需要搜索路径找到根结点，返回的结果是根结点。
</span><span style="color:#75715e">//这条搜索路径可能很长。如果返回的时候顺便把元素i所属的结点改为根节点，那么在下次搜索时就能够在O(1)的时间内得到结果
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span> (<span style="color:#66d9ef">int</span> x){
    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">!=</span> parent[x]){
		father[x] <span style="color:#f92672">=</span> find(father[x]);
    }
	<span style="color:#66d9ef">return</span> father[x];   
}
</code></pre></div><p>此方法成为路径压缩，不仅优化了下次查询，而且还优化了合并</p>
<p>但是使用递归实现，如果数据规模较大，有可能爆栈，非递归代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Find</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> x;
    <span style="color:#66d9ef">while</span>(father[r] <span style="color:#f92672">!=</span> r){<span style="color:#75715e">//找到根结点
</span><span style="color:#75715e"></span>		r <span style="color:#f92672">=</span> father[r];
    }
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> x;
    <span style="color:#66d9ef">int</span> j;
    <span style="color:#66d9ef">while</span>(i <span style="color:#f92672">!=</span> r){<span style="color:#75715e">//循环修改这条路径上的根结点
</span><span style="color:#75715e"></span>		j <span style="color:#f92672">=</span> father[i];<span style="color:#75715e">//j记录元素i此时的父亲
</span><span style="color:#75715e"></span>		father[i] <span style="color:#f92672">=</span> r;<span style="color:#75715e">//将i的父亲改为根结点
</span><span style="color:#75715e"></span>		i <span style="color:#f92672">=</span> j;<span style="color:#75715e">//i记录为要“查询”的结点
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> r;
}
</code></pre></div><p>经过以上优化，查找和合并的时间复杂度都小于 $(log_2n)$</p>
<h3 id="总结">总结</h3>
<ul>
<li>并查集的思想很精妙，用一个数组表示了整片森林</li>
<li>优化的关键在于记录每棵树的结点数量，根据结点关系合并</li>
</ul>]]></content:encoded>
    </item>
    
    <item>
      <title>树（二）</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/</link>
      <pubDate>Wed, 03 Feb 2021 19:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%BA%8C/</guid>
      <description>简单介绍了一下树</description>
      <content:encoded><![CDATA[<h3 id="树的遍历">树的遍历</h3>
<p>上一节记录了树的递归遍历，递归是函数自身调用自身，大量压栈出栈，时间和空间开销较大，而这操作都是在栈上，如果数据规模较大很容易溢出。</p>
<p>以下是树的非递归遍历方法：</p>
<p>偷个懒用一下C++写，头文件要加上</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></code></pre></div><h4 id="先序遍历">先序遍历</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//先序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreorderNoneSecu</span>(PTree T) {
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;先序非递归遍历&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	PTree t <span style="color:#f92672">=</span> T;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s;
	<span style="color:#66d9ef">while</span>(t <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s.empty()){
		<span style="color:#66d9ef">while</span>(t){
			cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//拿到这个结点就直接打印
</span><span style="color:#75715e"></span>			s.push(t);
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
		}

		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s.empty()){
			t <span style="color:#f92672">=</span> s.top();
			s.pop();			
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
		}
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h4 id="中序遍历">中序遍历</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//中序非递归遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InorderNoneSecu</span>(PTree T) {
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;中序非递归遍历&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	PTree t <span style="color:#f92672">=</span> T;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s;
	<span style="color:#66d9ef">while</span>(t <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s.empty()){
		<span style="color:#66d9ef">while</span>(t){
			s.push(t);
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
		}

		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s.empty()){
			t <span style="color:#f92672">=</span> s.top();
			s.pop();
			cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//遍历完左子树后再打印
</span><span style="color:#75715e"></span>			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
		}
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h4 id="后序遍历">后序遍历</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//后序非递归遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PostorderNoneSecu</span>(PTree T) {
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;后序非递归遍历&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	PTree t <span style="color:#f92672">=</span> T;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s;
	stack<span style="color:#f92672">&lt;</span>PTree<span style="color:#f92672">&gt;</span> s2;
	<span style="color:#66d9ef">while</span>(t <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s.empty()){
		<span style="color:#66d9ef">while</span>(t){
			s.push(t);
			s2.push(t);
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>right;
		}

		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s.empty()){
			t <span style="color:#f92672">=</span> s.top();
			s.pop();
			t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>left;
		}
	}

	<span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>s2.empty()){
		t <span style="color:#f92672">=</span> s2.top();
		s2.pop();
		cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
	}

	cout <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><p>后序遍历与先序遍历的顺序相反，那么可以先遍历右子树，也就是说将先序遍历的顺序逆过来压入s2中，，然后再根据栈的后进先出的特点，一一出栈。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>树（一）</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/</link>
      <pubDate>Tue, 02 Feb 2021 16:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%80/</guid>
      <description>简单介绍了一下树</description>
      <content:encoded><![CDATA[<p>树是n个结点的有限集，可以是空树（n == 0）也可以是非空树。</p>
<p>对于非空树：</p>
<p>1.有且仅有一个称之为根的结点。</p>
<p>2.除根结点以外的其余结点可分为m个互不相交的有限集，其中每个集合本身也是一棵树，成为根的子树。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84.jpg" alt=""  />
</p>
<h3 id="基本术语">基本术语</h3>
<ul>
<li>结点的度（Degree）：结点的子树个数</li>
<li>树的度：树的所有结点最大的度</li>
<li>叶结点（Leaf）：度为0的结点</li>
<li>父结点（Parent）：有子树的结点是其子树的根结点的父结点</li>
<li>子结点（Child）：若A结点是B结点的父结点，则称B结点为A结点的子结点；子结点也称孩子结点</li>
<li>兄弟结点（Sibling）：具有同一父结点的个节点彼此是兄弟结点</li>
<li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，n3&hellip;nk。路径所包含边的个数为路径的长度</li>
<li>祖先结点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li>
<li>子孙节点（Descendant）：某一结点的子树中的所有结点是这个结点的子孙</li>
<li>结点的层次（Level）：规定根结点在第一层，其它任意节点层数是父结点层数加一</li>
<li>树的深度（Depth）：树中所有结点中的最大层次</li>
</ul>
<h3 id="二叉树">二叉树</h3>
<p>二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<h4 id="性质">性质</h4>
<p>1.二叉树的第i层的最大节点数为<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgi.svg" alt=""  />
</p>
<p>2.深度为k的二叉树最大结点数为<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgk.svg" alt=""  />
</p>
<p>3.二叉树的终端节点数为n0，度数为2 的结点数为n2，则n0 = n2 +1</p>
<p><strong>特殊的,</strong></p>
<p>如果一个深度为 k 的二叉树，正好有  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgk.svg" alt=""  />
个结点，那么这棵树就被称为<strong>满二叉树</strong>。</p>
<p>如图所示：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%bb%a1%e4%ba%8c%e5%8f%89%e6%a0%91.jpg" alt=""  />
</p>
<p>如果一个二叉树，只有当第 i 层已经达到了<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/imgi.svg" alt=""  />
的最大值以后，才能往第 i + 1 层自左向右地添加结点，这棵树就被称为<strong>完全二叉树</strong>。</p>
<p>那么，根据二叉树的性质二可得，具有n个结点的完全二叉树的深度为
$$
[log_2(n)]+1
$$</p>
<p>如图所示：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%8f%89%e6%a0%91.jpg" alt=""  />
</p>
<h4 id="二叉树的建立">二叉树的建立</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Tree
{
	<span style="color:#66d9ef">int</span> data;
	<span style="color:#66d9ef">struct</span> Tree <span style="color:#f92672">*</span>left;
	<span style="color:#66d9ef">struct</span> Tree <span style="color:#f92672">*</span>right;
} BiTree, <span style="color:#f92672">*</span>PTree;
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//创造一个结点
</span><span style="color:#75715e"></span>PTree <span style="color:#a6e22e">CreatNode</span>(<span style="color:#66d9ef">int</span> value) {
	PTree p <span style="color:#f92672">=</span> (PTree)malloc(<span style="color:#66d9ef">sizeof</span>(BiTree));
	p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> value;
	p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
	<span style="color:#66d9ef">return</span> p;
}

<span style="color:#75715e">//插入结点且排序，不存在有相同值的结点
</span><span style="color:#75715e"></span>PTree <span style="color:#a6e22e">AddNode</span>(<span style="color:#66d9ef">int</span> value, PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> CreatNode(value);
	}

	<span style="color:#66d9ef">if</span> (value <span style="color:#f92672">==</span> p<span style="color:#f92672">-&gt;</span>data) {
		<span style="color:#66d9ef">return</span> p;
	}

	<span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> p<span style="color:#f92672">-&gt;</span>data) {
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL) {
			p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> CreatNode(value);
			<span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>left;
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">return</span> AddNode(value, p<span style="color:#f92672">-&gt;</span>left);
		}
	}
	<span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">if</span> (p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL) {
			p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> CreatNode(value);
			<span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>right;
		}
		<span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">return</span> AddNode(value, p<span style="color:#f92672">-&gt;</span>right);
		}
	}
}
</code></pre></div><h4 id="遍历二叉树">遍历二叉树</h4>
<p>递归遍历左子树、根节点、递归遍历右子树</p>
<h5 id="先序遍历">先序遍历</h5>
<p>输出根节点，递归遍历左子树，在递归遍历右子树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Preorder</span>(PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
		Preorder(p<span style="color:#f92672">-&gt;</span>left);
		Preorder(p<span style="color:#f92672">-&gt;</span>right);
	}
}
</code></pre></div><h5 id="中序遍历">中序遍历</h5>
<p>递归遍历左子树，输出根节点，在递归遍历右子树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Midorder</span>(PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
		Midorder(p<span style="color:#f92672">-&gt;</span>left);
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
		Midorder(p<span style="color:#f92672">-&gt;</span>right);
	}
}
</code></pre></div><h5 id="后序遍历">后序遍历</h5>
<p>递归遍历左子树，再递归遍历右子树，输出根节点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Postorder</span>(PTree p) {
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
		Postorder(p<span style="color:#f92672">-&gt;</span>left);
		Postorder(p<span style="color:#f92672">-&gt;</span>right);
		printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
	}
}
</code></pre></div><h4 id="求二叉树的深度">求二叉树的深度</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">TreeHeight</span>(PTree p) {
	<span style="color:#66d9ef">int</span> l, r;
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
	}
	<span style="color:#66d9ef">else</span> {
		l <span style="color:#f92672">=</span> TreeHeight(p<span style="color:#f92672">-&gt;</span>left);
		r <span style="color:#f92672">=</span> TreeHeight(p<span style="color:#f92672">-&gt;</span>right);
		<span style="color:#66d9ef">return</span> (l <span style="color:#f92672">&gt;</span> r <span style="color:#f92672">?</span> l : r) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
	}
}
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[]) {<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> value;
	PTree p <span style="color:#f92672">=</span> NULL;
	printf(<span style="color:#e6db74">&#34;Please enter 10 numbers:&#34;</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i) {
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">&amp;</span>value);
		<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
			p <span style="color:#f92672">=</span> CreatNode(value);
		}
		<span style="color:#66d9ef">else</span> {
			AddNode(value, p);
		}
	}

	Preorder(p);
	printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	Midorder(p);
	printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	Postorder(p);
	printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);

	printf(<span style="color:#e6db74">&#34;The depth of the binary tree is：%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, TreeHeight(p));

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>栈和队列</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 31 Jan 2021 23:38:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>简单介绍了一下栈和队列</description>
      <content:encoded><![CDATA[<h5 id="引入">引入</h5>
<p>栈是一种重要的线性结构，是线性表（顺序表，链表）的一种具体形式，也就是说其可以通过顺序表或链表实现。</p>
<p>顺序表或者链表可以像之前一样独立存在、处理数据，同时它们也可以是一些特殊的数据结构（栈、队列）的实现基础。</p>
<!-- raw HTML omitted -->
<h2 id="栈">栈</h2>
<h3 id="定义">定义</h3>
<p>栈是一个后进先出（LIFO）的线性表，其要求只在表尾进行数据的插入和删除等操作。也就是说，所谓栈其实就是一个线性表，但是它的操作上有一些特殊的要求和限制。如图</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%a0%88%e7%a4%ba%e6%84%8f%e5%9b%be.jpg" alt=""  />
</p>
<p><strong>线性表有两种存储形式，顺序表储存和链表储存。</strong></p>
<h3 id="顺序栈">顺序栈</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define MAXSIZE 100
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Stack{
	elem<span style="color:#f92672">*</span> base;<span style="color:#75715e">//栈基
</span><span style="color:#75715e"></span>	elem<span style="color:#f92672">*</span> top;<span style="color:#75715e">//栈顶
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> stacksize; <span style="color:#75715e">//栈的容量
</span><span style="color:#75715e"></span>}Stack;

</code></pre></div><h4 id="创建一个栈">创建一个栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CreatStack</span>(Stack<span style="color:#f92672">*</span> s){
	s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (elem<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(elem) <span style="color:#f92672">*</span> MAXSIZE);
	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s<span style="color:#f92672">-&gt;</span>base) <span style="color:#66d9ef">return</span> ERROR;
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base;
	s<span style="color:#f92672">-&gt;</span>stacksize <span style="color:#f92672">=</span> MAXSIZE;  	

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="入栈">入栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PushStack</span>(Stack<span style="color:#f92672">*</span> s, elem e){
	<span style="color:#66d9ef">if</span>(s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">-</span> s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">&gt;=</span> s<span style="color:#f92672">-&gt;</span>stacksize){
		s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> (elem<span style="color:#f92672">*</span>)realloc(s<span style="color:#f92672">-&gt;</span>base, <span style="color:#66d9ef">sizeof</span>(elem) <span style="color:#f92672">*</span> MAXSIZE);
		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>s<span style="color:#f92672">-&gt;</span>base) <span style="color:#66d9ef">return</span> ERROR;

		s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">+</span> s<span style="color:#f92672">-&gt;</span>stacksize;
		s<span style="color:#f92672">-&gt;</span>stacksize <span style="color:#f92672">+=</span>MAXSIZE;	
	}

	<span style="color:#f92672">*</span>(s<span style="color:#f92672">-&gt;</span>top) <span style="color:#f92672">=</span> e;
	s<span style="color:#f92672">-&gt;</span>top<span style="color:#f92672">++</span>;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="出栈">出栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PopStack</span>(Stack<span style="color:#f92672">*</span>s,elem <span style="color:#f92672">*</span>e){
	<span style="color:#66d9ef">if</span>(s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">==</span> s<span style="color:#f92672">-&gt;</span>base) <span style="color:#66d9ef">return</span> ERROR;
	<span style="color:#f92672">*</span>e <span style="color:#f92672">=</span> <span style="color:#f92672">*--</span>(s<span style="color:#f92672">-&gt;</span>top);

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="清空">清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CleanStack</span>(Stack<span style="color:#f92672">*</span> s){
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base;
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="销毁">销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DestroyStack</span>(Stack<span style="color:#f92672">*</span> s){
	free(s<span style="color:#f92672">-&gt;</span>base);
	s<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> s<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> NULL;
	s<span style="color:#f92672">-&gt;</span>stacksize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="获取当前容量">获取当前容量</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetSize</span>(Stack<span style="color:#f92672">*</span> s){
	<span style="color:#66d9ef">return</span> s<span style="color:#f92672">-&gt;</span>stacksize;
}
</code></pre></div><h3 id="链表栈">链表栈</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node<span style="color:#75715e">//定义链表结构
</span><span style="color:#75715e"></span>{
	elem data;<span style="color:#75715e">//数据域
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> Node<span style="color:#f92672">*</span> next;<span style="color:#75715e">//指针域
</span><span style="color:#75715e"></span>}Node, <span style="color:#f92672">*</span> LNode;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Stack
{
	LNode top;
	LNode base;
}Stack,<span style="color:#f92672">*</span>Pstack;
</code></pre></div><h4 id="创建一个栈-1">创建一个栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Pstack <span style="color:#a6e22e">CreatStack</span>(){
	Pstack stack <span style="color:#f92672">=</span> (Pstack)malloc(<span style="color:#66d9ef">sizeof</span>(Stack));
	<span style="color:#66d9ef">if</span>(stack <span style="color:#f92672">==</span> NULL){
		<span style="color:#66d9ef">return</span> NULL;
	}
	
	stack<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> stack<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> NULL;

	<span style="color:#66d9ef">return</span> stack;
}
</code></pre></div><h4 id="入栈-1">入栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PushStack</span>(Pstack <span style="color:#f92672">*</span>stack, elem e){
	Node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (LNode)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> NULL){
		<span style="color:#66d9ef">return</span> ERROR;
	}
	p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
	p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="出栈-1">出栈</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PopStack</span>(Pstack <span style="color:#f92672">*</span>stack){
	Node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	<span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>base){
		printf(<span style="color:#e6db74">&#34;栈已空&#34;</span>);
		<span style="color:#66d9ef">return</span> ERROR;
	}
	(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
	printf(<span style="color:#e6db74">&#34;%d &#34;</span>,p<span style="color:#f92672">-&gt;</span>data);
	free(p);

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="判断是否为空">判断是否为空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">IsEmptyStack</span>(Pstack stack){
	<span style="color:#66d9ef">return</span> (stack<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">==</span> stack<span style="color:#f92672">-&gt;</span>base);
}
</code></pre></div><h4 id="清空-1">清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CleanStack</span>(Pstack <span style="color:#f92672">*</span>stack){
	Node<span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	<span style="color:#66d9ef">while</span>(p){
		(<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; 
		free(p);
		p <span style="color:#f92672">=</span> (<span style="color:#f92672">*</span>stack)<span style="color:#f92672">-&gt;</span>top;
	}
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="销毁-1">销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DestroyStack</span>(Pstack <span style="color:#f92672">*</span>stack){
	CleanStack(stack);

	free(<span style="color:#f92672">*</span>stack);

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>	Pstack stack <span style="color:#f92672">=</span> CreatStack();

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i){
		PushStack(<span style="color:#f92672">&amp;</span>stack, i);
	}

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));

	<span style="color:#75715e">/*出栈*/</span>
	<span style="color:#75715e">// for (int i = 0; i &lt; 10; ++i){
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 	PopStack(&amp;stack);
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// }
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// printf(&#34;%\n&#34;);
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// printf(&#34;%d\n&#34;, IsEmptyStack(stack));
</span><span style="color:#75715e"></span>	
	<span style="color:#75715e">/*清空*/</span>
	CleanStack(<span style="color:#f92672">&amp;</span>stack);

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));
	printf(<span style="color:#e6db74">&#34;%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,stack);

	DestroyStack(<span style="color:#f92672">&amp;</span>stack);

	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, IsEmptyStack(stack));
	printf(<span style="color:#e6db74">&#34;%p</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,stack);

}
</code></pre></div><h3 id="栈与递归">栈与递归</h3>
<p><strong>递归：函数自己调用自己</strong></p>
<ul>
<li>函数定义是递归的——斐波那契数列</li>
<li>数据结构是递归的——单链表、树</li>
<li>问题解法是递归的——汉诺塔、</li>
</ul>
<h4 id="函数的调用">函数的调用</h4>
<p>函数被调用之前，</p>
<ol>
<li>系统需要将实参以及返回地址传递给被调用的函数进行保存</li>
<li>将被调用的函数的局部变量分配到储存区</li>
<li>将控制转移到被调用的函数的入口</li>
</ol>
<p>从被调用函数返回到调用函数之前，</p>
<ol>
<li>保存被调用函数的计算结果</li>
<li>释放被调用函数中的数据区</li>
<li>依照被调用函数的保存的返回地址将控制转移至此</li>
</ol>
<h2 id="队列">队列</h2>
<h3 id="定义-1">定义</h3>
<p>队列也是一种重要的线性结构。与栈相同，实现一个队列也需要顺序表或者链表作为基础。但是与栈不同的是，队列是一种先进先出（FIFO）的线性表。其要求所有的数据从队列的一段进入，从队列的另一端离开。在队列中，允许插入数据的一端叫做队尾（rear），允许数据离开的一端叫做队头（front）。如图所示</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e9%98%9f%e5%88%97.jpg" alt=""  />
</p>
<h2 id="链队列">链队列</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> QNode {
	elem data;			<span style="color:#75715e">//数据域
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> QNode<span style="color:#f92672">*</span>next;	<span style="color:#75715e">//指针域
</span><span style="color:#75715e"></span>} QNode, <span style="color:#f92672">*</span>PNode;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	PNode front;		<span style="color:#75715e">//队头指针
</span><span style="color:#75715e"></span>	PNode rear;			<span style="color:#75715e">//队尾指针
</span><span style="color:#75715e"></span>} LinkQueue;
</code></pre></div><h4 id="创建一个队列">创建一个队列</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CreatQueue</span>(LinkQueue <span style="color:#f92672">*</span>q) {
	q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> (PNode)malloc(<span style="color:#66d9ef">sizeof</span>(QNode));

	<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> ERROR;
	}

	q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img1.jpg" alt=""  />
</p>
<h4 id="入队">入队</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PushQueue</span>(LinkQueue <span style="color:#f92672">*</span>q, elem e) {
	QNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (PNode)malloc(<span style="color:#66d9ef">sizeof</span>(QNode));
	<span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> NULL) {
		<span style="color:#66d9ef">return</span> ERROR;
	}
	p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
	p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
	q<span style="color:#f92672">-&gt;</span>rear<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
	q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> p;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img2.jpg" alt=""  />
</p>
<h4 id="出队">出队</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PopQueue</span>(LinkQueue <span style="color:#f92672">*</span>q) {
	<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">==</span> q<span style="color:#f92672">-&gt;</span>rear) {
		<span style="color:#66d9ef">return</span> ERROR;
	}

	QNode<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
	printf(<span style="color:#e6db74">&#34;%d &#34;</span>, p<span style="color:#f92672">-&gt;</span>data);
	q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
	<span style="color:#66d9ef">if</span> (q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">==</span> p) q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>front;

	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="销毁-2">销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DestroyQueue</span>(LinkQueue <span style="color:#f92672">*</span>q) {
	<span style="color:#66d9ef">while</span> (q<span style="color:#f92672">-&gt;</span>front) {
		q<span style="color:#f92672">-&gt;</span>rear <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>front<span style="color:#f92672">-&gt;</span>next;
		free(q<span style="color:#f92672">-&gt;</span>front);
		q<span style="color:#f92672">-&gt;</span>front <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>rear;
	}
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>单链表</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 30 Jan 2021 17:02:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
      <description>简单介绍了一下单链表</description>
      <content:encoded><![CDATA[<p>链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻，可以给每个元素附加一个指针域，指向下一个元素的存储位置。</p>
<!-- raw HTML omitted -->
<p>每个结点都包括数据域和指针域，指针域存储下一个结点的地址，因此指针指向的类型也是结点类型。</p>
<p>在顺序表中，想找第i个元素，就可以立即通过L.elem[i-1]找到，称为<em>随机存取</em>方式，而在单链表中，没那么容易，必须从头开始，按顺序一个一个来，一直数到第i个元素，称为<em>顺序存取</em>方式。</p>
<h3 id="头指针和头节点">头指针和头节点</h3>
<h4 id="基本概念">基本概念</h4>
<h5 id="头指针">头指针</h5>
<p><strong>通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。</strong></p>
<h5 id="头节点">头节点</h5>
<p><strong>在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。</strong></p>
<p><strong>[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。</strong></p>
<p>空链表
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e7%a9%ba%e9%93%be%e8%a1%a8.jpg" alt=""  />
</p>
<p>单链表
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%8d%95%e9%93%be%e8%a1%a8.jpg" alt=""  />
</p>
<h4 id="引入头结点的优势">引入头结点的优势</h4>
<p>链表可以没有头结点，但是必须要有头指针，因为要用头指针来标识一个链表。设链表的头指针为pHead。除了头结点之外，还需要一个指向链表一般元素的指针pNode（因为pHead只能指向表头，不能指向其他元素，故需要另设指针）。</p>
<h5 id="优势1第一个位置的插入删除特别方便">优势1：第一个位置的插入删除特别方便</h5>
<p>若使用头结点，则第1个位置的插入和删除都是对p—&gt;next进行操作，而不用动p本身，而且减少了if else分支，具体的流程为：</p>
<h6 id="插入操作如下">插入操作如下</h6>
<ol>
<li>p指向要插入结点的前驱结点，若要插入的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。</li>
<li>让新结点s的next指向p的next，即s—&gt;next = p—&gt;next;</li>
<li>让p—&gt;next指向s，即p—&gt;next = s;</li>
</ol>
<h6 id="删除操作如下">删除操作如下</h6>
<ol>
<li>p指向要删除结点的前驱结点，若要删除的结点为第1个位置，则其前驱结点就是头结点，此时p指向头结点。</li>
<li>让临时指针q指向要删除的结点，即q = p—&gt;next；</li>
<li>让p的next指向要删除结点的下一个结点，即p—&gt;next = q—&gt;next；</li>
<li>释放q的空间，即free(q);</li>
</ol>
<hr>
<p>若没有头结点，在第1个位置插入或删除时，需要动头指针。</p>
<h6 id="插入操作如下-1">插入操作如下</h6>
<ol>
<li>判断要插入的是否是第1个位置，若是需要特殊处理。</li>
<li>若是第1个位置，让新结点s的next指向头指针PtrL。</li>
<li>return s，此时s作为链表的头指针。此时的更新了链表的头指针。</li>
<li>若不是第1个位置，首先找到要插入结点的前驱结点，让p指向这个前驱结点。</li>
<li>让新结点s的next指向p的next，即s—&gt;next = p—&gt;next;</li>
<li>让p—&gt;next指向s，即p—&gt;next = s;</li>
<li>return PtrL，此时PtrL还是作为链表的头指针，没有被修改，但考虑到一致性需要这样写。</li>
</ol>
<h6 id="删除操作如下-1">删除操作如下</h6>
<ol>
<li>判断要删除的是否是第1个位置，若是需要特殊处理。</li>
<li>若是第1个位置，让s指向要删除的结点。首先判断PtrL是否为空，若是直接return NULL;若不为空，则将链表的头结点挪到下一个位置，即PtrL = PtrL—&gt;next；</li>
<li>free(s);然后return PtrL</li>
<li>若不是第1个位置，首先找到要删除结点的前驱结点，让p指向这个前驱结点。</li>
<li>让临时指针q指向要删除的结点，即q = p—&gt;next；</li>
<li>让p的next指向要删除结点的下一个结点，即p—&gt;next = q—&gt;next；</li>
<li>释放q的空间，即free(q);</li>
<li>return PtrL</li>
</ol>
<h5 id="优势2统一空表和非空表的处理">优势2：统一空表和非空表的处理</h5>
<p>若使用头结点，<em>无论表是否为空，头指针都指向头结点，也就是</em>LNode类型*，对于空表和非空表的操作是一致的。</p>
<p>若不使用头结点，<em>当表非空时，头指针指向第1个结点的地址，即</em>LNode类型，但是对于空表，头指针指向的是NULL*，此时空表和非空表的操作是不一致的。</p>
<h3 id="链表的建立">链表的建立</h3>
<h4 id="有头结点链表的建立">有头结点链表的建立</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;


<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> LNode{
    elem data;          <span style="color:#75715e">//数据域
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> LNode<span style="color:#f92672">*</span> next; <span style="color:#75715e">//指针域
</span><span style="color:#75715e"></span>}Node, <span style="color:#f92672">*</span>List;
</code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">HeadCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//带头结点_头插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s;
    List head <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));<span style="color:#75715e">//生成头结点
</span><span style="color:#75715e"></span>    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;<span style="color:#75715e">//头结点的指针域next指向s结点，使得s成为结点
</span><span style="color:#75715e"></span>    }   
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">TailCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//带头结点_尾插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s, <span style="color:#f92672">*</span>r;
    List head <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    r <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;
        r <span style="color:#f92672">=</span> s;
    }

    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL){
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    }
    
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><hr>
<p>下面这个是建立头结点与建立链表分离</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">CreatHNode</span>(){<span style="color:#75715e">//建立头结点
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s, <span style="color:#f92672">*</span>r;
    List head <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">HeadList</span>(List head, <span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//头插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;<span style="color:#75715e">//头结点的指针域next指向s结点，使得s成为结点
</span><span style="color:#75715e"></span>    }   
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">TailList</span>(List head, <span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//尾插法
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>s, <span style="color:#f92672">*</span>r;
    r <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>){
        s <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
        s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> i;
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;
        r <span style="color:#f92672">=</span> s;
    }

    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL){
        r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    }
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p>为了方便测试，先写出遍历并打印链表的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PrintList</span>(List head){<span style="color:#75715e">//打印链表数据
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>t <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
    <span style="color:#66d9ef">while</span> (t <span style="color:#f92672">!=</span> NULL){
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,t<span style="color:#f92672">-&gt;</span>data);
        t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next;
    }
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    <span style="color:#75715e">//head = HeadCreatList(10);
</span><span style="color:#75715e"></span>    head <span style="color:#f92672">=</span> TailCreatList(<span style="color:#ae81ff">10</span>);
    <span style="color:#75715e">//head = CreatHNode();
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//HeadList(head, 10);
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//TailList(head, 10);
</span><span style="color:#75715e"></span>    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="无头结点链表的建立">无头结点链表的建立</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">HeadCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//头插法
</span><span style="color:#75715e"></span>	List head <span style="color:#f92672">=</span> NULL;
	Node <span style="color:#f92672">*</span>p;
	<span style="color:#66d9ef">while</span>(n<span style="color:#f92672">--</span>){
		p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
		p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> n;
		<span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL){
			p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
			head <span style="color:#f92672">=</span> p;
		}
		<span style="color:#66d9ef">else</span>{
			p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
			head <span style="color:#f92672">=</span> p;
		}
	}
	<span style="color:#66d9ef">return</span> head;
}

</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">List <span style="color:#a6e22e">TailCreatList</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//尾插法
</span><span style="color:#75715e"></span>	List head <span style="color:#f92672">=</span> NULL;
	Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q;
	<span style="color:#66d9ef">while</span>(n<span style="color:#f92672">--</span>){
		p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
		p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> n;
		<span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL){
			head <span style="color:#f92672">=</span> p;
		}
		<span style="color:#66d9ef">else</span>{
			q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
		}
		p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
		q <span style="color:#f92672">=</span> p;
	}
	<span style="color:#66d9ef">return</span> head;
}
</code></pre></div><p>为了测试，先写出打印链表的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">PrintList</span>(List head){<span style="color:#75715e">//打印链表元素
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL){
		<span style="color:#66d9ef">return</span> ERROR;
    }
    Node <span style="color:#f92672">*</span>t <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">while</span>(t <span style="color:#f92672">!=</span> NULL){
        printf(<span style="color:#e6db74">&#34;%d&#34;</span>, t<span style="color:#f92672">-&gt;</span>data);		
        t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next;
    }
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>);
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>	List head;
	<span style="color:#75715e">//head = HeadCreatList(10);
</span><span style="color:#75715e"></span>	head <span style="color:#f92672">=</span> TailCreatList(<span style="color:#ae81ff">10</span>);
	PrintList(head);
	<span style="color:#66d9ef">return</span> ;
}
</code></pre></div><h3 id="链表的各个功能的实现有头结点">链表的各个功能的实现（有头结点）</h3>
<p>上面介绍了有无头结点对于功能实现的影响，接下来先使用有头结点的链表进行</p>
<h4 id="链表元素的添加">链表元素的添加</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表添加元素（插头）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">HeadInsertList</span>(List head,Node a){
    Node <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a.data;
    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
    head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表添加元素（插尾）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">TailInsertList</span>(List head,Node a){
    Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>t, <span style="color:#f92672">*</span>s;
    t <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
    p <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a.data;
    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">!=</span> NULL){
        s <span style="color:#f92672">=</span> t;
        t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next;
    }
    s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    <span style="color:#75715e">//HeadInsertList(head, a);
</span><span style="color:#75715e"></span>    TailInsertList(head, a);

    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的插入">链表元素的插入</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表的插入（插在之前）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InsertIndexFront</span>(List head,<span style="color:#66d9ef">int</span> i){
    Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q, <span style="color:#f92672">*</span>r;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    p <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">while</span>(p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> i){
        r <span style="color:#f92672">=</span> p;
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
        j<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j<span style="color:#f92672">&gt;</span>i){
        <span style="color:#66d9ef">return</span> ERROR;
    }

    q <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>data);
    q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p;
    r<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> q;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表的插入（插在之后）
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InsertIndexBack</span>(List head,<span style="color:#66d9ef">int</span> i){
    Node <span style="color:#f92672">*</span>p,<span style="color:#f92672">*</span>q;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    p <span style="color:#f92672">=</span> head;
    <span style="color:#66d9ef">while</span>(p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> i){
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
        j<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;</span> i){
        <span style="color:#66d9ef">return</span> ERROR;
    }

    q <span style="color:#f92672">=</span> (List)malloc(<span style="color:#66d9ef">sizeof</span>(Node));
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>data);
    q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> q;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">oid <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>        List head;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    InsertIndexFront(head,<span style="color:#ae81ff">2</span>);
    <span style="color:#75715e">//InsertIndexBack(head,2);
</span><span style="color:#75715e"></span>
    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的查找">链表元素的查找</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表元素的查找
</span><span style="color:#75715e"></span>elem <span style="color:#a6e22e">GetElem</span>(List head, <span style="color:#66d9ef">int</span> index){<span style="color:#75715e">//按序号查找
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> j;
    Node<span style="color:#f92672">*</span> p;
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向第一个数据结点
</span><span style="color:#75715e"></span>    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//j为计数器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> index ){ <span style="color:#75715e">//顺着链表向后扫描，直到p指向第i个元素或p为空
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向下一个结点
</span><span style="color:#75715e"></span>        j<span style="color:#f92672">++</span>; <span style="color:#75715e">//计数器j相应加1
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;</span> index)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">//i值不合法i＞n或i&lt;=0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>data;<span style="color:#75715e">//返回第i个结点的数据域
</span><span style="color:#75715e"></span>
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">elem <span style="color:#a6e22e">GetIndex</span>(List head, <span style="color:#66d9ef">int</span> e) {<span style="color:#75715e">//按值查找
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//在带头结点的单链表L中查找值为e的元素
</span><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> p;
    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;

    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">!=</span>e){
        <span style="color:#75715e">//顺链域向后扫描，直到p为空或p所指结点的数据域等于e
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向下一个结点
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>index;
    }
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p)
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">//查找失败p为NULL
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> index;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){
    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,GetElem(head,<span style="color:#ae81ff">6</span>));
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,GetIndex(head,<span style="color:#ae81ff">6</span>));

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的删除">链表元素的删除</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">DeleteList</span>(List head, <span style="color:#66d9ef">int</span> index) {<span style="color:#75715e">//单链表的删除
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//在带头结点的单链表L中，删除第i个位置
</span><span style="color:#75715e"></span>    Node <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>q;
    <span style="color:#66d9ef">int</span> j;
    p <span style="color:#f92672">=</span> head;
    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span>((p<span style="color:#f92672">-&gt;</span>next)<span style="color:#f92672">&amp;&amp;</span>(j <span style="color:#f92672">&lt;</span> index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) {<span style="color:#75715e">//查找第i-1个结点，p指向该结点
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;
        j<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(p<span style="color:#f92672">-&gt;</span>next)<span style="color:#f92672">||</span>(j <span style="color:#f92672">&gt;</span> index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))<span style="color:#75715e">//当i&gt;n或i&lt;1时，删除位置不合理
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ERROR;
    q <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//临时保存被删结点的地址以备释放空间
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//改变删除结点前驱结点的指针域
</span><span style="color:#75715e"></span>    free(q); <span style="color:#75715e">//释放被删除结点的空间
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    DeleteList(head,<span style="color:#ae81ff">4</span>);

    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的修改">链表元素的修改</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//链表元素的修改
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">ReverseElem</span>(List head, <span style="color:#66d9ef">int</span> index,<span style="color:#66d9ef">int</span> e){
    <span style="color:#66d9ef">int</span> j;
    Node<span style="color:#f92672">*</span> p;
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向第一个数据结点
</span><span style="color:#75715e"></span>    j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//j为计数器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;</span> index ){ <span style="color:#75715e">//顺着链表向后扫描，直到p指向第i个元素或p为空
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next; <span style="color:#75715e">//p指向下一个结点
</span><span style="color:#75715e"></span>        j<span style="color:#f92672">++</span>; <span style="color:#75715e">//计数器j相应加1
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p <span style="color:#f92672">||</span> j <span style="color:#f92672">&gt;</span> index)
        <span style="color:#66d9ef">return</span> ERROR; <span style="color:#75715e">//i值不合法i＞n或i&lt;=0
</span><span style="color:#75715e"></span>    p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> e;
    <span style="color:#66d9ef">return</span> OK;<span style="color:#75715e">//返回第i个结点的数据域
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    List head;
    Node a;
    a.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">666</span>;
    head <span style="color:#f92672">=</span> HeadCreatList(<span style="color:#ae81ff">10</span>);

    PrintList(head);

    ReverseElem(head,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">999</span>);

    PrintList(head);

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><h4 id="链表元素的清空">链表元素的清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//清空链表
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">ClearList</span>(List head)  
{  
    Node<span style="color:#f92672">*</span>p,<span style="color:#f92672">*</span>q;
    <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL)  
        <span style="color:#66d9ef">return</span> ERROR;  
    p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;  
    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">!=</span>NULL)  
    {  
        q<span style="color:#f92672">=</span>p<span style="color:#f92672">-&gt;</span>next;  
        free(p);  
        p<span style="color:#f92672">=</span>q;  
    }  
    head<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>NULL;  
    <span style="color:#66d9ef">return</span> OK;  
}
</code></pre></div><h4 id="链表元素的排序">链表元素的排序</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">SwapElem</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>j){<span style="color:#75715e">//交换数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span>  temp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>i;
    <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>j;
    <span style="color:#f92672">*</span>j <span style="color:#f92672">=</span> temp;
    <span style="color:#66d9ef">return</span> OK;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SortList</span>(List head){<span style="color:#75715e">//冒泡排序
</span><span style="color:#75715e"></span>    Node<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> NULL;
    Node<span style="color:#f92672">*</span> q <span style="color:#f92672">=</span> NULL;
    Node<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">if</span>(head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL){
        <span style="color:#66d9ef">return</span> ;
    }

    <span style="color:#66d9ef">for</span> ( p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; p <span style="color:#f92672">!=</span> NULL; p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next){
        <span style="color:#66d9ef">for</span> ( q <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next; q<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL; q <span style="color:#f92672">=</span> q<span style="color:#f92672">-&gt;</span>next){
            <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">&gt;</span> q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data){
                SwapElem(<span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>data, <span style="color:#f92672">&amp;</span>q<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>data);
            }
        }
    }
}
</code></pre></div><h4 id="无头结点链表的功能实现就不在此赘述所有源码都在githubhttpsgithubcom28251536datanote">无头结点链表的功能实现就不在此赘述，所有源码都在<a href="https://github.com/28251536/DataNote">Github</a></h4>
]]></content:encoded>
    </item>
    
    <item>
      <title>顺序表</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</link>
      <pubDate>Fri, 29 Jan 2021 17:38:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</guid>
      <description>简单介绍了一下顺序表</description>
      <content:encoded><![CDATA[<h3 id="概念">概念</h3>
<p>具有 <em>一对一</em> 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构（顺序表）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;time.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define MAXSIZE 100
</span><span style="color:#75715e">#define OK 1
</span><span style="color:#75715e">#define ERROR 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> elem;


<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Sqlist{
    elem <span style="color:#f92672">*</span>e;<span style="color:#75715e">//存储空间的及地址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length;<span style="color:#75715e">//长度
</span><span style="color:#75715e"></span>}Sqlist;
</code></pre></div><h3 id="功能的实现">功能的实现</h3>
<h4 id="顺序表的初始化">顺序表的初始化</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//数组的初始化
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InitArray</span>(Sqlist <span style="color:#f92672">*</span>L){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e) {<span style="color:#75715e">//判断指针是否为空
</span><span style="color:#75715e"></span>        free(L<span style="color:#f92672">-&gt;</span>e);
        L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">=</span> NULL;
    }

    L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">=</span> (elem<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> MAXSIZE);<span style="color:#75715e">//申请capacity大小的空间
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL){
        printf(<span style="color:#e6db74">&#34;内存分配失败!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);<span style="color:#75715e">//判断内存分配是否成功
</span><span style="color:#75715e"></span>        exit(<span style="color:#ae81ff">0</span>);
    }

    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的添加">元素的添加</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//添加元素
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">PushBackArray</span>(Sqlist <span style="color:#f92672">*</span>L,elem value){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL){
        printf(<span style="color:#e6db74">&#34;请初始化顺序表</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> ERROR;
    }

    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">==</span> MAXSIZE) {
        <span style="color:#66d9ef">return</span> ERROR;
    }
    L<span style="color:#f92672">-&gt;</span>e[L<span style="color:#f92672">-&gt;</span>length] <span style="color:#f92672">=</span> value;
    <span style="color:#f92672">++</span>L<span style="color:#f92672">-&gt;</span>length;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的插入">元素的插入</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//插入
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">InsertArray</span>(Sqlist <span style="color:#f92672">*</span>L,<span style="color:#66d9ef">int</span> index,elem value){
    <span style="color:#66d9ef">if</span>(index <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> index <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>){
        <span style="color:#66d9ef">return</span> ERROR;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>length; i <span style="color:#f92672">&gt;=</span> index; i<span style="color:#f92672">--</span>) {
		L<span style="color:#f92672">-&gt;</span>e[i] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>e[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
	}

	L<span style="color:#f92672">-&gt;</span>e[index] <span style="color:#f92672">=</span> value;

	<span style="color:#f92672">++</span>L<span style="color:#f92672">-&gt;</span>length;
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的查找">元素的查找</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据位置查找
</span><span style="color:#75715e"></span>elem <span style="color:#a6e22e">FindByIndex</span>(Sqlist<span style="color:#f92672">*</span> L,<span style="color:#66d9ef">int</span> index){
    <span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>e[index];
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据值查找
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">FindByValue</span>(Sqlist<span style="color:#f92672">*</span> L,elem value){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e[i] <span style="color:#f92672">==</span> value){
            <span style="color:#66d9ef">return</span> i;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
</code></pre></div><h4 id="元素的删除">元素的删除</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据值删除
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">RemoveByValue</span>(Sqlist<span style="color:#f92672">*</span> L,elem value){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e[i] <span style="color:#f92672">==</span> value){
	        <span style="color:#66d9ef">for</span> (; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
		        L<span style="color:#f92672">-&gt;</span>e[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>e[i];
	        }

	        <span style="color:#f92672">--</span>L<span style="color:#f92672">-&gt;</span>length;
	        <span style="color:#66d9ef">return</span> OK;
        }
    }
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//根据位置删除
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">RemoveByIndex</span>(Sqlist<span style="color:#f92672">*</span> L,<span style="color:#66d9ef">int</span> index){
	<span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> index <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) {
		<span style="color:#66d9ef">return</span> ERROR;
	}

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> index; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
		L<span style="color:#f92672">-&gt;</span>e[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> L<span style="color:#f92672">-&gt;</span>e[i];
	}

	<span style="color:#f92672">--</span>L<span style="color:#f92672">-&gt;</span>length;
	<span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="元素的清空">元素的清空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//清空
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">CleanArray</span>(Sqlist <span style="color:#f92672">*</span>L){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL) {
        printf(<span style="color:#e6db74">&#34;未初始化</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> ERROR;
    
    }

    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="线性表的销毁">线性表的销毁</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//销毁
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">FreeArray</span>(Sqlist<span style="color:#f92672">*</span> L){
    <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">!=</span> NULL){
        free(L<span style="color:#f92672">-&gt;</span>e);
        L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">=</span> NULL;
    }

    L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="获取当前长度">获取当前长度</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//长度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetLength</span>(Sqlist<span style="color:#f92672">*</span> L){
     <span style="color:#66d9ef">if</span>(L<span style="color:#f92672">-&gt;</span>e <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>length;
}
</code></pre></div><h4 id="判断是否为空">判断是否为空</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//判断是否为空
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">IsEmptyArray</span>(Sqlist <span style="color:#f92672">*</span>L){
    <span style="color:#66d9ef">return</span> L<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h4 id="顺序表的合并">顺序表的合并</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//合并
</span><span style="color:#75715e"></span>Status <span style="color:#a6e22e">CombineArray</span>(Sqlist <span style="color:#f92672">*</span>L1,Sqlist <span style="color:#f92672">*</span>L2){
    <span style="color:#66d9ef">if</span> (L1<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> L2<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">&gt;</span> MAXSIZE) {
        printf(<span style="color:#e6db74">&#34;空间不足，合并失败</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
		<span style="color:#66d9ef">return</span> ERROR;
	}

	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L2<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>) {
		L1<span style="color:#f92672">-&gt;</span>e[L1<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+</span> i] <span style="color:#f92672">=</span> L2<span style="color:#f92672">-&gt;</span>e[i];
	}
    L1<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">+=</span>L2<span style="color:#f92672">-&gt;</span>length;

    free(L2<span style="color:#f92672">-&gt;</span>e);
    L2<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><h4 id="顺序表的打印">顺序表的打印</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//打印
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PrintArray</span>(Sqlist<span style="color:#f92672">*</span> L){
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> L<span style="color:#f92672">-&gt;</span>length; i<span style="color:#f92672">++</span>){
        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,L<span style="color:#f92672">-&gt;</span>e[i]);
    }
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(){<span style="color:#75715e">//测试
</span><span style="color:#75715e"></span>    Sqlist L,L2;
      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/********初始化及添加元素********/</span>
    <span style="color:#75715e">/******************************/</span>
    InitArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//初始化顺序表
</span><span style="color:#75715e"></span>    InitArray(<span style="color:#f92672">&amp;</span>L2);
    <span style="color:#75715e">//srand(time(NULL));
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>){<span style="color:#75715e">//赋值
</span><span style="color:#75715e"></span>        PushBackArray(<span style="color:#f92672">&amp;</span>L,i);
        PushBackArray(<span style="color:#f92672">&amp;</span>L2,i);
    }
    printf(<span style="color:#e6db74">&#34;初始化...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
     <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/************插入元素***********/</span>
    <span style="color:#75715e">/******************************/</span>
    InsertArray(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">100</span>);<span style="color:#75715e">//插入元素
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;插入元素...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/************查找元素***********/</span>
    <span style="color:#75715e">/******************************/</span>
    printf(<span style="color:#e6db74">&#34;查找元素...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;%d &#34;</span>,FindByIndex(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">10</span>));<span style="color:#75715e">//根据位置查找
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d &#34;</span>,FindByValue(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">4</span>));<span style="color:#75715e">//根据值查找
</span><span style="color:#75715e"></span>


      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/************删除元素***********/</span>
    <span style="color:#75715e">/******************************/</span>
    RemoveByIndex(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">3</span>);<span style="color:#75715e">//根据位置删除
</span><span style="color:#75715e"></span>    RemoveByValue(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">9</span>);<span style="color:#75715e">//根据值删除
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;删除元素...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>

      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/***********合并顺序表**********/</span>
    <span style="color:#75715e">/******************************/</span>
    CombineArray(<span style="color:#f92672">&amp;</span>L,<span style="color:#f92672">&amp;</span>L2);<span style="color:#75715e">//合并
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;合并顺序表...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
     <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/***********清空顺序表**********/</span>
    <span style="color:#75715e">/******************************/</span>
    CleanArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//清空
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;清空顺序表...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    PrintArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//打印
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, GetLength(<span style="color:#f92672">&amp;</span>L));<span style="color:#75715e">//获取当前长度
</span><span style="color:#75715e"></span>
      <span style="color:#75715e">/******************************/</span>
     <span style="color:#75715e">/***********销毁顺序表**********/</span>
    <span style="color:#75715e">/******************************/</span>
    FreeArray(<span style="color:#f92672">&amp;</span>L);<span style="color:#75715e">//销毁
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;销毁顺序表...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>,PushBackArray(<span style="color:#f92672">&amp;</span>L,<span style="color:#ae81ff">1</span>));
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    test();
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>数据结构概括</title>
      <link>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Fri, 29 Jan 2021 16:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>基础知识</description>
      <content:encoded><![CDATA[<h3 id="数据">数据</h3>
<p>所有能够输入到计算机中的去的描述客观事物的符号</p>
<h3 id="数据元素">数据元素</h3>
<p>数据的基本单位，也称结点或记录</p>
<h3 id="数据结构">数据结构</h3>
<p>相互之间存在一种或多种特定关系的数据元素的集合</p>
<h3 id="逻辑结构和存储结构">逻辑结构和存储结构</h3>
<h4 id="逻辑结构">逻辑结构</h4>
<p>数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题抽象出来的数学模型。</p>
<h5 id="1集合">1.集合</h5>
<p>数据元素间除同属于一个集合外，无其他关系
集合中的元素是离散的、无序的、相互之间没有关系的</p>
<h5 id="2线性结构">2.线性结构</h5>
<p>一个对一个
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e7%ba%bf%e6%80%a7%e7%bb%93%e6%9e%84.jpg" alt=""  />
</p>
<ul>
<li>线性表</li>
<li>栈</li>
<li>队列
线性结构像是珠子穿在一根线上，不会分叉，有且只有唯一的开始和结束</li>
</ul>
<h5 id="3树形结构">3.树形结构</h5>
<p>一个对多个
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84.jpg" alt=""  />

树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支。树枝和树枝之间是不相交的。</p>
<ul>
<li>树</li>
</ul>
<h5 id="4图形结构">4.图形结构</h5>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e5%9b%be%e5%bd%a2%e7%bb%93%e6%9e%84.jpg" alt=""  />

图形结构就像我们经常见到的地图，任何一个结点都可能和其它结点有关系，就像一张错综复杂的网。</p>
<h4 id="存储结构">存储结构</h4>
<p>存储结构是数据元素及其关系在计算机中的存储方式。</p>
<h5 id="1顺序结构">1.顺序结构</h5>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e9%a1%ba%e5%ba%8f%e5%82%a8%e5%ad%98.jpg" alt=""  />

顺序存储在计算机内的存储位置是连续的，可以快速定位第几个元素的问题。中间不允许有空，所以插入、删除时需要移动大量元素。</p>
<h5 id="2链式结构">2.链式结构</h5>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/28251536/cloudimg@master/img%e9%93%be%e5%bc%8f%e5%82%a8%e5%ad%98.png" alt=""  />

链式存储就像一个铁链子，一环扣一环才能连在一起。每个结点除了数据域，还有一个指针域，记录下一个元素的存储地址。</p>
<h5 id="3散列机构">3.散列机构</h5>
<h5 id="4索引结构">4.索引结构</h5>
<h3 id="算法复杂性">算法复杂性</h3>
<h4 id="时间复杂度">时间复杂度</h4>
<p>程序运行所需的时间</p>
<ol>
<li>常数阶 O(1)</li>
<li>O(n)</li>
<li>O(n²)</li>
<li>O(log(n))-二分查找</li>
<li>O(nlogn)-快排</li>
</ol>
<h5 id="递归时间复杂度">递归时间复杂度</h5>
<p>O(T * depth)  T是每一次递归的时间复杂度</p>
<h5 id="最好最坏情况时间复杂度">最好最坏情况时间复杂度</h5>
<h5 id="平均时间复杂度">平均时间复杂度</h5>
<h4 id="空间复杂度">空间复杂度</h4>
<p>程序运行所需的空间</p>
<p>主要分为两部分：</p>
<ol>
<li>固定部分：指令空间、数据空间（静态空间）</li>
<li>可变空间：动态分配的空间</li>
</ol>
<p>S(n) = O(f(n))</p>]]></content:encoded>
    </item>
    
    <item>
      <title>Hello Test</title>
      <link>https://www.niuwx.cn/posts/hello/hello-test/</link>
      <pubDate>Tue, 12 Jan 2021 22:33:51 +0800</pubDate>
      
      <guid>https://www.niuwx.cn/posts/hello/hello-test/</guid>
      <description>Desc Text.</description>
      <content:encoded><![CDATA[<p><strong>This is a test for hugo.</strong></p>
<h2 id="1">1</h2>
<h3 id="2">2</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello World&#34;</span>)
}
</code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title></title>
      <link>https://www.niuwx.cn/friends/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.niuwx.cn/friends/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    
    
  </channel>
</rss>
